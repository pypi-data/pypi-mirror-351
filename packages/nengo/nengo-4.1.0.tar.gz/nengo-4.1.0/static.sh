#!/usr/bin/env bash

# Automatically generated by nengo-bones, do not edit this file directly

NAME=$0
COMMAND=$1
STATUS=0  # used to exit with non-zero status if any command fails
# shellcheck disable=SC2034
SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

export JOB_NUMBER="$GITHUB_RUN_ID-$GITHUB_RUN_ATTEMPT"
if [[ -n "$JOB_SUFFIX" ]]; then
    export JOB_NUMBER="$JOB_NUMBER-$JOB_SUFFIX"
fi
export GIT_BRANCH="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"
if [[ "$GITHUB_REF_TYPE" == "tag" ]]; then
    export GIT_TAG="$GIT_BRANCH"
fi

exe() {
    echo "\$ $*";
    # remove empty spaces from args
    args=( "$@" )
    for i in "${!args[@]}"; do
      [ -n "${args[$i]}" ] || unset "args[$i]"
    done
    "${args[@]}" || { echo -e "\033[1;31mCOMMAND '${args[0]}' FAILED\033[0m"; STATUS=1; }
}

if [[ ! -e nengo ]]; then
    echo "Run this script from the root directory of this repository"
    exit 1
fi


shopt -s globstar

if [[ "$COMMAND" == "install" ]]; then
    :


    exe pip install \
        "jupyter>=1.0.0" \
        "pylint>=2.13.9" \
        "codespell>=2.2.1" \
        "gitlint>=0.18.0" \
        "flake8>=5.0.4" \
        "isort>=5.10.1" \
        "docformatter==1.5.0"
elif [[ "$COMMAND" == "script" ]]; then

    exe pylint nengo --jobs=0
    exe flake8 nengo
    exe isort nengo --check
    if [[ -d docs ]]; then
        exe bones format-notebook docs --verbose --check
    fi
    exe black --check nengo
    exe codespell -q 3
    exe shellcheck "$SCRIPT_DIR"/*.sh
    exe docformatter --check -r nengo

    # undo single-branch cloning
    git config --replace-all remote.origin.fetch +refs/heads/*:refs/remotes/origin/*
    git fetch origin main
    N_COMMITS=$(git rev-list --count HEAD ^origin/main)
    for ((i=0; i<N_COMMITS; i++)) do
        git log -n 1 --skip "$i" --pretty=%B \
            | grep -v '^Co-authored-by:' \
            | gitlint -vvv || STATUS=1
    done

elif [[ "$COMMAND" == "after_success" ]]; then
    :
elif [[ "$COMMAND" == "after_failure" ]]; then
    :
elif [[ "$COMMAND" == "after_script" ]]; then
    :
elif [[ -z "$COMMAND" ]]; then
    echo "$NAME requires a command like 'install' or 'script'"
else
    echo "$NAME does not define $COMMAND"
fi

exit "$STATUS"
