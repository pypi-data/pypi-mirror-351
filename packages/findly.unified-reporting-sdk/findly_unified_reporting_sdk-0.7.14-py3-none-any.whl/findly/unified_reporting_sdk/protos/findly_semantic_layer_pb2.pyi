"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _DataSourceIntegration:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _DataSourceIntegrationEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DataSourceIntegration.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    DATA_SOURCE_LOCATION_UNKNOWN: _DataSourceIntegration.ValueType  # 0
    SEMANTIC_LAYER: _DataSourceIntegration.ValueType  # 1
    GA4: _DataSourceIntegration.ValueType  # 2
    FB_ADS: _DataSourceIntegration.ValueType  # 3

class DataSourceIntegration(_DataSourceIntegration, metaclass=_DataSourceIntegrationEnumTypeWrapper): ...

DATA_SOURCE_LOCATION_UNKNOWN: DataSourceIntegration.ValueType  # 0
SEMANTIC_LAYER: DataSourceIntegration.ValueType  # 1
GA4: DataSourceIntegration.ValueType  # 2
FB_ADS: DataSourceIntegration.ValueType  # 3
global___DataSourceIntegration = DataSourceIntegration

class _DateGranularity:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _DateGranularityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DateGranularity.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN: _DateGranularity.ValueType  # 0
    DAY: _DateGranularity.ValueType  # 1
    WEEK: _DateGranularity.ValueType  # 2
    MONTH: _DateGranularity.ValueType  # 3
    QUARTER: _DateGranularity.ValueType  # 4
    YEAR: _DateGranularity.ValueType  # 5

class DateGranularity(_DateGranularity, metaclass=_DateGranularityEnumTypeWrapper): ...

UNKNOWN: DateGranularity.ValueType  # 0
DAY: DateGranularity.ValueType  # 1
WEEK: DateGranularity.ValueType  # 2
MONTH: DateGranularity.ValueType  # 3
QUARTER: DateGranularity.ValueType  # 4
YEAR: DateGranularity.ValueType  # 5
global___DateGranularity = DateGranularity

class _Aggregation:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _AggregationEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Aggregation.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    AGGREGATION_UNKNOWN: _Aggregation.ValueType  # 0
    SUM: _Aggregation.ValueType  # 1
    SUM_BOOLEAN: _Aggregation.ValueType  # 2
    COUNT_DISTINCT: _Aggregation.ValueType  # 3
    MIN: _Aggregation.ValueType  # 4
    MAX: _Aggregation.ValueType  # 5
    AVERAGE: _Aggregation.ValueType  # 6
    MEDIAN: _Aggregation.ValueType  # 7

class Aggregation(_Aggregation, metaclass=_AggregationEnumTypeWrapper): ...

AGGREGATION_UNKNOWN: Aggregation.ValueType  # 0
SUM: Aggregation.ValueType  # 1
SUM_BOOLEAN: Aggregation.ValueType  # 2
COUNT_DISTINCT: Aggregation.ValueType  # 3
MIN: Aggregation.ValueType  # 4
MAX: Aggregation.ValueType  # 5
AVERAGE: Aggregation.ValueType  # 6
MEDIAN: Aggregation.ValueType  # 7
global___Aggregation = Aggregation

class _DimensionType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _DimensionTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DimensionType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    DIMENSION_UNKNOWN: _DimensionType.ValueType  # 0
    CATEGORICAL: _DimensionType.ValueType  # 1
    """Category dimensions allow metrics to be grouped by different "category" slices and dices, such as product type, color, or geographical area. 
    These may point to existing columns in the data table, or be calculated using a SQL expression with the expr parameter.
    """
    TIME: _DimensionType.ValueType  # 2
    """Time dimensions are used to aggregate metrics against different levels of time granularity. 
    An Aggregation time dimension for measures must be set! This should either be set directly on the measure specification in the model, or else defaulted to the primary time dimension in the data source containing the measure.
    """
    FB_ADS_FIELD: _DimensionType.ValueType  # 3
    """Here are the possible types for FB Ads Dimensions"""
    FB_ADS_BREAKDOWN: _DimensionType.ValueType  # 4
    FB_ADS_ACTION_BREAKDOWN: _DimensionType.ValueType  # 5
    FB_ADS_SUMMARY_ACTION_BREAKDOWN: _DimensionType.ValueType  # 6

class DimensionType(_DimensionType, metaclass=_DimensionTypeEnumTypeWrapper): ...

DIMENSION_UNKNOWN: DimensionType.ValueType  # 0
CATEGORICAL: DimensionType.ValueType  # 1
"""Category dimensions allow metrics to be grouped by different "category" slices and dices, such as product type, color, or geographical area. 
These may point to existing columns in the data table, or be calculated using a SQL expression with the expr parameter.
"""
TIME: DimensionType.ValueType  # 2
"""Time dimensions are used to aggregate metrics against different levels of time granularity. 
An Aggregation time dimension for measures must be set! This should either be set directly on the measure specification in the model, or else defaulted to the primary time dimension in the data source containing the measure.
"""
FB_ADS_FIELD: DimensionType.ValueType  # 3
"""Here are the possible types for FB Ads Dimensions"""
FB_ADS_BREAKDOWN: DimensionType.ValueType  # 4
FB_ADS_ACTION_BREAKDOWN: DimensionType.ValueType  # 5
FB_ADS_SUMMARY_ACTION_BREAKDOWN: DimensionType.ValueType  # 6
global___DimensionType = DimensionType

class _DimensionValueType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _DimensionValueTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DimensionValueType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    VALUE_TYPE_UNKNOWN: _DimensionValueType.ValueType  # 0
    STRING: _DimensionValueType.ValueType  # 1
    INTEGER: _DimensionValueType.ValueType  # 2
    FLOAT: _DimensionValueType.ValueType  # 3
    BOOLEAN: _DimensionValueType.ValueType  # 4
    DATE: _DimensionValueType.ValueType  # 5
    DATETIME: _DimensionValueType.ValueType  # 6
    TIMESTAMP: _DimensionValueType.ValueType  # 7

class DimensionValueType(_DimensionValueType, metaclass=_DimensionValueTypeEnumTypeWrapper): ...

VALUE_TYPE_UNKNOWN: DimensionValueType.ValueType  # 0
STRING: DimensionValueType.ValueType  # 1
INTEGER: DimensionValueType.ValueType  # 2
FLOAT: DimensionValueType.ValueType  # 3
BOOLEAN: DimensionValueType.ValueType  # 4
DATE: DimensionValueType.ValueType  # 5
DATETIME: DimensionValueType.ValueType  # 6
TIMESTAMP: DimensionValueType.ValueType  # 7
global___DimensionValueType = DimensionValueType

class _MetricType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MetricTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MetricType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    METRIC_UNKNOWN: _MetricType.ValueType  # 0
    MEASURE_PROXY: _MetricType.ValueType  # 1
    """Measure proxies are metrics that point directly to a measure (you may think of the measure proxy as a function that takes only ONE measure as the input).
    Note that if a measure has already been defined in a data source with the create_metric: True parameter, you do not need to re-define a metric for the measure, and you can simply use the measure itself. 
    However, if you would like to include a constraint on top of the measure, you will need to create a measure proxy.
    For example, if you would like to create a metric that only includes orders with a price greater than 100, you can create a measure proxy with the constraint price > 100.
    If using a measure proxy, you must specify the measure in the measures parameter. Don't use the expression field as it will be ignored.
    """
    CUMULATIVE: _MetricType.ValueType  # 2
    """Cumulative metrics aggregate a measure over a given window. 
    Note that if no window is specified, the window would accumulate the measure over all time.
    """
    RATIO: _MetricType.ValueType  # 3
    """Ratio metrics involve a numerator measure and a denominator measure. 
    Note that if an optional constraint string is applied, the constraint is applied to both the numerator and denominator.
    """
    DERIVED: _MetricType.ValueType  # 4
    SQL_EXPRESSION: _MetricType.ValueType  # 5
    """When you are building a metric that involves a SQL expression of multiple measures, you can use an expression metric."""

class MetricType(_MetricType, metaclass=_MetricTypeEnumTypeWrapper):
    """Based on https://docs.getdbt.com/docs/build/metrics-
    Only MEASURE_PROXY and RATIO are supported for now. Don't use the other types.
    """

METRIC_UNKNOWN: MetricType.ValueType  # 0
MEASURE_PROXY: MetricType.ValueType  # 1
"""Measure proxies are metrics that point directly to a measure (you may think of the measure proxy as a function that takes only ONE measure as the input).
Note that if a measure has already been defined in a data source with the create_metric: True parameter, you do not need to re-define a metric for the measure, and you can simply use the measure itself. 
However, if you would like to include a constraint on top of the measure, you will need to create a measure proxy.
For example, if you would like to create a metric that only includes orders with a price greater than 100, you can create a measure proxy with the constraint price > 100.
If using a measure proxy, you must specify the measure in the measures parameter. Don't use the expression field as it will be ignored.
"""
CUMULATIVE: MetricType.ValueType  # 2
"""Cumulative metrics aggregate a measure over a given window. 
Note that if no window is specified, the window would accumulate the measure over all time.
"""
RATIO: MetricType.ValueType  # 3
"""Ratio metrics involve a numerator measure and a denominator measure. 
Note that if an optional constraint string is applied, the constraint is applied to both the numerator and denominator.
"""
DERIVED: MetricType.ValueType  # 4
SQL_EXPRESSION: MetricType.ValueType  # 5
"""When you are building a metric that involves a SQL expression of multiple measures, you can use an expression metric."""
global___MetricType = MetricType

class _MetricValueType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _MetricValueTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_MetricValueType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    METRIC_VALUE_TYPE_UNKNOWN: _MetricValueType.ValueType  # 0
    """These are the types from GA4"""
    METRIC_VALUE_TYPE_INTEGER: _MetricValueType.ValueType  # 1
    """Integer type."""
    METRIC_VALUE_TYPE_FLOAT: _MetricValueType.ValueType  # 2
    """Floating point type."""
    METRIC_VALUE_TYPE_SECONDS: _MetricValueType.ValueType  # 3
    """A duration of seconds; a special floating point type."""
    METRIC_VALUE_TYPE_MILLISECONDS: _MetricValueType.ValueType  # 4
    """A duration in milliseconds; a special floating point type."""
    METRIC_VALUE_TYPE_MINUTES: _MetricValueType.ValueType  # 5
    """A duration in minutes; a special floating point type."""
    METRIC_VALUE_TYPE_HOURS: _MetricValueType.ValueType  # 6
    """A duration in hours; a special floating point type."""
    METRIC_VALUE_TYPE_STANDARD: _MetricValueType.ValueType  # 7
    """A custom metric of standard type; a special floating point type."""
    METRIC_VALUE_TYPE_CURRENCY: _MetricValueType.ValueType  # 8
    """An amount of money; a special floating point type."""
    METRIC_VALUE_TYPE_FEET: _MetricValueType.ValueType  # 9
    """A length in feet; a special floating point type."""
    METRIC_VALUE_TYPE_MILES: _MetricValueType.ValueType  # 10
    """A length in miles; a special floating point type."""
    METRIC_VALUE_TYPE_METERS: _MetricValueType.ValueType  # 11
    """A length in meters; a special floating point type."""
    METRIC_VALUE_TYPE_KILOMETERS: _MetricValueType.ValueType  # 12
    """A length in kilometers; a special floating point type."""
    METRIC_VALUE_TYPE_STRING: _MetricValueType.ValueType  # 13
    """Now, these are the types from FB ADS."""
    METRIC_VALUE_TYPE_NUMERIC_STRING: _MetricValueType.ValueType  # 14
    METRIC_VALUE_TYPE_LIST_ADS_ACTION_STATS: _MetricValueType.ValueType  # 15
    """A single action for a Statistics result -> https://github.com/facebook/facebook-python-business-sdk/blob/main/facebook_business/adobjects/adsactionstats.py"""
    METRIC_VALUE_TYPE_LIST_ADS_INSIGHTS_DDA_RESULT: _MetricValueType.ValueType  # 16
    METRIC_VALUE_TYPE_LIST_ADS_HISTOGRAM_STATS: _MetricValueType.ValueType  # 17

class MetricValueType(_MetricValueType, metaclass=_MetricValueTypeEnumTypeWrapper):
    """The value type of the metric, e.g. INTEGER, FLOAT, etc.
    Based on https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/MetricType.
    And also on https://developers.facebook.com/docs/marketing-api/reference/ad-account/insights/.
    """

METRIC_VALUE_TYPE_UNKNOWN: MetricValueType.ValueType  # 0
"""These are the types from GA4"""
METRIC_VALUE_TYPE_INTEGER: MetricValueType.ValueType  # 1
"""Integer type."""
METRIC_VALUE_TYPE_FLOAT: MetricValueType.ValueType  # 2
"""Floating point type."""
METRIC_VALUE_TYPE_SECONDS: MetricValueType.ValueType  # 3
"""A duration of seconds; a special floating point type."""
METRIC_VALUE_TYPE_MILLISECONDS: MetricValueType.ValueType  # 4
"""A duration in milliseconds; a special floating point type."""
METRIC_VALUE_TYPE_MINUTES: MetricValueType.ValueType  # 5
"""A duration in minutes; a special floating point type."""
METRIC_VALUE_TYPE_HOURS: MetricValueType.ValueType  # 6
"""A duration in hours; a special floating point type."""
METRIC_VALUE_TYPE_STANDARD: MetricValueType.ValueType  # 7
"""A custom metric of standard type; a special floating point type."""
METRIC_VALUE_TYPE_CURRENCY: MetricValueType.ValueType  # 8
"""An amount of money; a special floating point type."""
METRIC_VALUE_TYPE_FEET: MetricValueType.ValueType  # 9
"""A length in feet; a special floating point type."""
METRIC_VALUE_TYPE_MILES: MetricValueType.ValueType  # 10
"""A length in miles; a special floating point type."""
METRIC_VALUE_TYPE_METERS: MetricValueType.ValueType  # 11
"""A length in meters; a special floating point type."""
METRIC_VALUE_TYPE_KILOMETERS: MetricValueType.ValueType  # 12
"""A length in kilometers; a special floating point type."""
METRIC_VALUE_TYPE_STRING: MetricValueType.ValueType  # 13
"""Now, these are the types from FB ADS."""
METRIC_VALUE_TYPE_NUMERIC_STRING: MetricValueType.ValueType  # 14
METRIC_VALUE_TYPE_LIST_ADS_ACTION_STATS: MetricValueType.ValueType  # 15
"""A single action for a Statistics result -> https://github.com/facebook/facebook-python-business-sdk/blob/main/facebook_business/adobjects/adsactionstats.py"""
METRIC_VALUE_TYPE_LIST_ADS_INSIGHTS_DDA_RESULT: MetricValueType.ValueType  # 16
METRIC_VALUE_TYPE_LIST_ADS_HISTOGRAM_STATS: MetricValueType.ValueType  # 17
global___MetricValueType = MetricValueType

@typing.final
class Dimension(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    EXPR_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    TYPE_PARAMS_FIELD_NUMBER: builtins.int
    TOP_N_VALUES_FIELD_NUMBER: builtins.int
    VALUE_TYPE_FIELD_NUMBER: builtins.int
    DATA_SOURCE_NAMES_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    VALUE_TYPE_ENUM_FIELD_NUMBER: builtins.int
    name: builtins.str
    """The name of the dimension."""
    description: builtins.str
    """The description of the dimension."""
    expr: builtins.str
    """The expression defining the dimension e.g. order_id
    Beware that there is no matching signature for operator BETWEEN for argument type DATETIME
    And we want to define a date range of interest for our queries
    Use DATE_TRUNC(CAST(dimension.name, DATETIME), DateGranularity) to ensure we can use WHERE date range correctly
    """
    type: global___DimensionType.ValueType
    """The type of the dimension, e.g. CATEGORICAL or TIME."""
    value_type: builtins.str
    """The type of the values of the dimension, e.g. STRING, INTEGER, FLOAT, etc.
    Prefer to use the value_type_enum field
    """
    display_name: builtins.str
    """The display name."""
    value_type_enum: global___DimensionValueType.ValueType
    @property
    def type_params(self) -> global___DimensionTypeParams:
        """The parameters of the dimension type."""

    @property
    def top_n_values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The top n values of the dimension."""

    @property
    def data_source_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The data source names that the dimension is available in."""

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        description: builtins.str = ...,
        expr: builtins.str = ...,
        type: global___DimensionType.ValueType = ...,
        type_params: global___DimensionTypeParams | None = ...,
        top_n_values: collections.abc.Iterable[builtins.str] | None = ...,
        value_type: builtins.str = ...,
        data_source_names: collections.abc.Iterable[builtins.str] | None = ...,
        display_name: builtins.str = ...,
        value_type_enum: global___DimensionValueType.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["type_params", b"type_params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["data_source_names", b"data_source_names", "description", b"description", "display_name", b"display_name", "expr", b"expr", "name", b"name", "top_n_values", b"top_n_values", "type", b"type", "type_params", b"type_params", "value_type", b"value_type", "value_type_enum", b"value_type_enum"]) -> None: ...

global___Dimension = Dimension

@typing.final
class DimensionTypeParams(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TIME_GRANULARITY_FIELD_NUMBER: builtins.int
    IS_PRIMARY_FIELD_NUMBER: builtins.int
    time_granularity: global___DateGranularity.ValueType
    """The date granularity of the dimension if it is a time dimension."""
    is_primary: builtins.bool
    """Note for Time dimensions: For data sources with a measure involved, a primary time dimension is required (notice the is_primary: True parameter).
    Set the is_primary parameter to True to indicate the time dimension that is to be the primary, or preferred, time dimension for a measure (or metric).
    """
    def __init__(
        self,
        *,
        time_granularity: global___DateGranularity.ValueType = ...,
        is_primary: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["is_primary", b"is_primary", "time_granularity", b"time_granularity"]) -> None: ...

global___DimensionTypeParams = DimensionTypeParams

@typing.final
class Metric(google.protobuf.message.Message):
    """Parameters that are associated with metrics include:

    name: Provide the reference name for the metric. This name must be unique amongst all metrics.
    owners: Define the list of Technical Owners of this metric via email. 
    type: Define the type of metric, which can be a measure (measure_proxy), ratio (ratio), SQL expression (expr), or cumulative (cumulative).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    EXPRESSION_FIELD_NUMBER: builtins.int
    VIEW_ID_OF_TABLE_FIELD_NUMBER: builtins.int
    TABLE_NAME_FIELD_NUMBER: builtins.int
    MEASURES_FIELD_NUMBER: builtins.int
    NUMERATOR_FIELD_NUMBER: builtins.int
    DENOMINATOR_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    WINDOW_FIELD_NUMBER: builtins.int
    GRAIN_TO_DATE_FIELD_NUMBER: builtins.int
    VALUE_TYPE_FIELD_NUMBER: builtins.int
    DISPLAY_NAME_FIELD_NUMBER: builtins.int
    IS_NUMERIC_FIELD_NUMBER: builtins.int
    id: builtins.str
    """The unique identifier of the metric."""
    name: builtins.str
    """The name of the metric."""
    description: builtins.str
    """The description of the metric.
    The metric name and description should correctly translate the metric's expression.
    """
    expression: builtins.str
    """The expression defining the metric e.g. revenue would have 
    expression = transactions.price * transactions.quantity
    Shouldn't be used if type is MEASURE_PROXY.
    Always create simple expressions. If you need to create a complex expression, create a measure in the data source and use it in the metric.
    Two different metrics should not have the same expression. 
    e.g. x+y , x-y, x*y, x/y, x%y, x^y, x/y*z, x+y*z, x-y*z, x+y/z, x-y/z, etc.
    """
    view_id_of_table: builtins.str
    """The id of the table view that the metric is defined on."""
    table_name: builtins.str
    """The name of the table view that the metric is defined on."""
    numerator: builtins.str
    """Numerator and denominator are only used if type is RATIO. Don't use identifiers as numerator or denominator.
    It should be included only measures that are defined in a data source.
    We also probably don't want the numerator and denominator to be the same measure.
    Do not use another metric for the numerator or denominator. You should use measures present in a data source.
    The numerator of the metric if it is a ratio metric. It should be a measure.
    """
    denominator: builtins.str
    """The denominator of the metric if it is a ratio metric. It should be a measure."""
    type: global___MetricType.ValueType
    """The type of the metric, e.g. MEASURE_PROXY, CUMULATIVE, RATIO, etc.
    If the type is MEASURE_PROXY, the name of the metric must match the measure name in the expression
    """
    window: builtins.str
    """The window of the metric if it is a cumulative metric."""
    grain_to_date: builtins.str
    """The grain of the metric if it is a cumulative metric."""
    value_type: global___MetricValueType.ValueType
    """The value type of the metric, e.g. INTEGER, FLOAT, etc.
    Always set this field to METRIC_VALUE_TYPE_UNKNOWN = 0
    """
    display_name: builtins.str
    is_numeric: builtins.bool
    """If the metric is numeric or not."""
    @property
    def measures(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The measures of the metric.
        If type is MEASURE_PROXY, then this should be a list of exactly one measure.
        It should be included only measures that are defined in a data source.
        Two metrics of type MEASURE_PROXY cannot refer to the same measure.
        """

    def __init__(
        self,
        *,
        id: builtins.str = ...,
        name: builtins.str = ...,
        description: builtins.str = ...,
        expression: builtins.str = ...,
        view_id_of_table: builtins.str = ...,
        table_name: builtins.str = ...,
        measures: collections.abc.Iterable[builtins.str] | None = ...,
        numerator: builtins.str = ...,
        denominator: builtins.str = ...,
        type: global___MetricType.ValueType = ...,
        window: builtins.str = ...,
        grain_to_date: builtins.str = ...,
        value_type: global___MetricValueType.ValueType = ...,
        display_name: builtins.str = ...,
        is_numeric: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["cumulative_process", b"cumulative_process", "grain_to_date", b"grain_to_date", "window", b"window"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["cumulative_process", b"cumulative_process", "denominator", b"denominator", "description", b"description", "display_name", b"display_name", "expression", b"expression", "grain_to_date", b"grain_to_date", "id", b"id", "is_numeric", b"is_numeric", "measures", b"measures", "name", b"name", "numerator", b"numerator", "table_name", b"table_name", "type", b"type", "value_type", b"value_type", "view_id_of_table", b"view_id_of_table", "window", b"window"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["cumulative_process", b"cumulative_process"]) -> typing.Literal["window", "grain_to_date"] | None: ...

global___Metric = Metric

@typing.final
class DateStrRange(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_DATE_FIELD_NUMBER: builtins.int
    END_DATE_FIELD_NUMBER: builtins.int
    start_date: builtins.str
    """Start date in the format YYYY-MM-DD."""
    end_date: builtins.str
    """End date in the format YYYY-MM-DD."""
    def __init__(
        self,
        *,
        start_date: builtins.str = ...,
        end_date: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["end_date", b"end_date", "start_date", b"start_date"]) -> None: ...

global___DateStrRange = DateStrRange

@typing.final
class QueryArgs(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WHERE_CLAUSE_FIELD_NUMBER: builtins.int
    GROUP_BY_COLUMNS_FIELD_NUMBER: builtins.int
    METRICS_EXPRESSION_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    ORDER_BY_FIELD_NUMBER: builtins.int
    DATE_WHERE_CLAUSE_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    HAVING_CLAUSE_FIELD_NUMBER: builtins.int
    INCOMPATIBLE_METRICS_FIELD_NUMBER: builtins.int
    INCOMPATIBLE_DIMENSIONS_FIELD_NUMBER: builtins.int
    DATE_RANGES_FIELD_NUMBER: builtins.int
    SQL_EXPLANATION_FIELD_NUMBER: builtins.int
    LEVEL_FIELD_NUMBER: builtins.int
    TIME_INCREMENT_FIELD_NUMBER: builtins.int
    MAIN_DATA_SOURCE_NAME_FIELD_NUMBER: builtins.int
    where_clause: builtins.str
    """This is the where clause of the generated sql."""
    limit: builtins.str
    """This is the LIMIT clause of the generated sql."""
    date_where_clause: builtins.str
    having_clause: builtins.str
    sql_explanation: builtins.str
    """The explanation of the generated sql."""
    level: builtins.str
    """level and time_increment are important info for Facebook Ads insights
    https://developers.facebook.com/docs/marketing-api/reference/ad-account/insights/
    """
    time_increment: builtins.str
    main_data_source_name: builtins.str
    @property
    def group_by_columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """This is the group by clause of the generated sql."""

    @property
    def metrics_expression(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """This is the metric expression of the generated sql."""

    @property
    def order_by(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Column names for ordering. Descending order is indicated by a prepended '-'."""

    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The name of the metrics to be queried."""

    @property
    def incompatible_metrics(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The list of metrics selected by the pipeline, but are incompatible for the request."""

    @property
    def incompatible_dimensions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The list of dimensions selected by the pipeline, but are incompatible for the request."""

    @property
    def date_ranges(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___DateStrRange]:
        """The date ranges to be queried."""

    def __init__(
        self,
        *,
        where_clause: builtins.str = ...,
        group_by_columns: collections.abc.Iterable[builtins.str] | None = ...,
        metrics_expression: collections.abc.Iterable[builtins.str] | None = ...,
        limit: builtins.str = ...,
        order_by: collections.abc.Iterable[builtins.str] | None = ...,
        date_where_clause: builtins.str = ...,
        metrics: collections.abc.Iterable[builtins.str] | None = ...,
        having_clause: builtins.str = ...,
        incompatible_metrics: collections.abc.Iterable[builtins.str] | None = ...,
        incompatible_dimensions: collections.abc.Iterable[builtins.str] | None = ...,
        date_ranges: collections.abc.Iterable[global___DateStrRange] | None = ...,
        sql_explanation: builtins.str = ...,
        level: builtins.str = ...,
        time_increment: builtins.str = ...,
        main_data_source_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["date_ranges", b"date_ranges", "date_where_clause", b"date_where_clause", "group_by_columns", b"group_by_columns", "having_clause", b"having_clause", "incompatible_dimensions", b"incompatible_dimensions", "incompatible_metrics", b"incompatible_metrics", "level", b"level", "limit", b"limit", "main_data_source_name", b"main_data_source_name", "metrics", b"metrics", "metrics_expression", b"metrics_expression", "order_by", b"order_by", "sql_explanation", b"sql_explanation", "time_increment", b"time_increment", "where_clause", b"where_clause"]) -> None: ...

global___QueryArgs = QueryArgs

@typing.final
class DatasourceMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LOCATION_FIELD_NUMBER: builtins.int
    PROPERTY_ID_FIELD_NUMBER: builtins.int
    PROPERTY_NAME_FIELD_NUMBER: builtins.int
    location: global___DataSourceIntegration.ValueType
    property_id: builtins.str
    property_name: builtins.str
    def __init__(
        self,
        *,
        location: global___DataSourceIntegration.ValueType = ...,
        property_id: builtins.str = ...,
        property_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["location", b"location", "property_id", b"property_id", "property_name", b"property_name"]) -> None: ...

global___DatasourceMetadata = DatasourceMetadata
