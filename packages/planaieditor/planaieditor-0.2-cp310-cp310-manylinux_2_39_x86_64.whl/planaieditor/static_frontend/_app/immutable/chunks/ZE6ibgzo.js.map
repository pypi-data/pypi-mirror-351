{"version":3,"file":"ZE6ibgzo.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/store.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn\n * @param {[number,number]} [elseif]\n * @returns {void}\n */\nexport function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {\n\tif (hydrating && root_index === 0) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (\n\t\t/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,\n\t\tflag = true\n\t) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating && hydrate_index !== -1) {\n\t\t\tif (root_index === 0) {\n\t\t\t\tconst data = /** @type {Comment} */ (anchor).data;\n\t\t\t\tif (data === HYDRATION_START) {\n\t\t\t\t\thydrate_index = 0;\n\t\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\t\thydrate_index = Infinity;\n\t\t\t\t} else {\n\t\t\t\t\thydrate_index = parseInt(data.substring(1));\n\t\t\t\t\tif (hydrate_index !== hydrate_index) {\n\t\t\t\t\t\t// if hydrate_index is NaN\n\t\t\t\t\t\t// we set an invalid index to force mismatch\n\t\t\t\t\t\thydrate_index = condition ? Infinity : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is_else = hydrate_index > root_index;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t\thydrate_index = -1; // ignore hydration in next else if\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, captured_signals, untrack } from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { LEGACY_DERIVED_PROP, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @param {Derived} current_value\n * @returns {boolean}\n */\nfunction has_destroyed_component_ctx(current_value) {\n\treturn current_value.ctx?.d ?? false;\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\n\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t// or `createClassComponent(Component, props)`\n\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\tvar setter =\n\t\t(bindable &&\n\t\t\t(get_descriptor(props, key)?.set ??\n\t\t\t\t(is_entry_props && key in props && ((v) => (props[key] = v))))) ||\n\t\tundefined;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\t// Ensure we eagerly capture the initial value if it's bindable\n\tif (bindable) {\n\t\tget(current_value);\n\t}\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (captured_signals !== null) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\treturn current_value.v;\n\t\t}\n\n\t\treturn get(current_value);\n\t};\n}\n"],"names":["if_block","node","fn","root_index","hydrate_index","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","UNINITIALIZED","flags","EFFECT_TRANSPARENT","has_branch","set_branch","flag","update_branch","new_condition","mismatch","data","HYDRATION_START","HYDRATION_START_ELSE","is_else","remove_nodes","set_hydrate_node","set_hydrating","resume_effect","branch","pause_effect","block","hydrate_node","is_store_binding","IS_UNMOUNTED","store_get","store","store_name","stores","entry","mutable_source","noop","is_synchronous_callback","subscribe_to_store","v","set","get_store","get","store_unsub","store_set","value","setup_stores","cleanup","teardown","define_property","capture_store_binding","previous_is_store_binding","rest_props_handler","target","key","rest_props","props","exclude","name","legacy_rest_props_handler","prop","PROPS_IS_UPDATED","update","legacy_rest_props","source","spread_props_handler","i","p","is_function","desc","get_descriptor","descriptor","STATE_SYMBOL","LEGACY_PROPS","keys","spread_props","has_destroyed_component_ctx","current_value","_a","fallback","immutable","PROPS_IS_IMMUTABLE","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","is_store_sub","prop_value","is_entry_props","setter","fallback_value","fallback_dirty","fallback_used","get_fallback","untrack","e.props_invalid_value","getter","derived_getter","derived","derived_safe_equal","LEGACY_DERIVED_PROP","legacy_parent","mutation","from_child","inner_current_value","parent_value","child_value","safe_equals","new_value","proxy"],"mappings":"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","x_google_ignoreList":[0,1,2]}