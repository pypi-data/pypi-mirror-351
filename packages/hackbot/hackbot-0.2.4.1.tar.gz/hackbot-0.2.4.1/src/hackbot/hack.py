from typing import Optional, List, Dict, Any, Literal, AsyncGenerator, Tuple
from dataclasses import dataclass
import aiohttp
import json
import tempfile
from pathlib import Path
from loguru import logger as log
from termcolor import colored
from hackbot.config import HACKBOT_URL_BASE
from hackbot.utils import (
    compress_source_code,
    get_repo_info,
    postprocess_scope_results,
    postprocess_learn_results,
    Endpoint,
    validate_checklist_file,
)
from hackbot.spinner import Spinner
from github import Github, GithubException, Auth

GREEN = "\033[1;32m"
RED = "\033[1;31m"
YELLOW = "\033[1;33m"
BLUE = "\033[1;34m"
MAGENTA = "\033[1;35m"
CYAN = "\033[1;36m"
END = "\033[0m"


@dataclass
class HackBotClientMessage:
    """A message sent to the hackbot client."""

    type: Literal["message", "progress", "error", "scope"]
    message: str

    def log(self) -> None:
        """Log the message to the console."""
        if self.type == "message":
            log.info(self.message)
        elif self.type == "progress":
            log.info(self.message, extra={"progress": True})
        elif self.type == "scope":
            log.info(self.message, extra={"scope": True})
        elif self.type == "error":
            log.error(self.message)


async def process_stream(response: aiohttp.ClientResponse) -> AsyncGenerator[str, None]:
    """Process the streaming response from the hackbot service."""
    async for line in response.content:
        line = line.decode("utf-8")
        if line.startswith("data: "):
            json_str = line[5:].strip()  # Remove 'data: ' prefix
            yield json_str


async def do_post(
    invocation_args: Dict[str, Any],
    api_key: str,
    endpoint: Endpoint,
    source_path: str = ".",
    output: Optional[str] = None,
    checklist: Optional[str] = None,
) -> AsyncGenerator[str, None]:
    """
    Analyze the target source code using the hackbot service.
    Available endpoints:
    - Endpoint.RUN: Run all checks (scope + hack)
    - Endpoint.SCOPE: Analyze the scope of the code
    - Endpoint.LEARN: Invalid in do_post as it uses a different POST request
    Args:
        address: The hackbot service address
        port: The service port number
        api_key: Authentication API key
        endpoint: The endpoint to use
        source_path: Path to the source code to analyze
        output: Optional path to save results
        checklist: Optional checklist file generated by hackbot learn

    Returns:
        List of analysis results
    """

    assert endpoint != Endpoint.LEARN, "Invalid endpoint for do_post"

    # Search for closest enclosing git repo and info from there, can be None
    repo_info = get_repo_info(source_path)
    # Compress the source code into a tempfile
    with tempfile.NamedTemporaryFile(delete=True, suffix=".zip") as temp_zip:
        compress_source_code(source_path, temp_zip.name, git_info=repo_info)

        url = f"{HACKBOT_URL_BASE}/api/{endpoint.value}"
        headers = {"X-API-KEY": api_key, "Connection": "keep-alive"}

        # Prepare the form data
        data = aiohttp.FormData()
        data.add_field(
            "file",
            open(temp_zip.name, "rb"),
            filename="compressed_source_code.zip",
            content_type="application/zip",
        )
        if repo_info:
            for key, value in repo_info.items():
                if key and value:
                    data.add_field(f"repo_info_{key}", value)

        # Invocation args into invocation_arg_* keys
        for key, value in invocation_args.items():
            data.add_field(f"invocation_arg_{key}", value)

        if checklist:
            checklist_data = validate_checklist_file(Path(checklist))
            data.add_field("checklist", json.dumps(checklist_data), content_type="application/json")

        results: list[dict[str, Any]] = []
        timeout = aiohttp.ClientTimeout(total=None)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.post(url, data=data, headers=headers) as response:
                if response.status != 200:
                    raise RuntimeError(
                        f"Hack request failed with status {response.status}, and error: {await response.text()}"
                    )

                async for result in process_stream(response):
                    results.append(json.loads(result))
                    # The type of result is indeed str, and json can only have string keys
                    assert isinstance(result, str)
                    yield result

                # Save results if output path specified
                if output:
                    output_path = Path(output)
                    output_path.parent.mkdir(parents=True, exist_ok=True)
                    with open(output_path, "w") as f:
                        json.dump(results, f, indent=2)


async def cli_scope(
    invocation_args: Dict[str, Any],
    api_key: str,
    source_path: str = ".",
    output: Optional[str] = None,
) -> Tuple[List[str], List[str]]:

    scope_files: list[str] = []
    ambiguous_files: list[str] = []
    with Spinner("Analyzing scope...", "Scope analysis done in {taken_time:.2f}s"):
        async for report in do_post(invocation_args, api_key, Endpoint.SCOPE, source_path, output):
            result_json = json.loads(report)
            if result_json.get("message") is not None:
                log.info(result_json.get("message"))
            elif result_json.get("scope") is not None:
                scope_files.extend(result_json.get("scope"))
                ambiguous_files.extend(result_json.get("ambiguity"))
            elif result_json.get("error") is not None:
                log.error(result_json.get("error"))
                return scope_files, ambiguous_files

    log.info("âœ… Scope analysis done!")
    postprocess_scope_results(source_path, scope_files, ambiguous_files)
    return scope_files, ambiguous_files


async def cli_run(
    invocation_args: Dict[str, Any],
    api_key: str,
    source_path: str = ".",
    output: Optional[str] = None,
    checklist: Optional[str] = None,
) -> Any:

    results: list[dict[str, Any]] = []
    with Spinner("Analyzing code...", "Code analysis done in {taken_time:.2f}s"):
        async for report in do_post(
            invocation_args, api_key, Endpoint.RUN, source_path, output, checklist
        ):
            result_json = json.loads(report)
            if result_json.get("message") is not None:
                log.info(result_json.get("message"))
            elif result_json.get("progress") is not None:
                log.info(result_json.get("progress").get("message"))
            elif result_json.get("title") is not None:
                log.info("\U0001f41b Finding: " + result_json.get("title"))
                results.append(result_json)
            elif result_json.get("error") is not None:
                log.error(result_json.get("error"))
                return results

    log.info("âœ… Code analysis done!")

    if len(results) == 0:
        log.info(
            colored(
                "âœ… No issues found",
                "green",
            )
        )

    return results


async def do_learn_post(
    api_key: str,
    user_url: str,
    merge: bool = False,
) -> AsyncGenerator[str, None]:
    url = f"{HACKBOT_URL_BASE}/api/{Endpoint.LEARN.value}"
    headers = {"Content-Type": "application/json", "X-API-KEY": api_key, "Connection": "keep-alive"}

    existing_checklist = ""
    json_args: Dict[str, Any] = {
        "url": user_url,
    }
    if merge is True:
        existing_checklist = validate_checklist_file(Path.cwd() / "checklist.json")
        json_args["existing_checklist"] = existing_checklist
    timeout = aiohttp.ClientTimeout(total=None)
    async with aiohttp.ClientSession(timeout=timeout) as session:
        async with session.post(url, headers=headers, json=json_args) as response:
            assert response.status == 200, f"Failed to run learn : HTTP code {response.status} "

            async for result in process_stream(response):
                yield result


async def cli_learn(
    api_key: str,
    user_url: str,
    merge: bool = False,
) -> None:
    checklist: Any | None = None
    with Spinner("ðŸ§  Learning from url...", "Learning from url done in {taken_time:.2f}s"):
        async for report in do_learn_post(api_key, user_url, merge):
            result_json = json.loads(report)
            if result_json.get("message") is not None:
                log.info(result_json.get("message"))
            elif result_json.get("checklist") is not None:
                # Because it comes from a json encoded string already
                checklist = json.loads(result_json.get("checklist", "{}"))
                log.info("Received checklist data")
            elif result_json.get("error") is not None:
                log.error(result_json.get("error"))
                return

    log.info(
        f"{GREEN}âœ… Learning from url done! Go check {CYAN}checklist.json{END} for the digested knowledge as a checklist, and then run {CYAN}hackbot run --checklist checklist.json{END} to run the hackbot campaign."
    )

    if checklist:
        postprocess_learn_results(checklist)
    return


class HackbotAuthError(Exception):
    """Exception raised for authentication errors with the hackbot service."""

    def __init__(self, message: str):
        self.message = message


async def authenticate(api_key: str) -> HackbotAuthError | None:
    """Verify API key authentication with the hackbot service.
    Responds either with None (auth success) or a HackbotAuthError (auth failure)"""
    url = f"{HACKBOT_URL_BASE}/api/authenticate"
    headers = {"X-API-KEY": api_key}

    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            if response.status == 200:
                return None
            else:
                return HackbotAuthError(
                    f"Authentication failed: HTTP code {response.status}, and error: {await response.text()}"
                )


async def get_selectable_models(api_key: str) -> List[str]:
    """Get the list of selectable models from the hackbot service."""
    url = f"{HACKBOT_URL_BASE}/get_selectable_models"
    headers = {"X-API-KEY": api_key}
    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            assert (
                response.status == 200
            ), f"Failed to get selectable models: HTTP code {response.status} from backend endpoint"
            return (await response.json())["models"]


async def generate_issues(
    issues_repo: str, github_api_key: str, results: List[Dict[str, Any]]
) -> None:
    """
    Generate GitHub issues for bugs discovered by the bot.

    This function creates a master issue in the specified GitHub repository
    containing all the bugs found. It uses the GitHub API to create issues
    and requires appropriate authentication and permissions.

    Args:
        issues_repo (str): The full name of the GitHub repository (e.g., "owner/repo").
        github_api_key (str): The GitHub token for authentication.
        results (List[Dict[str, Any]]): A list of dictionaries containing bug information.

    Returns:
        None

    Raises:
        Exception: If there are permission issues or other errors when interacting with the GitHub API.

    Note:
        - This function requires a GitHub token with 'issues: write' and 'contents: read' permissions.
        - It creates a master issue with a title format of "HB-{number}".
    """
    if not issues_repo:
        log.error("GitHub repository is not specified.")
        return

    # Authenticate with GitHub
    auth = Auth.Token(github_api_key)
    g = Github(auth=auth)

    # Get a list of the bugs discovered by the bot
    issues_found = [issue for issue in results if issue.get("bug_id") is not None]
    if len(issues_found) == 0:
        log.info("No bugs found, skipping issue generation")
        return

    # Get the output repository. This will fail if the github token does not have access to the repository
    repo = None
    try:
        repo = g.get_repo(issues_repo)
    except GithubException as e:
        log.error(f"Error accessing repository: {e}")
        return

    last_hb_issue = 0
    # Fetch all existing issues in the repository and find the last one created by the bot
    for issue in repo.get_issues(state="all"):
        if issue.title.startswith("HB-"):
            last_hb_issue = int(issue.title.split("-")[1])
            break

    # Create a master issue in the repository that will contain all the bugs.
    # This will fail if the github token does not have write access to the issues
    # permissions:
    # - issues: write
    master_issue = None
    try:
        master_issue = repo.create_issue(title=f"HB-{last_hb_issue + 1}")
    except GithubException as e:
        log.error(f"Error creating issue: {e}")
        if e.status == 422:
            raise Exception(
                "Validation failed, aborting. This functionality requires a GITHUB_TOKEN with 'issues: write' in the workflow permissions section."
            )
        elif e.status == 403:
            raise Exception(
                "Forbidden, aborting. This functionality requires a GITHUB_TOKEN with 'issues: write' in the workflow permissions section."
            )
        elif e.status == 410:
            raise Exception("Gone, aborting. The repository does not allow issues.")

    # Add each bug as a comment to the master issue
    for issue in issues_found:
        body = f"#{issue.get('bug_id')} - {issue.get('bug_title')}\n{issue.get('bug_description')}"
        if master_issue:
            master_issue.create_comment(body=body)

    if master_issue:
        log.info(f"Created issue: {master_issue.title}")
