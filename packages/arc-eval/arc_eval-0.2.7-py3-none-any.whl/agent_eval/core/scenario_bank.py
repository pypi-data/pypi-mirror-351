import os
import json
from datetime import datetime
import yaml

try:
    import fcntl
    has_fcntl = True
except ImportError:
    has_fcntl = False


class ScenarioBank:
    """Stores and manages learned failure patterns and generates test scenarios."""

    def __init__(self):
        # Patterns file (appended as JSONL); user-specific, git-ignored
        self.patterns_file = ".arc-eval/learned_patterns.jsonl"
        # Generated scenarios file under domains (auto-generated, git-ignored)
        self.scenarios_file = "agent_eval/domains/customer_generated.yaml"
        # Ensure patterns directory exists
        patterns_dir = os.path.dirname(self.patterns_file)
        if patterns_dir and not os.path.exists(patterns_dir):
            os.makedirs(patterns_dir, exist_ok=True)

    def add_pattern(self, pattern: dict):
        """Append a new failure pattern entry (thread-safe)."""
        with open(self.patterns_file, "a") as f:
            if has_fcntl:
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
            try:
                f.write(json.dumps(pattern) + "\n")
            finally:
                if has_fcntl:
                    fcntl.flock(f.fileno(), fcntl.LOCK_UN)

    def get_pattern_count(self, fingerprint: str) -> int:
        """Return how many times this fingerprint has been recorded."""
        if not os.path.exists(self.patterns_file):
            return 0
        count = 0
        with open(self.patterns_file) as f:
            for line in f:
                try:
                    data = json.loads(line)
                    if data.get("fingerprint") == fingerprint:
                        count += 1
                except json.JSONDecodeError:
                    continue
        return count

    def _write_scenarios_header(self) -> str:
        """Return the auto-generated scenarios file header."""
        total = self._get_total_pattern_count()
        header = """# AUTO-GENERATED - DO NOT EDIT MANUALLY
# Generated by Arc-Eval Pattern Learning System
# Last updated: {timestamp}
# Patterns learned: {count}
#
# These scenarios are automatically generated from real customer failures.
# To modify, use the pattern learning system, not direct edits.
"""
        return header.format(timestamp=datetime.now().isoformat(), count=total)

    def _get_total_pattern_count(self) -> int:
        """Count total recorded patterns across all fingerprints."""
        if not os.path.exists(self.patterns_file):
            return 0
        lines = 0
        with open(self.patterns_file) as f:
            for _ in f:
                lines += 1
        return lines

    def generate_scenario(self, pattern: dict) -> dict:
        """
        Convert a failure pattern into a new test scenario definition,
        appending it to the generated scenarios file.
        """
        scenario = {
            "id": pattern.get('scenario_id'),
            "name": f"LEARNED: {pattern.get('failure_reason', '')[:50]}",
            "description": pattern.get("failure_reason", "").strip(),
            "severity": "high",  # Default to high for learned patterns
            "test_type": "behavioral",
            "category": pattern.get("domain", "general"),
            "compliance": pattern.get("compliance_violation", []),
            "input_template": {"test": "learned_pattern"},
            "expected_behavior": "Agent should handle this pattern correctly",
            "failure_indicators": [pattern.get("failure_reason", "")],
            "remediation": pattern.get("remediation", "").strip(),
        }
        # Ensure scenarios_file directory exists
        scenarios_dir = os.path.dirname(self.scenarios_file)
        if scenarios_dir and not os.path.exists(scenarios_dir):
            os.makedirs(scenarios_dir, exist_ok=True)

        # Read existing content
        existing = {"scenarios": []}
        first_write = not os.path.exists(self.scenarios_file) or os.path.getsize(self.scenarios_file) == 0
        if not first_write:
            with open(self.scenarios_file, "r") as f:
                existing = yaml.safe_load(f) or existing
        
        # Append new scenario
        existing["scenarios"].append(scenario)
        
        # Write back complete file
        with open(self.scenarios_file, "w") as f:
            if first_write:
                f.write(self._write_scenarios_header())
            yaml.dump(existing, f, sort_keys=False)
        return scenario