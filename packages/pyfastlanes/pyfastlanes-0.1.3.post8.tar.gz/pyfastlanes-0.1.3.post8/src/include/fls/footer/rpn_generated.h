// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_RPN_FASTLANES_H_
#define FLATBUFFERS_GENERATED_RPN_FASTLANES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 2 && FLATBUFFERS_VERSION_REVISION == 10,
              "Non-compatible flatbuffers version included");

#include "operator_token_generated.h"

namespace fastlanes {

struct RPN;
struct RPNBuilder;
struct RPNT;

struct RPNT : public ::flatbuffers::NativeTable {
	typedef RPN                           TableType;
	std::vector<fastlanes::OperatorToken> operator_tokens {};
	std::vector<uint64_t>                 operand_tokens {};
};

struct RPN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef RPNT                 NativeTableType;
	typedef RPNBuilder           Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OPERATOR_TOKENS = 4, VT_OPERAND_TOKENS = 6 };
	const ::flatbuffers::Vector<fastlanes::OperatorToken>* operator_tokens() const {
		return GetPointer<const ::flatbuffers::Vector<fastlanes::OperatorToken>*>(VT_OPERATOR_TOKENS);
	}
	const ::flatbuffers::Vector<uint64_t>* operand_tokens() const {
		return GetPointer<const ::flatbuffers::Vector<uint64_t>*>(VT_OPERAND_TOKENS);
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_OPERATOR_TOKENS) &&
		       verifier.VerifyVector(operator_tokens()) && VerifyOffset(verifier, VT_OPERAND_TOKENS) &&
		       verifier.VerifyVector(operand_tokens()) && verifier.EndTable();
	}
	RPNT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void  UnPackTo(RPNT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<RPN> Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	                                       const RPNT*                               _o,
	                                       const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct RPNBuilder {
	typedef RPN                       Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void add_operator_tokens(::flatbuffers::Offset<::flatbuffers::Vector<fastlanes::OperatorToken>> operator_tokens) {
		fbb_.AddOffset(RPN::VT_OPERATOR_TOKENS, operator_tokens);
	}
	void add_operand_tokens(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> operand_tokens) {
		fbb_.AddOffset(RPN::VT_OPERAND_TOKENS, operand_tokens);
	}
	explicit RPNBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<RPN> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<RPN>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<RPN>
CreateRPN(::flatbuffers::FlatBufferBuilder&                                      _fbb,
          ::flatbuffers::Offset<::flatbuffers::Vector<fastlanes::OperatorToken>> operator_tokens = 0,
          ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>>                 operand_tokens  = 0) {
	RPNBuilder builder_(_fbb);
	builder_.add_operand_tokens(operand_tokens);
	builder_.add_operator_tokens(operator_tokens);
	return builder_.Finish();
}

inline ::flatbuffers::Offset<RPN>
CreateRPNDirect(::flatbuffers::FlatBufferBuilder&            _fbb,
                const std::vector<fastlanes::OperatorToken>* operator_tokens = nullptr,
                const std::vector<uint64_t>*                 operand_tokens  = nullptr) {
	auto operator_tokens__ = operator_tokens ? _fbb.CreateVector<fastlanes::OperatorToken>(*operator_tokens) : 0;
	auto operand_tokens__  = operand_tokens ? _fbb.CreateVector<uint64_t>(*operand_tokens) : 0;
	return fastlanes::CreateRPN(_fbb, operator_tokens__, operand_tokens__);
}

::flatbuffers::Offset<RPN> CreateRPN(::flatbuffers::FlatBufferBuilder&         _fbb,
                                     const RPNT*                               _o,
                                     const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline RPNT* RPN::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<RPNT>(new RPNT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void RPN::UnPackTo(RPNT* _o, const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = operator_tokens();
		if (_e) {
			_o->operator_tokens.resize(_e->size());
			for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->operator_tokens[_i] = static_cast<fastlanes::OperatorToken>(_e->Get(_i));
			}
		} else {
			_o->operator_tokens.resize(0);
		}
	}
	{
		auto _e = operand_tokens();
		if (_e) {
			_o->operand_tokens.resize(_e->size());
			for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_o->operand_tokens[_i] = _e->Get(_i);
			}
		} else {
			_o->operand_tokens.resize(0);
		}
	}
}

inline ::flatbuffers::Offset<RPN>
RPN::Pack(::flatbuffers::FlatBufferBuilder& _fbb, const RPNT* _o, const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateRPN(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RPN>
CreateRPN(::flatbuffers::FlatBufferBuilder& _fbb, const RPNT* _o, const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const RPNT*                               __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _operator_tokens = _o->operator_tokens.size() ? _fbb.CreateVector(_o->operator_tokens) : 0;
	auto _operand_tokens  = _o->operand_tokens.size() ? _fbb.CreateVector(_o->operand_tokens) : 0;
	return fastlanes::CreateRPN(_fbb, _operator_tokens, _operand_tokens);
}

inline const fastlanes::RPN* GetRPN(const void* buf) {
	return ::flatbuffers::GetRoot<fastlanes::RPN>(buf);
}

inline const fastlanes::RPN* GetSizePrefixedRPN(const void* buf) {
	return ::flatbuffers::GetSizePrefixedRoot<fastlanes::RPN>(buf);
}

inline bool VerifyRPNBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifyBuffer<fastlanes::RPN>(nullptr);
}

inline bool VerifySizePrefixedRPNBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifySizePrefixedBuffer<fastlanes::RPN>(nullptr);
}

inline void FinishRPNBuffer(::flatbuffers::FlatBufferBuilder& fbb, ::flatbuffers::Offset<fastlanes::RPN> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedRPNBuffer(::flatbuffers::FlatBufferBuilder&     fbb,
                                        ::flatbuffers::Offset<fastlanes::RPN> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fastlanes::RPNT> UnPackRPN(const void*                               buf,
                                                  const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::RPNT>(GetRPN(buf)->UnPack(res));
}

inline std::unique_ptr<fastlanes::RPNT> UnPackSizePrefixedRPN(const void*                               buf,
                                                              const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::RPNT>(GetSizePrefixedRPN(buf)->UnPack(res));
}

} // namespace fastlanes

#endif // FLATBUFFERS_GENERATED_RPN_FASTLANES_H_
