// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_FOOTER_FASTLANES_H_
#define FLATBUFFERS_GENERATED_FOOTER_FASTLANES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 2 && FLATBUFFERS_VERSION_REVISION == 10,
              "Non-compatible flatbuffers version included");

namespace fastlanes {

struct SegmentDescriptor;
struct SegmentDescriptorBuilder;
struct SegmentDescriptorT;

struct BinaryValue;
struct BinaryValueBuilder;
struct BinaryValueT;

enum class EntryPointType : uint8_t { UINT8 = 0, UINT16 = 1, UINT32 = 2, UINT64 = 3 };

inline const EntryPointType (&EnumValuesEntryPointType())[4] {
	static const EntryPointType values[] = {
	    EntryPointType::UINT8, EntryPointType::UINT16, EntryPointType::UINT32, EntryPointType::UINT64};
	return values;
}

inline const char* const* EnumNamesEntryPointType() {
	static const char* const names[5] = {"UINT8", "UINT16", "UINT32", "UINT64", nullptr};
	return names;
}

inline const char* EnumNameEntryPointType(EntryPointType e) {
	if (::flatbuffers::IsOutRange(e, EntryPointType::UINT8, EntryPointType::UINT64))
		return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesEntryPointType()[index];
}

struct SegmentDescriptorT : public ::flatbuffers::NativeTable {
	typedef SegmentDescriptor TableType;
	uint64_t                  entrypoint_offset = 0;
	uint64_t                  entrypoint_size   = 0;
	uint64_t                  data_offset       = 0;
	uint64_t                  data_size         = 0;
	fastlanes::EntryPointType entry_point_t     = fastlanes::EntryPointType::UINT8;
};

struct SegmentDescriptor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef SegmentDescriptorT       NativeTableType;
	typedef SegmentDescriptorBuilder Builder;
	enum FlatBuffersVTableOffset     FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_ENTRYPOINT_OFFSET = 4,
        VT_ENTRYPOINT_SIZE   = 6,
        VT_DATA_OFFSET       = 8,
        VT_DATA_SIZE         = 10,
        VT_ENTRY_POINT_T     = 12
	};
	uint64_t entrypoint_offset() const {
		return GetField<uint64_t>(VT_ENTRYPOINT_OFFSET, 0);
	}
	uint64_t entrypoint_size() const {
		return GetField<uint64_t>(VT_ENTRYPOINT_SIZE, 0);
	}
	uint64_t data_offset() const {
		return GetField<uint64_t>(VT_DATA_OFFSET, 0);
	}
	uint64_t data_size() const {
		return GetField<uint64_t>(VT_DATA_SIZE, 0);
	}
	fastlanes::EntryPointType entry_point_t() const {
		return static_cast<fastlanes::EntryPointType>(GetField<uint8_t>(VT_ENTRY_POINT_T, 0));
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_ENTRYPOINT_OFFSET, 8) &&
		       VerifyField<uint64_t>(verifier, VT_ENTRYPOINT_SIZE, 8) &&
		       VerifyField<uint64_t>(verifier, VT_DATA_OFFSET, 8) && VerifyField<uint64_t>(verifier, VT_DATA_SIZE, 8) &&
		       VerifyField<uint8_t>(verifier, VT_ENTRY_POINT_T, 1) && verifier.EndTable();
	}
	SegmentDescriptorT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(SegmentDescriptorT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<SegmentDescriptor> Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	                                                     const SegmentDescriptorT*                 _o,
	                                                     const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct SegmentDescriptorBuilder {
	typedef SegmentDescriptor         Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void                              add_entrypoint_offset(uint64_t entrypoint_offset) {
		                             fbb_.AddElement<uint64_t>(SegmentDescriptor::VT_ENTRYPOINT_OFFSET, entrypoint_offset, 0);
	}
	void add_entrypoint_size(uint64_t entrypoint_size) {
		fbb_.AddElement<uint64_t>(SegmentDescriptor::VT_ENTRYPOINT_SIZE, entrypoint_size, 0);
	}
	void add_data_offset(uint64_t data_offset) {
		fbb_.AddElement<uint64_t>(SegmentDescriptor::VT_DATA_OFFSET, data_offset, 0);
	}
	void add_data_size(uint64_t data_size) {
		fbb_.AddElement<uint64_t>(SegmentDescriptor::VT_DATA_SIZE, data_size, 0);
	}
	void add_entry_point_t(fastlanes::EntryPointType entry_point_t) {
		fbb_.AddElement<uint8_t>(SegmentDescriptor::VT_ENTRY_POINT_T, static_cast<uint8_t>(entry_point_t), 0);
	}
	explicit SegmentDescriptorBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<SegmentDescriptor> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<SegmentDescriptor>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<SegmentDescriptor>
CreateSegmentDescriptor(::flatbuffers::FlatBufferBuilder& _fbb,
                        uint64_t                          entrypoint_offset = 0,
                        uint64_t                          entrypoint_size   = 0,
                        uint64_t                          data_offset       = 0,
                        uint64_t                          data_size         = 0,
                        fastlanes::EntryPointType         entry_point_t     = fastlanes::EntryPointType::UINT8) {
	SegmentDescriptorBuilder builder_(_fbb);
	builder_.add_data_size(data_size);
	builder_.add_data_offset(data_offset);
	builder_.add_entrypoint_size(entrypoint_size);
	builder_.add_entrypoint_offset(entrypoint_offset);
	builder_.add_entry_point_t(entry_point_t);
	return builder_.Finish();
}

::flatbuffers::Offset<SegmentDescriptor>
CreateSegmentDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                        const SegmentDescriptorT*                 _o,
                        const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct BinaryValueT : public ::flatbuffers::NativeTable {
	typedef BinaryValue  TableType;
	std::vector<uint8_t> binary_data {};
};

struct BinaryValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef BinaryValueT                  NativeTableType;
	typedef BinaryValueBuilder            Builder;
	enum FlatBuffersVTableOffset          FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_BINARY_DATA = 4 };
	const ::flatbuffers::Vector<uint8_t>* binary_data() const {
		return GetPointer<const ::flatbuffers::Vector<uint8_t>*>(VT_BINARY_DATA);
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_BINARY_DATA) &&
		       verifier.VerifyVector(binary_data()) && verifier.EndTable();
	}
	BinaryValueT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void          UnPackTo(BinaryValueT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<BinaryValue> Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	                                               const BinaryValueT*                       _o,
	                                               const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct BinaryValueBuilder {
	typedef BinaryValue               Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void add_binary_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> binary_data) {
		fbb_.AddOffset(BinaryValue::VT_BINARY_DATA, binary_data);
	}
	explicit BinaryValueBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<BinaryValue> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<BinaryValue>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<BinaryValue>
CreateBinaryValue(::flatbuffers::FlatBufferBuilder&                     _fbb,
                  ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> binary_data = 0) {
	BinaryValueBuilder builder_(_fbb);
	builder_.add_binary_data(binary_data);
	return builder_.Finish();
}

inline ::flatbuffers::Offset<BinaryValue> CreateBinaryValueDirect(::flatbuffers::FlatBufferBuilder& _fbb,
                                                                  const std::vector<uint8_t>* binary_data = nullptr) {
	auto binary_data__ = binary_data ? _fbb.CreateVector<uint8_t>(*binary_data) : 0;
	return fastlanes::CreateBinaryValue(_fbb, binary_data__);
}

::flatbuffers::Offset<BinaryValue> CreateBinaryValue(::flatbuffers::FlatBufferBuilder&         _fbb,
                                                     const BinaryValueT*                       _o,
                                                     const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline SegmentDescriptorT* SegmentDescriptor::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<SegmentDescriptorT>(new SegmentDescriptorT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void SegmentDescriptor::UnPackTo(SegmentDescriptorT*                       _o,
                                        const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e               = entrypoint_offset();
		_o->entrypoint_offset = _e;
	}
	{
		auto _e             = entrypoint_size();
		_o->entrypoint_size = _e;
	}
	{
		auto _e         = data_offset();
		_o->data_offset = _e;
	}
	{
		auto _e       = data_size();
		_o->data_size = _e;
	}
	{
		auto _e           = entry_point_t();
		_o->entry_point_t = _e;
	}
}

inline ::flatbuffers::Offset<SegmentDescriptor>
SegmentDescriptor::Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
                        const SegmentDescriptorT*                 _o,
                        const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateSegmentDescriptor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SegmentDescriptor>
CreateSegmentDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                        const SegmentDescriptorT*                 _o,
                        const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const SegmentDescriptorT*                 __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _entrypoint_offset = _o->entrypoint_offset;
	auto _entrypoint_size   = _o->entrypoint_size;
	auto _data_offset       = _o->data_offset;
	auto _data_size         = _o->data_size;
	auto _entry_point_t     = _o->entry_point_t;
	return fastlanes::CreateSegmentDescriptor(
	    _fbb, _entrypoint_offset, _entrypoint_size, _data_offset, _data_size, _entry_point_t);
}

inline BinaryValueT* BinaryValue::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<BinaryValueT>(new BinaryValueT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void BinaryValue::UnPackTo(BinaryValueT* _o, const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = binary_data();
		if (_e) {
			_o->binary_data.resize(_e->size());
			std::copy(_e->begin(), _e->end(), _o->binary_data.begin());
		}
	}
}

inline ::flatbuffers::Offset<BinaryValue> BinaryValue::Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
                                                            const BinaryValueT*                       _o,
                                                            const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateBinaryValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BinaryValue> CreateBinaryValue(::flatbuffers::FlatBufferBuilder&         _fbb,
                                                            const BinaryValueT*                       _o,
                                                            const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const BinaryValueT*                       __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _binary_data = _o->binary_data.size() ? _fbb.CreateVector(_o->binary_data) : 0;
	return fastlanes::CreateBinaryValue(_fbb, _binary_data);
}

inline const fastlanes::SegmentDescriptor* GetSegmentDescriptor(const void* buf) {
	return ::flatbuffers::GetRoot<fastlanes::SegmentDescriptor>(buf);
}

inline const fastlanes::SegmentDescriptor* GetSizePrefixedSegmentDescriptor(const void* buf) {
	return ::flatbuffers::GetSizePrefixedRoot<fastlanes::SegmentDescriptor>(buf);
}

inline bool VerifySegmentDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifyBuffer<fastlanes::SegmentDescriptor>(nullptr);
}

inline bool VerifySizePrefixedSegmentDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifySizePrefixedBuffer<fastlanes::SegmentDescriptor>(nullptr);
}

inline void FinishSegmentDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                   fbb,
                                          ::flatbuffers::Offset<fastlanes::SegmentDescriptor> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedSegmentDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                   fbb,
                                                      ::flatbuffers::Offset<fastlanes::SegmentDescriptor> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fastlanes::SegmentDescriptorT>
UnPackSegmentDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::SegmentDescriptorT>(GetSegmentDescriptor(buf)->UnPack(res));
}

inline std::unique_ptr<fastlanes::SegmentDescriptorT>
UnPackSizePrefixedSegmentDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::SegmentDescriptorT>(GetSizePrefixedSegmentDescriptor(buf)->UnPack(res));
}

} // namespace fastlanes

#endif // FLATBUFFERS_GENERATED_FOOTER_FASTLANES_H_
