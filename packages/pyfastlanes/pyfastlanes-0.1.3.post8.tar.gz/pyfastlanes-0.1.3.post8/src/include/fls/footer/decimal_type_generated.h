// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DECIMALTYPE_FASTLANES_H_
#define FLATBUFFERS_GENERATED_DECIMALTYPE_FASTLANES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 2 && FLATBUFFERS_VERSION_REVISION == 10,
              "Non-compatible flatbuffers version included");

namespace fastlanes {

struct DecimalType;
struct DecimalTypeBuilder;
struct DecimalTypeT;

struct DecimalTypeT : public ::flatbuffers::NativeTable {
	typedef DecimalType TableType;
	uint64_t            precision = 0;
	uint64_t            scale     = 0;
};

struct DecimalType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef DecimalTypeT         NativeTableType;
	typedef DecimalTypeBuilder   Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_PRECISION = 4, VT_SCALE = 6 };
	uint64_t                     precision() const {
		                    return GetField<uint64_t>(VT_PRECISION, 0);
	}
	uint64_t scale() const {
		return GetField<uint64_t>(VT_SCALE, 0);
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_PRECISION, 8) &&
		       VerifyField<uint64_t>(verifier, VT_SCALE, 8) && verifier.EndTable();
	}
	DecimalTypeT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void          UnPackTo(DecimalTypeT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<DecimalType> Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	                                               const DecimalTypeT*                       _o,
	                                               const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct DecimalTypeBuilder {
	typedef DecimalType               Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void                              add_precision(uint64_t precision) {
		                             fbb_.AddElement<uint64_t>(DecimalType::VT_PRECISION, precision, 0);
	}
	void add_scale(uint64_t scale) {
		fbb_.AddElement<uint64_t>(DecimalType::VT_SCALE, scale, 0);
	}
	explicit DecimalTypeBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<DecimalType> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<DecimalType>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<DecimalType>
CreateDecimalType(::flatbuffers::FlatBufferBuilder& _fbb, uint64_t precision = 0, uint64_t scale = 0) {
	DecimalTypeBuilder builder_(_fbb);
	builder_.add_scale(scale);
	builder_.add_precision(precision);
	return builder_.Finish();
}

::flatbuffers::Offset<DecimalType> CreateDecimalType(::flatbuffers::FlatBufferBuilder&         _fbb,
                                                     const DecimalTypeT*                       _o,
                                                     const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline DecimalTypeT* DecimalType::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<DecimalTypeT>(new DecimalTypeT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void DecimalType::UnPackTo(DecimalTypeT* _o, const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e       = precision();
		_o->precision = _e;
	}
	{
		auto _e   = scale();
		_o->scale = _e;
	}
}

inline ::flatbuffers::Offset<DecimalType> DecimalType::Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
                                                            const DecimalTypeT*                       _o,
                                                            const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateDecimalType(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DecimalType> CreateDecimalType(::flatbuffers::FlatBufferBuilder&         _fbb,
                                                            const DecimalTypeT*                       _o,
                                                            const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const DecimalTypeT*                       __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _precision = _o->precision;
	auto _scale     = _o->scale;
	return fastlanes::CreateDecimalType(_fbb, _precision, _scale);
}

} // namespace fastlanes

#endif // FLATBUFFERS_GENERATED_DECIMALTYPE_FASTLANES_H_
