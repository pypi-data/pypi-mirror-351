// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COLUMNDESCRIPTOR_FASTLANES_H_
#define FLATBUFFERS_GENERATED_COLUMNDESCRIPTOR_FASTLANES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 2 && FLATBUFFERS_VERSION_REVISION == 10,
              "Non-compatible flatbuffers version included");

#include "datatype_generated.h"
#include "decimal_type_generated.h"
#include "footer_generated.h"
#include "operator_token_generated.h"
#include "rpn_generated.h"

namespace fastlanes {

struct ExpressionResult;
struct ExpressionResultBuilder;
struct ExpressionResultT;

struct ColumnDescriptor;
struct ColumnDescriptorBuilder;
struct ColumnDescriptorT;

struct ExpressionResultT : public ::flatbuffers::NativeTable {
	typedef ExpressionResult TableType;
	fastlanes::OperatorToken operator_token = fastlanes::OperatorToken::INVALID;
	uint64_t                 size           = 0;
};

struct ExpressionResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef ExpressionResultT       NativeTableType;
	typedef ExpressionResultBuilder Builder;
	enum FlatBuffersVTableOffset    FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_OPERATOR_TOKEN = 4, VT_SIZE = 6 };
	fastlanes::OperatorToken        operator_token() const {
		       return static_cast<fastlanes::OperatorToken>(GetField<uint16_t>(VT_OPERATOR_TOKEN, 0));
	}
	uint64_t size() const {
		return GetField<uint64_t>(VT_SIZE, 0);
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint16_t>(verifier, VT_OPERATOR_TOKEN, 2) &&
		       VerifyField<uint64_t>(verifier, VT_SIZE, 8) && verifier.EndTable();
	}
	ExpressionResultT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(ExpressionResultT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<ExpressionResult> Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	                                                    const ExpressionResultT*                  _o,
	                                                    const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct ExpressionResultBuilder {
	typedef ExpressionResult          Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void                              add_operator_token(fastlanes::OperatorToken operator_token) {
		                             fbb_.AddElement<uint16_t>(ExpressionResult::VT_OPERATOR_TOKEN, static_cast<uint16_t>(operator_token), 0);
	}
	void add_size(uint64_t size) {
		fbb_.AddElement<uint64_t>(ExpressionResult::VT_SIZE, size, 0);
	}
	explicit ExpressionResultBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<ExpressionResult> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<ExpressionResult>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<ExpressionResult>
CreateExpressionResult(::flatbuffers::FlatBufferBuilder& _fbb,
                       fastlanes::OperatorToken          operator_token = fastlanes::OperatorToken::INVALID,
                       uint64_t                          size           = 0) {
	ExpressionResultBuilder builder_(_fbb);
	builder_.add_size(size);
	builder_.add_operator_token(operator_token);
	return builder_.Finish();
}

::flatbuffers::Offset<ExpressionResult>
CreateExpressionResult(::flatbuffers::FlatBufferBuilder&         _fbb,
                       const ExpressionResultT*                  _o,
                       const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

struct ColumnDescriptorT : public ::flatbuffers::NativeTable {
	typedef ColumnDescriptor                                    TableType;
	fastlanes::DataType                                         data_type = fastlanes::DataType::INVALID;
	std::unique_ptr<fastlanes::RPNT>                            encoding_rpn {};
	uint64_t                                                    idx = 0;
	std::string                                                 name {};
	std::vector<std::unique_ptr<fastlanes::ColumnDescriptorT>>  children {};
	std::unique_ptr<fastlanes::BinaryValueT>                    max {};
	uint64_t                                                    column_offset = 0;
	uint64_t                                                    total_size    = 0;
	std::vector<std::unique_ptr<fastlanes::ExpressionResultT>>  expr_space {};
	std::vector<std::unique_ptr<fastlanes::SegmentDescriptorT>> segment_descriptors {};
	uint64_t                                                    n_null = 0;
	std::unique_ptr<fastlanes::DecimalTypeT>                    fix_me_decimal_type {};
	ColumnDescriptorT() = default;
	ColumnDescriptorT(const ColumnDescriptorT& o);
	ColumnDescriptorT(ColumnDescriptorT&&) FLATBUFFERS_NOEXCEPT = default;
	ColumnDescriptorT& operator=(ColumnDescriptorT o) FLATBUFFERS_NOEXCEPT;
};

struct ColumnDescriptor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef ColumnDescriptorT       NativeTableType;
	typedef ColumnDescriptorBuilder Builder;
	enum FlatBuffersVTableOffset    FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_DATA_TYPE           = 4,
        VT_ENCODING_RPN        = 6,
        VT_IDX                 = 8,
        VT_NAME                = 10,
        VT_CHILDREN            = 12,
        VT_MAX                 = 14,
        VT_COLUMN_OFFSET       = 16,
        VT_TOTAL_SIZE          = 18,
        VT_EXPR_SPACE          = 20,
        VT_SEGMENT_DESCRIPTORS = 22,
        VT_N_NULL              = 24,
        VT_FIX_ME_DECIMAL_TYPE = 26
	};
	fastlanes::DataType data_type() const {
		return static_cast<fastlanes::DataType>(GetField<uint8_t>(VT_DATA_TYPE, 0));
	}
	const fastlanes::RPN* encoding_rpn() const {
		return GetPointer<const fastlanes::RPN*>(VT_ENCODING_RPN);
	}
	uint64_t idx() const {
		return GetField<uint64_t>(VT_IDX, 0);
	}
	const ::flatbuffers::String* name() const {
		return GetPointer<const ::flatbuffers::String*>(VT_NAME);
	}
	const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>* children() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>*>(
		    VT_CHILDREN);
	}
	const fastlanes::BinaryValue* max() const {
		return GetPointer<const fastlanes::BinaryValue*>(VT_MAX);
	}
	uint64_t column_offset() const {
		return GetField<uint64_t>(VT_COLUMN_OFFSET, 0);
	}
	uint64_t total_size() const {
		return GetField<uint64_t>(VT_TOTAL_SIZE, 0);
	}
	const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ExpressionResult>>* expr_space() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ExpressionResult>>*>(
		    VT_EXPR_SPACE);
	}
	const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::SegmentDescriptor>>* segment_descriptors() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::SegmentDescriptor>>*>(
		    VT_SEGMENT_DESCRIPTORS);
	}
	uint64_t n_null() const {
		return GetField<uint64_t>(VT_N_NULL, 0);
	}
	const fastlanes::DecimalType* fix_me_decimal_type() const {
		return GetPointer<const fastlanes::DecimalType*>(VT_FIX_ME_DECIMAL_TYPE);
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
		       VerifyOffset(verifier, VT_ENCODING_RPN) && verifier.VerifyTable(encoding_rpn()) &&
		       VerifyField<uint64_t>(verifier, VT_IDX, 8) && VerifyOffset(verifier, VT_NAME) &&
		       verifier.VerifyString(name()) && VerifyOffset(verifier, VT_CHILDREN) &&
		       verifier.VerifyVector(children()) && verifier.VerifyVectorOfTables(children()) &&
		       VerifyOffset(verifier, VT_MAX) && verifier.VerifyTable(max()) &&
		       VerifyField<uint64_t>(verifier, VT_COLUMN_OFFSET, 8) &&
		       VerifyField<uint64_t>(verifier, VT_TOTAL_SIZE, 8) && VerifyOffset(verifier, VT_EXPR_SPACE) &&
		       verifier.VerifyVector(expr_space()) && verifier.VerifyVectorOfTables(expr_space()) &&
		       VerifyOffset(verifier, VT_SEGMENT_DESCRIPTORS) && verifier.VerifyVector(segment_descriptors()) &&
		       verifier.VerifyVectorOfTables(segment_descriptors()) && VerifyField<uint64_t>(verifier, VT_N_NULL, 8) &&
		       VerifyOffset(verifier, VT_FIX_ME_DECIMAL_TYPE) && verifier.VerifyTable(fix_me_decimal_type()) &&
		       verifier.EndTable();
	}
	ColumnDescriptorT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(ColumnDescriptorT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<ColumnDescriptor> Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	                                                    const ColumnDescriptorT*                  _o,
	                                                    const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct ColumnDescriptorBuilder {
	typedef ColumnDescriptor          Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void                              add_data_type(fastlanes::DataType data_type) {
		                             fbb_.AddElement<uint8_t>(ColumnDescriptor::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
	}
	void add_encoding_rpn(::flatbuffers::Offset<fastlanes::RPN> encoding_rpn) {
		fbb_.AddOffset(ColumnDescriptor::VT_ENCODING_RPN, encoding_rpn);
	}
	void add_idx(uint64_t idx) {
		fbb_.AddElement<uint64_t>(ColumnDescriptor::VT_IDX, idx, 0);
	}
	void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
		fbb_.AddOffset(ColumnDescriptor::VT_NAME, name);
	}
	void add_children(
	    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>> children) {
		fbb_.AddOffset(ColumnDescriptor::VT_CHILDREN, children);
	}
	void add_max(::flatbuffers::Offset<fastlanes::BinaryValue> max) {
		fbb_.AddOffset(ColumnDescriptor::VT_MAX, max);
	}
	void add_column_offset(uint64_t column_offset) {
		fbb_.AddElement<uint64_t>(ColumnDescriptor::VT_COLUMN_OFFSET, column_offset, 0);
	}
	void add_total_size(uint64_t total_size) {
		fbb_.AddElement<uint64_t>(ColumnDescriptor::VT_TOTAL_SIZE, total_size, 0);
	}
	void add_expr_space(
	    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ExpressionResult>>> expr_space) {
		fbb_.AddOffset(ColumnDescriptor::VT_EXPR_SPACE, expr_space);
	}
	void add_segment_descriptors(
	    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::SegmentDescriptor>>>
	        segment_descriptors) {
		fbb_.AddOffset(ColumnDescriptor::VT_SEGMENT_DESCRIPTORS, segment_descriptors);
	}
	void add_n_null(uint64_t n_null) {
		fbb_.AddElement<uint64_t>(ColumnDescriptor::VT_N_NULL, n_null, 0);
	}
	void add_fix_me_decimal_type(::flatbuffers::Offset<fastlanes::DecimalType> fix_me_decimal_type) {
		fbb_.AddOffset(ColumnDescriptor::VT_FIX_ME_DECIMAL_TYPE, fix_me_decimal_type);
	}
	explicit ColumnDescriptorBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<ColumnDescriptor> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<ColumnDescriptor>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<ColumnDescriptor> CreateColumnDescriptor(
    ::flatbuffers::FlatBufferBuilder&            _fbb,
    fastlanes::DataType                          data_type    = fastlanes::DataType::INVALID,
    ::flatbuffers::Offset<fastlanes::RPN>        encoding_rpn = 0,
    uint64_t                                     idx          = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name         = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>> children      = 0,
    ::flatbuffers::Offset<fastlanes::BinaryValue>                                                    max           = 0,
    uint64_t                                                                                         column_offset = 0,
    uint64_t                                                                                         total_size    = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ExpressionResult>>> expr_space    = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::SegmentDescriptor>>>
                                                  segment_descriptors = 0,
    uint64_t                                      n_null              = 0,
    ::flatbuffers::Offset<fastlanes::DecimalType> fix_me_decimal_type = 0) {
	ColumnDescriptorBuilder builder_(_fbb);
	builder_.add_n_null(n_null);
	builder_.add_total_size(total_size);
	builder_.add_column_offset(column_offset);
	builder_.add_idx(idx);
	builder_.add_fix_me_decimal_type(fix_me_decimal_type);
	builder_.add_segment_descriptors(segment_descriptors);
	builder_.add_expr_space(expr_space);
	builder_.add_max(max);
	builder_.add_children(children);
	builder_.add_name(name);
	builder_.add_encoding_rpn(encoding_rpn);
	builder_.add_data_type(data_type);
	return builder_.Finish();
}

inline ::flatbuffers::Offset<ColumnDescriptor> CreateColumnDescriptorDirect(
    ::flatbuffers::FlatBufferBuilder&                                       _fbb,
    fastlanes::DataType                                                     data_type    = fastlanes::DataType::INVALID,
    ::flatbuffers::Offset<fastlanes::RPN>                                   encoding_rpn = 0,
    uint64_t                                                                idx          = 0,
    const char*                                                             name         = nullptr,
    const std::vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>*  children     = nullptr,
    ::flatbuffers::Offset<fastlanes::BinaryValue>                           max          = 0,
    uint64_t                                                                column_offset       = 0,
    uint64_t                                                                total_size          = 0,
    const std::vector<::flatbuffers::Offset<fastlanes::ExpressionResult>>*  expr_space          = nullptr,
    const std::vector<::flatbuffers::Offset<fastlanes::SegmentDescriptor>>* segment_descriptors = nullptr,
    uint64_t                                                                n_null              = 0,
    ::flatbuffers::Offset<fastlanes::DecimalType>                           fix_me_decimal_type = 0) {
	auto name__     = name ? _fbb.CreateString(name) : 0;
	auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>(*children) : 0;
	auto expr_space__ =
	    expr_space ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::ExpressionResult>>(*expr_space) : 0;
	auto segment_descriptors__ =
	    segment_descriptors
	        ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::SegmentDescriptor>>(*segment_descriptors)
	        : 0;
	return fastlanes::CreateColumnDescriptor(_fbb,
	                                         data_type,
	                                         encoding_rpn,
	                                         idx,
	                                         name__,
	                                         children__,
	                                         max,
	                                         column_offset,
	                                         total_size,
	                                         expr_space__,
	                                         segment_descriptors__,
	                                         n_null,
	                                         fix_me_decimal_type);
}

::flatbuffers::Offset<ColumnDescriptor>
CreateColumnDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                       const ColumnDescriptorT*                  _o,
                       const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline ExpressionResultT* ExpressionResult::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<ExpressionResultT>(new ExpressionResultT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void ExpressionResult::UnPackTo(ExpressionResultT*                        _o,
                                       const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e            = operator_token();
		_o->operator_token = _e;
	}
	{
		auto _e  = size();
		_o->size = _e;
	}
}

inline ::flatbuffers::Offset<ExpressionResult>
ExpressionResult::Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
                       const ExpressionResultT*                  _o,
                       const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateExpressionResult(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ExpressionResult>
CreateExpressionResult(::flatbuffers::FlatBufferBuilder&         _fbb,
                       const ExpressionResultT*                  _o,
                       const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const ExpressionResultT*                  __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _operator_token = _o->operator_token;
	auto _size           = _o->size;
	return fastlanes::CreateExpressionResult(_fbb, _operator_token, _size);
}

inline ColumnDescriptorT::ColumnDescriptorT(const ColumnDescriptorT& o)
    : data_type(o.data_type)
    , encoding_rpn((o.encoding_rpn) ? new fastlanes::RPNT(*o.encoding_rpn) : nullptr)
    , idx(o.idx)
    , name(o.name)
    , max((o.max) ? new fastlanes::BinaryValueT(*o.max) : nullptr)
    , column_offset(o.column_offset)
    , total_size(o.total_size)
    , n_null(o.n_null)
    , fix_me_decimal_type((o.fix_me_decimal_type) ? new fastlanes::DecimalTypeT(*o.fix_me_decimal_type) : nullptr) {
	children.reserve(o.children.size());
	for (const auto& children_ : o.children) {
		children.emplace_back((children_) ? new fastlanes::ColumnDescriptorT(*children_) : nullptr);
	}
	expr_space.reserve(o.expr_space.size());
	for (const auto& expr_space_ : o.expr_space) {
		expr_space.emplace_back((expr_space_) ? new fastlanes::ExpressionResultT(*expr_space_) : nullptr);
	}
	segment_descriptors.reserve(o.segment_descriptors.size());
	for (const auto& segment_descriptors_ : o.segment_descriptors) {
		segment_descriptors.emplace_back(
		    (segment_descriptors_) ? new fastlanes::SegmentDescriptorT(*segment_descriptors_) : nullptr);
	}
}

inline ColumnDescriptorT& ColumnDescriptorT::operator=(ColumnDescriptorT o) FLATBUFFERS_NOEXCEPT {
	std::swap(data_type, o.data_type);
	std::swap(encoding_rpn, o.encoding_rpn);
	std::swap(idx, o.idx);
	std::swap(name, o.name);
	std::swap(children, o.children);
	std::swap(max, o.max);
	std::swap(column_offset, o.column_offset);
	std::swap(total_size, o.total_size);
	std::swap(expr_space, o.expr_space);
	std::swap(segment_descriptors, o.segment_descriptors);
	std::swap(n_null, o.n_null);
	std::swap(fix_me_decimal_type, o.fix_me_decimal_type);
	return *this;
}

inline ColumnDescriptorT* ColumnDescriptor::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<ColumnDescriptorT>(new ColumnDescriptorT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void ColumnDescriptor::UnPackTo(ColumnDescriptorT*                        _o,
                                       const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e       = data_type();
		_o->data_type = _e;
	}
	{
		auto _e = encoding_rpn();
		if (_e) {
			if (_o->encoding_rpn) {
				_e->UnPackTo(_o->encoding_rpn.get(), _resolver);
			} else {
				_o->encoding_rpn = std::unique_ptr<fastlanes::RPNT>(_e->UnPack(_resolver));
			}
		} else if (_o->encoding_rpn) {
			_o->encoding_rpn.reset();
		}
	}
	{
		auto _e = idx();
		_o->idx = _e;
	}
	{
		auto _e = name();
		if (_e)
			_o->name = _e->str();
	}
	{
		auto _e = children();
		if (_e) {
			_o->children.resize(_e->size());
			for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				if (_o->children[_i]) {
					_e->Get(_i)->UnPackTo(_o->children[_i].get(), _resolver);
				} else {
					_o->children[_i] = std::unique_ptr<fastlanes::ColumnDescriptorT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		} else {
			_o->children.resize(0);
		}
	}
	{
		auto _e = max();
		if (_e) {
			if (_o->max) {
				_e->UnPackTo(_o->max.get(), _resolver);
			} else {
				_o->max = std::unique_ptr<fastlanes::BinaryValueT>(_e->UnPack(_resolver));
			}
		} else if (_o->max) {
			_o->max.reset();
		}
	}
	{
		auto _e           = column_offset();
		_o->column_offset = _e;
	}
	{
		auto _e        = total_size();
		_o->total_size = _e;
	}
	{
		auto _e = expr_space();
		if (_e) {
			_o->expr_space.resize(_e->size());
			for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				if (_o->expr_space[_i]) {
					_e->Get(_i)->UnPackTo(_o->expr_space[_i].get(), _resolver);
				} else {
					_o->expr_space[_i] = std::unique_ptr<fastlanes::ExpressionResultT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		} else {
			_o->expr_space.resize(0);
		}
	}
	{
		auto _e = segment_descriptors();
		if (_e) {
			_o->segment_descriptors.resize(_e->size());
			for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				if (_o->segment_descriptors[_i]) {
					_e->Get(_i)->UnPackTo(_o->segment_descriptors[_i].get(), _resolver);
				} else {
					_o->segment_descriptors[_i] =
					    std::unique_ptr<fastlanes::SegmentDescriptorT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		} else {
			_o->segment_descriptors.resize(0);
		}
	}
	{
		auto _e    = n_null();
		_o->n_null = _e;
	}
	{
		auto _e = fix_me_decimal_type();
		if (_e) {
			if (_o->fix_me_decimal_type) {
				_e->UnPackTo(_o->fix_me_decimal_type.get(), _resolver);
			} else {
				_o->fix_me_decimal_type = std::unique_ptr<fastlanes::DecimalTypeT>(_e->UnPack(_resolver));
			}
		} else if (_o->fix_me_decimal_type) {
			_o->fix_me_decimal_type.reset();
		}
	}
}

inline ::flatbuffers::Offset<ColumnDescriptor>
ColumnDescriptor::Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
                       const ColumnDescriptorT*                  _o,
                       const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateColumnDescriptor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ColumnDescriptor>
CreateColumnDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                       const ColumnDescriptorT*                  _o,
                       const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const ColumnDescriptorT*                  __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _data_type    = _o->data_type;
	auto _encoding_rpn = _o->encoding_rpn ? CreateRPN(_fbb, _o->encoding_rpn.get(), _rehasher) : 0;
	auto _idx          = _o->idx;
	auto _name         = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
	auto _children =
	    _o->children.size()
	        ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>(
	              _o->children.size(),
	              [](size_t i, _VectorArgs* __va) {
		              return CreateColumnDescriptor(*__va->__fbb, __va->__o->children[i].get(), __va->__rehasher);
	              },
	              &_va)
	        : 0;
	auto _max           = _o->max ? CreateBinaryValue(_fbb, _o->max.get(), _rehasher) : 0;
	auto _column_offset = _o->column_offset;
	auto _total_size    = _o->total_size;
	auto _expr_space =
	    _o->expr_space.size()
	        ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::ExpressionResult>>(
	              _o->expr_space.size(),
	              [](size_t i, _VectorArgs* __va) {
		              return CreateExpressionResult(*__va->__fbb, __va->__o->expr_space[i].get(), __va->__rehasher);
	              },
	              &_va)
	        : 0;
	auto _segment_descriptors = _o->segment_descriptors.size()
	                                ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::SegmentDescriptor>>(
	                                      _o->segment_descriptors.size(),
	                                      [](size_t i, _VectorArgs* __va) {
		                                      return CreateSegmentDescriptor(*__va->__fbb,
		                                                                     __va->__o->segment_descriptors[i].get(),
		                                                                     __va->__rehasher);
	                                      },
	                                      &_va)
	                                : 0;
	auto _n_null              = _o->n_null;
	auto _fix_me_decimal_type =
	    _o->fix_me_decimal_type ? CreateDecimalType(_fbb, _o->fix_me_decimal_type.get(), _rehasher) : 0;
	return fastlanes::CreateColumnDescriptor(_fbb,
	                                         _data_type,
	                                         _encoding_rpn,
	                                         _idx,
	                                         _name,
	                                         _children,
	                                         _max,
	                                         _column_offset,
	                                         _total_size,
	                                         _expr_space,
	                                         _segment_descriptors,
	                                         _n_null,
	                                         _fix_me_decimal_type);
}

inline const fastlanes::ColumnDescriptor* GetColumnDescriptor(const void* buf) {
	return ::flatbuffers::GetRoot<fastlanes::ColumnDescriptor>(buf);
}

inline const fastlanes::ColumnDescriptor* GetSizePrefixedColumnDescriptor(const void* buf) {
	return ::flatbuffers::GetSizePrefixedRoot<fastlanes::ColumnDescriptor>(buf);
}

inline bool VerifyColumnDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifyBuffer<fastlanes::ColumnDescriptor>(nullptr);
}

inline bool VerifySizePrefixedColumnDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifySizePrefixedBuffer<fastlanes::ColumnDescriptor>(nullptr);
}

inline void FinishColumnDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                  fbb,
                                         ::flatbuffers::Offset<fastlanes::ColumnDescriptor> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedColumnDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                  fbb,
                                                     ::flatbuffers::Offset<fastlanes::ColumnDescriptor> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fastlanes::ColumnDescriptorT>
UnPackColumnDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::ColumnDescriptorT>(GetColumnDescriptor(buf)->UnPack(res));
}

inline std::unique_ptr<fastlanes::ColumnDescriptorT>
UnPackSizePrefixedColumnDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::ColumnDescriptorT>(GetSizePrefixedColumnDescriptor(buf)->UnPack(res));
}

} // namespace fastlanes

#endif // FLATBUFFERS_GENERATED_COLUMNDESCRIPTOR_FASTLANES_H_
