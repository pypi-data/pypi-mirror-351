// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_TABLEDESCRIPTOR_FASTLANES_H_
#define FLATBUFFERS_GENERATED_TABLEDESCRIPTOR_FASTLANES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 2 && FLATBUFFERS_VERSION_REVISION == 10,
              "Non-compatible flatbuffers version included");

#include "rowgroup_descriptor_generated.h"

namespace fastlanes {

struct TableDescriptor;
struct TableDescriptorBuilder;
struct TableDescriptorT;

struct TableDescriptorT : public ::flatbuffers::NativeTable {
	typedef TableDescriptor                                      TableType;
	std::vector<std::unique_ptr<fastlanes::RowgroupDescriptorT>> m_rowgroup_descriptors {};
	uint64_t                                                     m_table_binary_size = 0;
	TableDescriptorT()                                                               = default;
	TableDescriptorT(const TableDescriptorT& o);
	TableDescriptorT(TableDescriptorT&&) FLATBUFFERS_NOEXCEPT = default;
	TableDescriptorT& operator=(TableDescriptorT o) FLATBUFFERS_NOEXCEPT;
};

struct TableDescriptor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef TableDescriptorT       NativeTableType;
	typedef TableDescriptorBuilder Builder;
	enum FlatBuffersVTableOffset   FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_M_ROWGROUP_DESCRIPTORS = 4,
        VT_M_TABLE_BINARY_SIZE    = 6
	};
	/// A list of row‚Äêgroup descriptors
	const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::RowgroupDescriptor>>* m_rowgroup_descriptors() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::RowgroupDescriptor>>*>(
		    VT_M_ROWGROUP_DESCRIPTORS);
	}
	/// Total size in bytes of the table binary
	uint64_t m_table_binary_size() const {
		return GetField<uint64_t>(VT_M_TABLE_BINARY_SIZE, 0);
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_M_ROWGROUP_DESCRIPTORS) &&
		       verifier.VerifyVector(m_rowgroup_descriptors()) &&
		       verifier.VerifyVectorOfTables(m_rowgroup_descriptors()) &&
		       VerifyField<uint64_t>(verifier, VT_M_TABLE_BINARY_SIZE, 8) && verifier.EndTable();
	}
	TableDescriptorT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(TableDescriptorT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<TableDescriptor> Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	                                                   const TableDescriptorT*                   _o,
	                                                   const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct TableDescriptorBuilder {
	typedef TableDescriptor           Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void                              add_m_rowgroup_descriptors(
	                                 ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::RowgroupDescriptor>>>
	                                     m_rowgroup_descriptors) {
		fbb_.AddOffset(TableDescriptor::VT_M_ROWGROUP_DESCRIPTORS, m_rowgroup_descriptors);
	}
	void add_m_table_binary_size(uint64_t m_table_binary_size) {
		fbb_.AddElement<uint64_t>(TableDescriptor::VT_M_TABLE_BINARY_SIZE, m_table_binary_size, 0);
	}
	explicit TableDescriptorBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<TableDescriptor> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<TableDescriptor>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<TableDescriptor>
CreateTableDescriptor(::flatbuffers::FlatBufferBuilder& _fbb,
                      ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::RowgroupDescriptor>>>
                               m_rowgroup_descriptors = 0,
                      uint64_t m_table_binary_size    = 0) {
	TableDescriptorBuilder builder_(_fbb);
	builder_.add_m_table_binary_size(m_table_binary_size);
	builder_.add_m_rowgroup_descriptors(m_rowgroup_descriptors);
	return builder_.Finish();
}

inline ::flatbuffers::Offset<TableDescriptor> CreateTableDescriptorDirect(
    ::flatbuffers::FlatBufferBuilder&                                        _fbb,
    const std::vector<::flatbuffers::Offset<fastlanes::RowgroupDescriptor>>* m_rowgroup_descriptors = nullptr,
    uint64_t                                                                 m_table_binary_size    = 0) {
	auto m_rowgroup_descriptors__ =
	    m_rowgroup_descriptors
	        ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::RowgroupDescriptor>>(*m_rowgroup_descriptors)
	        : 0;
	return fastlanes::CreateTableDescriptor(_fbb, m_rowgroup_descriptors__, m_table_binary_size);
}

::flatbuffers::Offset<TableDescriptor>
CreateTableDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                      const TableDescriptorT*                   _o,
                      const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline TableDescriptorT::TableDescriptorT(const TableDescriptorT& o)
    : m_table_binary_size(o.m_table_binary_size) {
	m_rowgroup_descriptors.reserve(o.m_rowgroup_descriptors.size());
	for (const auto& m_rowgroup_descriptors_ : o.m_rowgroup_descriptors) {
		m_rowgroup_descriptors.emplace_back(
		    (m_rowgroup_descriptors_) ? new fastlanes::RowgroupDescriptorT(*m_rowgroup_descriptors_) : nullptr);
	}
}

inline TableDescriptorT& TableDescriptorT::operator=(TableDescriptorT o) FLATBUFFERS_NOEXCEPT {
	std::swap(m_rowgroup_descriptors, o.m_rowgroup_descriptors);
	std::swap(m_table_binary_size, o.m_table_binary_size);
	return *this;
}

inline TableDescriptorT* TableDescriptor::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<TableDescriptorT>(new TableDescriptorT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void TableDescriptor::UnPackTo(TableDescriptorT* _o, const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e = m_rowgroup_descriptors();
		if (_e) {
			_o->m_rowgroup_descriptors.resize(_e->size());
			for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				if (_o->m_rowgroup_descriptors[_i]) {
					_e->Get(_i)->UnPackTo(_o->m_rowgroup_descriptors[_i].get(), _resolver);
				} else {
					_o->m_rowgroup_descriptors[_i] =
					    std::unique_ptr<fastlanes::RowgroupDescriptorT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		} else {
			_o->m_rowgroup_descriptors.resize(0);
		}
	}
	{
		auto _e                 = m_table_binary_size();
		_o->m_table_binary_size = _e;
	}
}

inline ::flatbuffers::Offset<TableDescriptor>
TableDescriptor::Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
                      const TableDescriptorT*                   _o,
                      const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateTableDescriptor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TableDescriptor>
CreateTableDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                      const TableDescriptorT*                   _o,
                      const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const TableDescriptorT*                   __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _m_rowgroup_descriptors =
	    _o->m_rowgroup_descriptors.size()
	        ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::RowgroupDescriptor>>(
	              _o->m_rowgroup_descriptors.size(),
	              [](size_t i, _VectorArgs* __va) {
		              return CreateRowgroupDescriptor(
		                  *__va->__fbb, __va->__o->m_rowgroup_descriptors[i].get(), __va->__rehasher);
	              },
	              &_va)
	        : 0;
	auto _m_table_binary_size = _o->m_table_binary_size;
	return fastlanes::CreateTableDescriptor(_fbb, _m_rowgroup_descriptors, _m_table_binary_size);
}

inline const fastlanes::TableDescriptor* GetTableDescriptor(const void* buf) {
	return ::flatbuffers::GetRoot<fastlanes::TableDescriptor>(buf);
}

inline const fastlanes::TableDescriptor* GetSizePrefixedTableDescriptor(const void* buf) {
	return ::flatbuffers::GetSizePrefixedRoot<fastlanes::TableDescriptor>(buf);
}

inline bool VerifyTableDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifyBuffer<fastlanes::TableDescriptor>(nullptr);
}

inline bool VerifySizePrefixedTableDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifySizePrefixedBuffer<fastlanes::TableDescriptor>(nullptr);
}

inline void FinishTableDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                 fbb,
                                        ::flatbuffers::Offset<fastlanes::TableDescriptor> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedTableDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                 fbb,
                                                    ::flatbuffers::Offset<fastlanes::TableDescriptor> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fastlanes::TableDescriptorT>
UnPackTableDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::TableDescriptorT>(GetTableDescriptor(buf)->UnPack(res));
}

inline std::unique_ptr<fastlanes::TableDescriptorT>
UnPackSizePrefixedTableDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::TableDescriptorT>(GetSizePrefixedTableDescriptor(buf)->UnPack(res));
}

} // namespace fastlanes

#endif // FLATBUFFERS_GENERATED_TABLEDESCRIPTOR_FASTLANES_H_
