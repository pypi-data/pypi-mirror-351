// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ROWGROUPDESCRIPTOR_FASTLANES_H_
#define FLATBUFFERS_GENERATED_ROWGROUPDESCRIPTOR_FASTLANES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 2 && FLATBUFFERS_VERSION_REVISION == 10,
              "Non-compatible flatbuffers version included");

#include "column_descriptor_generated.h"

namespace fastlanes {

struct RowgroupDescriptor;
struct RowgroupDescriptorBuilder;
struct RowgroupDescriptorT;

struct RowgroupDescriptorT : public ::flatbuffers::NativeTable {
	typedef RowgroupDescriptor                                 TableType;
	uint64_t                                                   m_n_vec = 0;
	std::vector<std::unique_ptr<fastlanes::ColumnDescriptorT>> m_column_descriptors {};
	uint64_t                                                   m_size     = 0;
	uint64_t                                                   m_offset   = 0;
	uint64_t                                                   m_n_tuples = 0;
	RowgroupDescriptorT()                                                 = default;
	RowgroupDescriptorT(const RowgroupDescriptorT& o);
	RowgroupDescriptorT(RowgroupDescriptorT&&) FLATBUFFERS_NOEXCEPT = default;
	RowgroupDescriptorT& operator=(RowgroupDescriptorT o) FLATBUFFERS_NOEXCEPT;
};

struct RowgroupDescriptor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
	typedef RowgroupDescriptorT       NativeTableType;
	typedef RowgroupDescriptorBuilder Builder;
	enum FlatBuffersVTableOffset      FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_M_N_VEC              = 4,
        VT_M_COLUMN_DESCRIPTORS = 6,
        VT_M_SIZE               = 8,
        VT_M_OFFSET             = 10,
        VT_M_N_TUPLES           = 12
	};
	uint64_t m_n_vec() const {
		return GetField<uint64_t>(VT_M_N_VEC, 0);
	}
	const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>* m_column_descriptors() const {
		return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>*>(
		    VT_M_COLUMN_DESCRIPTORS);
	}
	uint64_t m_size() const {
		return GetField<uint64_t>(VT_M_SIZE, 0);
	}
	uint64_t m_offset() const {
		return GetField<uint64_t>(VT_M_OFFSET, 0);
	}
	uint64_t m_n_tuples() const {
		return GetField<uint64_t>(VT_M_N_TUPLES, 0);
	}
	bool Verify(::flatbuffers::Verifier& verifier) const {
		return VerifyTableStart(verifier) && VerifyField<uint64_t>(verifier, VT_M_N_VEC, 8) &&
		       VerifyOffset(verifier, VT_M_COLUMN_DESCRIPTORS) && verifier.VerifyVector(m_column_descriptors()) &&
		       verifier.VerifyVectorOfTables(m_column_descriptors()) && VerifyField<uint64_t>(verifier, VT_M_SIZE, 8) &&
		       VerifyField<uint64_t>(verifier, VT_M_OFFSET, 8) && VerifyField<uint64_t>(verifier, VT_M_N_TUPLES, 8) &&
		       verifier.EndTable();
	}
	RowgroupDescriptorT* UnPack(const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	void UnPackTo(RowgroupDescriptorT* _o, const ::flatbuffers::resolver_function_t* _resolver = nullptr) const;
	static ::flatbuffers::Offset<RowgroupDescriptor>
	Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
	     const RowgroupDescriptorT*                _o,
	     const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);
};

struct RowgroupDescriptorBuilder {
	typedef RowgroupDescriptor        Table;
	::flatbuffers::FlatBufferBuilder& fbb_;
	::flatbuffers::uoffset_t          start_;
	void                              add_m_n_vec(uint64_t m_n_vec) {
		                             fbb_.AddElement<uint64_t>(RowgroupDescriptor::VT_M_N_VEC, m_n_vec, 0);
	}
	void add_m_column_descriptors(
	    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>>
	        m_column_descriptors) {
		fbb_.AddOffset(RowgroupDescriptor::VT_M_COLUMN_DESCRIPTORS, m_column_descriptors);
	}
	void add_m_size(uint64_t m_size) {
		fbb_.AddElement<uint64_t>(RowgroupDescriptor::VT_M_SIZE, m_size, 0);
	}
	void add_m_offset(uint64_t m_offset) {
		fbb_.AddElement<uint64_t>(RowgroupDescriptor::VT_M_OFFSET, m_offset, 0);
	}
	void add_m_n_tuples(uint64_t m_n_tuples) {
		fbb_.AddElement<uint64_t>(RowgroupDescriptor::VT_M_N_TUPLES, m_n_tuples, 0);
	}
	explicit RowgroupDescriptorBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
	    : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}
	::flatbuffers::Offset<RowgroupDescriptor> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto       o   = ::flatbuffers::Offset<RowgroupDescriptor>(end);
		return o;
	}
};

inline ::flatbuffers::Offset<RowgroupDescriptor> CreateRowgroupDescriptor(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t                          m_n_vec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>>
             m_column_descriptors = 0,
    uint64_t m_size               = 0,
    uint64_t m_offset             = 0,
    uint64_t m_n_tuples           = 0) {
	RowgroupDescriptorBuilder builder_(_fbb);
	builder_.add_m_n_tuples(m_n_tuples);
	builder_.add_m_offset(m_offset);
	builder_.add_m_size(m_size);
	builder_.add_m_n_vec(m_n_vec);
	builder_.add_m_column_descriptors(m_column_descriptors);
	return builder_.Finish();
}

inline ::flatbuffers::Offset<RowgroupDescriptor> CreateRowgroupDescriptorDirect(
    ::flatbuffers::FlatBufferBuilder&                                      _fbb,
    uint64_t                                                               m_n_vec              = 0,
    const std::vector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>* m_column_descriptors = nullptr,
    uint64_t                                                               m_size               = 0,
    uint64_t                                                               m_offset             = 0,
    uint64_t                                                               m_n_tuples           = 0) {
	auto m_column_descriptors__ =
	    m_column_descriptors
	        ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>(*m_column_descriptors)
	        : 0;
	return fastlanes::CreateRowgroupDescriptor(_fbb, m_n_vec, m_column_descriptors__, m_size, m_offset, m_n_tuples);
}

::flatbuffers::Offset<RowgroupDescriptor>
CreateRowgroupDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                         const RowgroupDescriptorT*                _o,
                         const ::flatbuffers::rehasher_function_t* _rehasher = nullptr);

inline RowgroupDescriptorT::RowgroupDescriptorT(const RowgroupDescriptorT& o)
    : m_n_vec(o.m_n_vec)
    , m_size(o.m_size)
    , m_offset(o.m_offset)
    , m_n_tuples(o.m_n_tuples) {
	m_column_descriptors.reserve(o.m_column_descriptors.size());
	for (const auto& m_column_descriptors_ : o.m_column_descriptors) {
		m_column_descriptors.emplace_back(
		    (m_column_descriptors_) ? new fastlanes::ColumnDescriptorT(*m_column_descriptors_) : nullptr);
	}
}

inline RowgroupDescriptorT& RowgroupDescriptorT::operator=(RowgroupDescriptorT o) FLATBUFFERS_NOEXCEPT {
	std::swap(m_n_vec, o.m_n_vec);
	std::swap(m_column_descriptors, o.m_column_descriptors);
	std::swap(m_size, o.m_size);
	std::swap(m_offset, o.m_offset);
	std::swap(m_n_tuples, o.m_n_tuples);
	return *this;
}

inline RowgroupDescriptorT* RowgroupDescriptor::UnPack(const ::flatbuffers::resolver_function_t* _resolver) const {
	auto _o = std::unique_ptr<RowgroupDescriptorT>(new RowgroupDescriptorT());
	UnPackTo(_o.get(), _resolver);
	return _o.release();
}

inline void RowgroupDescriptor::UnPackTo(RowgroupDescriptorT*                      _o,
                                         const ::flatbuffers::resolver_function_t* _resolver) const {
	(void)_o;
	(void)_resolver;
	{
		auto _e     = m_n_vec();
		_o->m_n_vec = _e;
	}
	{
		auto _e = m_column_descriptors();
		if (_e) {
			_o->m_column_descriptors.resize(_e->size());
			for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				if (_o->m_column_descriptors[_i]) {
					_e->Get(_i)->UnPackTo(_o->m_column_descriptors[_i].get(), _resolver);
				} else {
					_o->m_column_descriptors[_i] =
					    std::unique_ptr<fastlanes::ColumnDescriptorT>(_e->Get(_i)->UnPack(_resolver));
				}
			}
		} else {
			_o->m_column_descriptors.resize(0);
		}
	}
	{
		auto _e    = m_size();
		_o->m_size = _e;
	}
	{
		auto _e      = m_offset();
		_o->m_offset = _e;
	}
	{
		auto _e        = m_n_tuples();
		_o->m_n_tuples = _e;
	}
}

inline ::flatbuffers::Offset<RowgroupDescriptor>
RowgroupDescriptor::Pack(::flatbuffers::FlatBufferBuilder&         _fbb,
                         const RowgroupDescriptorT*                _o,
                         const ::flatbuffers::rehasher_function_t* _rehasher) {
	return CreateRowgroupDescriptor(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RowgroupDescriptor>
CreateRowgroupDescriptor(::flatbuffers::FlatBufferBuilder&         _fbb,
                         const RowgroupDescriptorT*                _o,
                         const ::flatbuffers::rehasher_function_t* _rehasher) {
	(void)_rehasher;
	(void)_o;
	struct _VectorArgs {
		::flatbuffers::FlatBufferBuilder*         __fbb;
		const RowgroupDescriptorT*                __o;
		const ::flatbuffers::rehasher_function_t* __rehasher;
	} _va = {&_fbb, _o, _rehasher};
	(void)_va;
	auto _m_n_vec              = _o->m_n_vec;
	auto _m_column_descriptors = _o->m_column_descriptors.size()
	                                 ? _fbb.CreateVector<::flatbuffers::Offset<fastlanes::ColumnDescriptor>>(
	                                       _o->m_column_descriptors.size(),
	                                       [](size_t i, _VectorArgs* __va) {
		                                       return CreateColumnDescriptor(*__va->__fbb,
		                                                                     __va->__o->m_column_descriptors[i].get(),
		                                                                     __va->__rehasher);
	                                       },
	                                       &_va)
	                                 : 0;
	auto _m_size               = _o->m_size;
	auto _m_offset             = _o->m_offset;
	auto _m_n_tuples           = _o->m_n_tuples;
	return fastlanes::CreateRowgroupDescriptor(_fbb, _m_n_vec, _m_column_descriptors, _m_size, _m_offset, _m_n_tuples);
}

inline const fastlanes::RowgroupDescriptor* GetRowgroupDescriptor(const void* buf) {
	return ::flatbuffers::GetRoot<fastlanes::RowgroupDescriptor>(buf);
}

inline const fastlanes::RowgroupDescriptor* GetSizePrefixedRowgroupDescriptor(const void* buf) {
	return ::flatbuffers::GetSizePrefixedRoot<fastlanes::RowgroupDescriptor>(buf);
}

inline bool VerifyRowgroupDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifyBuffer<fastlanes::RowgroupDescriptor>(nullptr);
}

inline bool VerifySizePrefixedRowgroupDescriptorBuffer(::flatbuffers::Verifier& verifier) {
	return verifier.VerifySizePrefixedBuffer<fastlanes::RowgroupDescriptor>(nullptr);
}

inline void FinishRowgroupDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                    fbb,
                                           ::flatbuffers::Offset<fastlanes::RowgroupDescriptor> root) {
	fbb.Finish(root);
}

inline void FinishSizePrefixedRowgroupDescriptorBuffer(::flatbuffers::FlatBufferBuilder&                    fbb,
                                                       ::flatbuffers::Offset<fastlanes::RowgroupDescriptor> root) {
	fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fastlanes::RowgroupDescriptorT>
UnPackRowgroupDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::RowgroupDescriptorT>(GetRowgroupDescriptor(buf)->UnPack(res));
}

inline std::unique_ptr<fastlanes::RowgroupDescriptorT>
UnPackSizePrefixedRowgroupDescriptor(const void* buf, const ::flatbuffers::resolver_function_t* res = nullptr) {
	return std::unique_ptr<fastlanes::RowgroupDescriptorT>(GetSizePrefixedRowgroupDescriptor(buf)->UnPack(res));
}

} // namespace fastlanes

#endif // FLATBUFFERS_GENERATED_ROWGROUPDESCRIPTOR_FASTLANES_H_
