"""Rebase script generation and execution."""

import os
import subprocess
import tempfile
from datetime import datetime
from typing import List, Tuple

from ..models import CommitGroup


class RebaseScriptGenerator:
    """Generates rebase scripts for dry-run mode."""
    
    def __init__(self, repo_path: str = "."):
        self.repo_path = repo_path
    
    def execute_squash(self, groups: List[CommitGroup]) -> Tuple[bool, str]:
        """Execute the actual squash operation using git commands."""
        try:
            # Create backup branch
            current_branch = subprocess.run(
                ["git", "branch", "--show-current"],
                capture_output=True, text=True, check=True
            ).stdout.strip()
            
            backup_branch = f"backup_{current_branch}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            subprocess.run(
                ["git", "branch", backup_branch],
                check=True
            )
            
            # Process each group
            for group in groups:
                if len(group.commits) <= 1:
                    continue  # Skip single-commit groups
                
                # Sort commits by timestamp (oldest first)
                sorted_commits = sorted(group.commits, key=lambda c: c.timestamp)
                oldest_commit = sorted_commits[0]
                
                # Get the parent of the oldest commit
                parent_hash = oldest_commit.parent_hash
                if not parent_hash:
                    # If no parent (root commit), skip this group
                    continue
                
                # Create a rebase todo file
                with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as todo_file:
                    # Write rebase instructions
                    todo_file.write(f"pick {oldest_commit.hash} {oldest_commit.message}\n")
                    for commit in sorted_commits[1:]:
                        todo_file.write(f"squash {commit.hash} {commit.message}\n")
                    todo_file.flush()
                    todo_path = todo_file.name
                
                # Create a commit message file
                with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as msg_file:
                    msg_file.write(group.suggested_message)
                    msg_file.flush()
                    msg_path = msg_file.name
                
                try:
                    # Set up git sequence editor to use our todo file
                    env = os.environ.copy()
                    env['GIT_SEQUENCE_EDITOR'] = f'cp {todo_path}'
                    env['GIT_EDITOR'] = f'cp {msg_path}'
                    
                    # Execute the rebase
                    result = subprocess.run(
                        ["git", "rebase", "-i", parent_hash],
                        env=env,
                        capture_output=True,
                        text=True
                    )
                    
                    if result.returncode != 0:
                        # Try to abort the rebase if it failed
                        subprocess.run(["git", "rebase", "--abort"], capture_output=True)
                        return False, f"Rebase failed: {result.stderr}"
                        
                finally:
                    # Clean up temp files
                    if os.path.exists(todo_path):
                        os.unlink(todo_path)
                    if os.path.exists(msg_path):
                        os.unlink(msg_path)
            
            return True, backup_branch
            
        except subprocess.CalledProcessError as e:
            return False, f"Git command failed: {e.stderr if hasattr(e, 'stderr') else str(e)}"
        except Exception as e:
            return False, f"Unexpected error: {str(e)}"
    
    def generate_rebase_script(self, groups: List[CommitGroup], output_path: str) -> str:
        """Generate a shell script that performs the rebase operations."""
        script_lines = [
            "#!/bin/bash",
            "# Generated by git-smart-squash",
            f"# Generated on: {datetime.now().isoformat()}",
            "",
            "set -e  # Exit on any error",
            "",
            "echo 'Starting git smart squash operations...'",
            ""
        ]
        
        # Add backup creation
        script_lines.extend([
            "# Create backup branch",
            'CURRENT_BRANCH="$(git branch --show-current)"',
            'BACKUP_BRANCH="backup_${CURRENT_BRANCH}_$(date +%Y%m%d_%H%M%S)"',
            'git branch "$BACKUP_BRANCH"',
            'echo "Created backup branch: $BACKUP_BRANCH"',
            ""
        ])
        
        # Generate rebase instructions for each group
        for i, group in enumerate(groups):
            if len(group.commits) > 1:
                sorted_commits = sorted(group.commits, key=lambda c: c.timestamp)
                oldest_commit = sorted_commits[0]
                
                if not oldest_commit.parent_hash:
                    continue
                
                script_lines.extend([
                    f"# Group {i+1}: {group.rationale}",
                    f"# Squashing {len(group.commits)} commits",
                    f"# New message: {group.suggested_message}",
                    "",
                    "# Create todo file for rebase",
                    f"TODO_FILE=$(mktemp)",
                    f"MSG_FILE=$(mktemp)",
                    "",
                    "cat << 'EOF' > $TODO_FILE",
                    f"pick {oldest_commit.hash} {oldest_commit.message}",
                ])
                
                for commit in sorted_commits[1:]:
                    script_lines.append(f"squash {commit.hash} {commit.message}")
                
                script_lines.extend([
                    "EOF",
                    "",
                    "cat << 'EOF' > $MSG_FILE",
                    group.suggested_message,
                    "EOF",
                    "",
                    f"GIT_SEQUENCE_EDITOR=\"cp $TODO_FILE\" GIT_EDITOR=\"cp $MSG_FILE\" git rebase -i {oldest_commit.parent_hash}",
                    "rm -f $TODO_FILE $MSG_FILE",
                    ""
                ])
        
        script_lines.extend([
            "",
            "echo 'Git smart squash completed successfully!'",
            'echo "Backup branch created: $BACKUP_BRANCH"',
            'echo "To restore backup: git reset --hard $BACKUP_BRANCH"'
        ])
        
        # Write script to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(script_lines))
        
        # Make script executable
        os.chmod(output_path, 0o755)
        
        return output_path