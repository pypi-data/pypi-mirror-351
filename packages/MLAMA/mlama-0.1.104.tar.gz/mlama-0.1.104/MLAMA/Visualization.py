# -*- coding: utf-8 -*-
"""Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fdbWbsZgYTqDMrbVlC0MVfjGy8HRutCm
"""

# -*- coding: utf-8 -*-
"""Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fdbWbsZgYTqDMrbVlC0MVfjGy8HRutCm
"""

from pandas import read_csv
from pandas import DataFrame
from pandas import concat
import pandas as pd
import numpy as np
import matplotlib.dates as mdates
import matplotlib.colors as mcolors
import matplotlib.pyplot as plt
from .Predictions import individual_model_weekly_count, individual_model_weekly_MAPE
from .Processor import process_metrics_df, find_model_week_values_sum_shift


#generalized version updated!
#visualization
def visualize_weekly_case_count_all_model_each_wave(WAVES, predictions, trend_adjustment_steps, wave_start_shift_matrix, model_evaluation_dictionary, recent_week_count, models):
    """
    Visualizes weekly case counts with predictions for ARIMA and ML models.
    """
    # Generate per-model metrics (A_dict, B_dict, etc.)
    model_dicts = individual_model_weekly_count(WAVES, predictions, trend_adjustment_steps, model_evaluation_dictionary, models, recent_week_count)
    # print(model_dicts)
    #model_dicts = {}
    #for model_name in models.keys():
        #model_dicts[model_name] = model_results[model_name]

    max_x_tick = 25  # Maximum number of x-tick labels

    for WAVE in WAVES:
        waveID = WAVE.waveID
        #print("Wave: ", waveID)

        fig = plt.figure(figsize=(25, 25))
        gs = fig.add_gridspec(len(predictions) + 1, len(trend_adjustment_steps), hspace=0.2, wspace=0.2)

        #time = WAVE.get_wave_df().tail(recent_week_count).reset_index(drop=False)
        # Determine global min and max for y-axis across all shifts and predictions
        all_weekcase_values = []
        all_prediction_values = []

        for shift in trend_adjustment_steps:
            from_date, to_date = WAVE.get_wave_test_start_date_with_shift(shift)
            shifted_wave, _, _ = WAVE.get_wave_dates_with_shift(shift, wave_start_shift_matrix)
            time = shifted_wave.tail(recent_week_count).reset_index(drop=False)
            all_weekcase_values.extend(time['weekcase'].tolist())
            for prediction_length in predictions:
              for model_name, model_data in model_dicts.items():
                    wave_model_data = model_data[waveID][shift]
                    column_name = f"{model_name}_{prediction_length}"
                    if column_name in wave_model_data.columns:
                        all_prediction_values.extend(wave_model_data[column_name].tolist())


        # Combine all values for percentile calculation
        all_values = np.array(all_weekcase_values + all_prediction_values)

        all_values = all_values[np.isfinite(all_values)]  # Keep only finite values

        # Check if all_values is empty, and provide a default max_y if needed
        if len(all_values) > 0:
            upper_limit = np.percentile(all_values, 98)  # Use 98th percentile to avoid extreme outliers
            max_y = max(upper_limit, max(all_weekcase_values, default=0)) * 1.2  # Add 20% margin for better visualization
        else:
            max_y = 1  # Default small value to avoid NaN/Inf error

        # Set the minimum y-limit
        min_y = 0  # Weekly case count can't be negative

        # Find global min and max y-values
        # min_y = 0  # Assuming weekly case count can't be negative
        # max_y = max(all_weekcase_values) * 1.2  # Adding 20% margin for better visibility
        #max_y = max(max(all_weekcase_values, default=0), max(all_prediction_values, default=0)) * 1.1  # Adding 10% margin for better visibility


        shift0 = trend_adjustment_steps[0]
        trend_change_date, _ = WAVE.get_wave_test_start_date_with_shift(shift0)
        d = datetime.datetime.strptime(trend_change_date,"%Y-%m-%d")
        w = datetime.timedelta(weeks=1)
        s = d-w
        trend_change_date = s.strftime("%Y-%m-%d")

        shifted_wave, _, _ = WAVE.get_wave_dates_with_shift(shift0, wave_start_shift_matrix)
        time0 = shifted_wave.tail(recent_week_count).reset_index(drop=False)
        # print(time0)
        for shift in trend_adjustment_steps:
            from_date, to_date = WAVE.get_wave_test_start_date_with_shift(shift)
            shifted_wave, _, _ = WAVE.get_wave_dates_with_shift(shift, wave_start_shift_matrix)
            time = shifted_wave.tail(recent_week_count).reset_index(drop=False)
            all_weekcase_values.extend(time['weekcase'].tolist())
            additional_time_in_time0 = time0[~time0['week'].isin(time['week'])]

            # print(f"Additional time points in shift 0 at the start for shift {shift}:\n", additional_time_in_time0)

            print("Wave: ", waveID, "Shift: ", shift, 'from: ', from_date, to_date)#updated time here, to get correct x_axis
            for prediction_length in predictions:
                ax = fig.add_subplot(gs[prediction_length, shift])
                plt.subplots_adjust(left=0.04, right=0.9, top=0.9, bottom=0.01)
                ax.set_ylim(min_y, max_y)  # Ensure consistent y-axis across all subplots


                # Scatter plot for observed weekly cases

                # Concatenate additional_time_in_time0 at the front of time
                time_extended = pd.concat([additional_time_in_time0, time], ignore_index=True)
                # Sort by 'week' to maintain chronological order
                time_extended = time_extended.sort_values(by='week').reset_index(drop=True)

                # Now plot
                ax.scatter(time_extended['week'], time_extended['weekcase'], color='black', label='Observed', zorder=3)
                #ax.scatter(time['week'], time['weekcase'], color='black', label='Observed', zorder=3)

                # Customize Axes
                #ax.axvline(x=from_date, color='grey', linestyle="--")
                ax.axvline(x=trend_change_date, color='grey', linestyle="-")
                ax.axvline(x=to_date, color='grey', linestyle="--")

                # Plot each model's predictions dynamically

                for model_name, model_data in model_dicts.items():
                    wave_model_data = model_data[waveID][shift]

                    #print(f"{model_name}: {wave_model_data}")
                    column_name = f"{model_name}_{prediction_length}"
                    #print('column_name: ', column_name)
                    #print(wave_model_data[column_name].dropna())
                    #print(wave_model_data.columns)
                    #print('model_name: ', model_name, 'waveID', waveID, 'shift', shift, 'prediction_length', prediction_length)
                    if column_name in wave_model_data.columns:
                        ax.plot(wave_model_data[column_name].dropna(), label=model_name, linewidth=2)


                if shift == 0:
                    plt.ylabel(f"Prediction Length = {prediction_length} Week")
                if prediction_length == 1:
                    ax.set_title(f"Shift = {shift} Week")
                if prediction_length == 6:
                    ax.tick_params(axis='x', labelrotation=90)
                else:
                    ax.set_xticklabels([])
                    ax.set_xticks([])

        ax.legend(bbox_to_anchor=(-0.5, -0.5), ncol=4, fontsize=20)
        fig.text(0, 0.5, f'Weekly Case Count, Wave = {waveID}', va='center', rotation='vertical', fontsize="20")
        plt.show()



#generalized

from matplotlib.colors import ListedColormap
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

def visualize_weekly_MAPE_all_model_each_wave(WAVES, predictions, trend_adjustment_steps, model_evaluation_dictionary, recent_week_count, models):
    """
    Generalized function to visualize weekly MAPE for multiple models across waves.

    Parameters:
        WAVES: List of wave objects containing wave IDs.
        predictions: Model predictions.
        trend_adjustment_steps: List of shifts for predictions.
        model_evaluation_dictionary: Dictionary of evaluation results.
        recent_week_count: Number of recent weeks to consider.
        models: Dictionary of models to visualize with their keys and associated methods (e.g., {'ARIMA': SARIMAX, 'RF': RandomForestRegressor}).
    """
    model_results_wave_collection = individual_model_weekly_MAPE(WAVES, predictions, trend_adjustment_steps, model_evaluation_dictionary, models)
    mape_wave_shift = {}
    # print('individual_model_weekly_MAPE DONE')
    for WAVE in WAVES:  # Iterate over each wave
        waveID = WAVE.waveID
        fig, axes = plt.subplots(len(models), len(trend_adjustment_steps), sharex=True, sharey=True, figsize=(25, 10))
        gs = fig.add_gridspec(len(models), len(trend_adjustment_steps), hspace=0.2, wspace=0.2)
        plt.subplots_adjust(left=0.08, right=0.9, top=0.9, bottom=0.1)

        for model_index, (model_name, model_class) in enumerate(models.items()):  # Dynamically iterate over models
            model_results_collection = model_results_wave_collection[model_name][waveID]

            for shift in trend_adjustment_steps:  # Iterate over shifts
                ax = axes[model_index, shift]
                mape_shift = pd.DataFrame()
                weeks = [x - 1 for x in predictions]
                #print('model_results_collection', model_results_collection)
                # Retrieve and plot model results
                all_week_list, values_list = find_model_week_values_sum_shift(model_results_collection, shift, weeks)
                values_df = pd.DataFrame(values_list)
                values_df.columns = [model_name]
                #print('okk')
                # Bar and line plot
                all_week_list.plot(
                    kind='bar',
                    stacked=False,
                    width=1,
                    colormap=ListedColormap(sns.color_palette("muted", 10)),
                    figsize=(13, 15),
                    ax=ax
                )
                #ax.plot(values_list, label="MAPE")
                ax.plot(values_list, label="MAPE", marker='o')  # Line plot with markers
                ax.scatter(range(len(values_list)), values_list, color='red', label="MAPE Points", zorder=3)  # Scatter plot for individual points

                ax.set_title(f"Shift = {shift} Week ")
                ax.get_legend().remove()

                mape_shift = pd.concat([mape_shift, values_df], axis=1, join='inner')  # Concatenate MAPE results
                mape_wave_shift[waveID] = mape_shift
                #print('waveID ', waveID, 'shift', shift)#, 'mape_shift', mape_shift)
                # Labeling
                if shift == 0:
                    ax.set_ylabel(model_name)
                if shift == len(trend_adjustment_steps) - 1 and model_index == len(models) - 1:
                    ax.legend(
                        ["MAPE", "MAPE", 'First Week', 'Second Week', 'Third Week', 'Fourth Week', 'Fifth Week', 'Sixth Week'],
                        loc='lower center',
                        bbox_to_anchor=(-2, -0.3),
                        ncol=7
                    )

        # Super labels
        fig.supxlabel(f"Prediction Length (Week), Wave = {waveID}")
        fig.supylabel("MAPE %")

    return mape_wave_shift

def safe_to_datetime(x):
    if isinstance(x, (str, bytes)):
        return datetime.datetime.fromisoformat(x)
    return pd.to_datetime(x)  # handles datetime, pandas Timestamp, etc.



import matplotlib.pyplot as plt
import datetime
#Visualization.py
def visualize_wave_shifts(data_dict):
    """
    Plots clearer and user-friendly time interval ranges for all wave-shift combinations.

    Args:
        data_dict (dict): A dictionary containing wave shift combinations
                          with 'all', 'train', and 'test' data ranges.
    """
    plt.figure(figsize=(14, 8))
    plt.title("Time Interval Comparison for Wave-shift Combinations", fontsize=16, pad=20)
    plt.xlabel("Date", fontsize=14, labelpad=40)  # Move x-axis label down
    plt.ylabel("Wave-shift Combinations", fontsize=14, labelpad=15)  # Move y-axis label up

    # Move y-axis label farther to the right
    plt.gca().yaxis.set_label_coords(-0.1, 0.5)  # Adjust x and y positions of label


    y_offset = 1  # Start y_offset for waves
    spacing = 2  # Spacing between each wave

    for wave_name, intervals in data_dict.items():
        all_range = [safe_to_datetime(i) for i in intervals['all'].index]
        train_range = [safe_to_datetime(i) for i in intervals['train'].index]
        test_range = [safe_to_datetime(i) for i in intervals['test'].index]


    # for wave_name, intervals in data_dict.items():
    #     # Extract ranges and convert to datetime
    #     all_range = [datetime.datetime.fromisoformat(i) for i in intervals['all'].index]
    #     train_range = [datetime.datetime.fromisoformat(i) for i in intervals['train'].index]
    #     test_range = [datetime.datetime.fromisoformat(i) for i in intervals['test'].index]

        # Plot 'all', 'train', and 'test' ranges with spacing
        plt.hlines(y=y_offset, xmin=all_range[0], xmax=all_range[-1], color='gray', label='Full Range' if y_offset == 1 else "", linewidth=2, alpha=0.7)
        plt.hlines(y=y_offset + 0.5, xmin=train_range[0], xmax=train_range[-1], color='blue', label='Train Range' if y_offset == 1 else "", linewidth=2)
        plt.hlines(y=y_offset + 1, xmin=test_range[0], xmax=test_range[-1], color='green', label='Test Range' if y_offset == 1 else "", linewidth=2)

        # Add markers for start and end dates
        plt.scatter([all_range[0], all_range[-1]], [y_offset, y_offset], color='gray', edgecolor='black', s=40, label='_nolegend_')
        plt.scatter([train_range[0], train_range[-1]], [y_offset + 0.5, y_offset + 0.5], color='blue', edgecolor='black', s=40, label='_nolegend_')
        plt.scatter([test_range[0], test_range[-1]], [y_offset + 1, y_offset + 1], color='green', edgecolor='black', s=40, label='_nolegend_')

        # Annotate wave name slightly to the left
        plt.text(all_range[0] - datetime.timedelta(days=7), y_offset - 0.2, wave_name, fontsize=12, ha='right', color='black')

        # Increment y_offset for the next wave
        y_offset += spacing

    # Adjust y-axis limits
    plt.ylim(0, y_offset)
    plt.yticks([])  # Remove y-axis ticks for a cleaner look
    plt.xticks(rotation=45, fontsize=12)

    # Add a grouped legend
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15), fontsize=12, ncol=3, frameon=False)

    # Final layout adjustments
    plt.tight_layout()
    plt.show()





#generalized


def plot_predictions(wave_tasks, labels, shift, prediction_length, MAPE_data_dictionary, models, observed_label='Observed', recent_week_count=None, model_colors=None):
    """
    Generalized function to plot predictions for multiple ML models and ARIMA.

    Parameters:
    - wave_tasks: List of wave task objects
    - shift: shift amount parameter
    - prediction_length: Prediction length parameter
    - MAPE_data_dictionary: Dictionary containing MAPE data for each wave, shift, and prediction length
    - models: Dictionary of models to include in the plot
    - observed_label: Column name for the observed data
    - recent_week_count: Optional. Number of weeks to consider for plotting. Defaults to None (all data).
    - model_colors: Optional dictionary mapping model names to specific plot colors.
    """
    fig = plt.figure(figsize=(16, 10))
    plt.subplots_adjust(left=0.1, right=1, top=1, bottom=0.15)
    gs = fig.add_gridspec(len(wave_tasks), 1, hspace=0, wspace=0)
    i = 0

    for wave in wave_tasks:
        waveID = wave.waveID
        wave_shift_prediction_length_key = f'wave {waveID} shift {shift} prediction_length {prediction_length}'
        task = MAPE_data_dictionary[wave_shift_prediction_length_key]

        # Extract recent weeks if specified
        if recent_week_count:
            task = task.tail(recent_week_count).reset_index(drop=True)

        ax = fig.add_subplot(gs[i, 0])

        # Plot each model's predictions
        for model_name in models.keys():
            if model_name in task.columns:
                color = model_colors.get(model_name, None) if model_colors else None
                ax.plot(task.index, task[model_name], label=model_name, linestyle='-', lw=1.5, color=color)

        # Plot observed data
        if observed_label in task.columns:
            ax.plot(task.index, task[observed_label], label=observed_label, color='black', linestyle='dotted')

        ax.set_ylabel("Wave " + labels[i], fontsize=13)
        i += 1

        if i >= 2:
            ax.legend(loc='lower center', bbox_to_anchor=(1.05, 1), ncol=1)
            ax.set_xticklabels(task.index, rotation=45)

        ax.axvline('2023-10-08', color='black', linestyle='--', lw=2)  # Example date for a vertical line

    # Adding title and labels
    fig.supxlabel('Week', fontsize=16)
    fig.supylabel("Covid Cases", fontsize=16)
    plt.show()


# def plot_predictions(wave_tasks, labels, shift, prediction_length, MAPE_data_dictionary, models, observed_label='Observed', recent_week_count=None):
#     """
#     Generalized function to plot predictions for multiple ML models and ARIMA.

#     Parameters:
#     - wave_tasks: List of wave task objects
#     - shift: shift amount parameter
#     - prediction_length: Prediction length parameter
#     - MAPE_data_dictionary: Dictionary containing MAPE data for each wave, shift, and prediction length
#     - models: Dictionary of models to include in the plot
#     - observed_label: Column name for the observed data
#     - recent_week_count: Optional. Number of weeks to consider for plotting. Defaults to None (all data).
#     """
#     fig = plt.figure(figsize=(16, 10))
#     plt.subplots_adjust(left=0.1, right=1, top=1, bottom=0.15)
#     gs = fig.add_gridspec(len(wave_tasks), 1, hspace=0, wspace=0)
#     i = 0

#     #labels = ['', " & 2", " & 2 & 1"]  # Example labels for waves
#     for wave in wave_tasks:
#         waveID = wave.waveID
#         wave_shift_prediction_length_key = f'wave {waveID} shift {shift} prediction_length {prediction_length}'
#         task = MAPE_data_dictionary[wave_shift_prediction_length_key]

#         # Extract recent weeks if specified
#         if recent_week_count:
#             task = task.tail(recent_week_count).reset_index(drop=True)

#         ax = fig.add_subplot(gs[i, 0])

#         # Plot each model's predictions
#         for model_name in models.keys():
#             if model_name in task.columns:
#                 ax.plot(task.index, task[model_name], label=model_name, linestyle='-', lw=1.5)

#         # Plot observed data
#         if observed_label in task.columns:
#             ax.plot(task.index, task[observed_label], label=observed_label, color='black', linestyle='dotted')

#         ax.set_ylabel("Wave "+labels[i], fontsize=13)

#         i += 1
#         if i >= 2:
#             ax.legend(loc='lower center', bbox_to_anchor=(1.05, 1), ncol=1)
#             ax.set_xticklabels(task.index, rotation=45)

#         ax.axvline('2023-10-08', color='black', linestyle='--', lw=2)  # Example date for a vertical line

#     # Adding title and labels
#     fig.supxlabel('Week', fontsize=16)
#     fig.supylabel("Covid Cases", fontsize=16)
#     plt.show()

def plot_weekly_predictions(weekly_prediction_future, models, shift, length, shift_type = 'Responsiveness', model_colors=None):
    """
    Plots weekly predictions from different models for a specified shift and length.

    Parameters:
    - weekly_prediction_future (dict): Dictionary containing weekly predictions.
    - models (dict): Dictionary mapping model names to their implementations.
    - shift (int): The shift value to filter the data.
    - length (float): The length value to filter the data.
    """

    # Extract weeks (keys) and model predictions (values)
    weeks = list(weekly_prediction_future.keys())

    # Initialize an empty dictionary to store model predictions
    model_predictions = {model: [] for model in ['Observed', 'ARIMA', 'MLAMA'] + list(models.keys())}
    filtered_weeks = []

    # Loop through each week and extract the predictions
    for week in weeks:
        data = weekly_prediction_future[week]

        # Filter based on shift and length

        # if data['Shift'][0] != shift or data['Length'][0] != length:
        #     continue  # Skip weeks that do not match criteria
        data_filtered = data[(data['Shift']==0) & (data['Length']==1)]
        filtered_weeks.append(week)
        #print(week, filtered_weeks)
        # Extract observed values
        model_predictions['Observed'].append(data_filtered['Observed'] if 'Observed' in data_filtered else None)

        # Extract model predictions
        model_predictions['ARIMA'].append(data_filtered['ARIMA'] if 'ARIMA' in data_filtered else None)
        model_predictions['MLAMA'].append(data_filtered['MLAMA'] if 'MLAMA' in data_filtered else None)

        for model in models.keys():
            if model == 'ARIMA':
                continue
            model_predictions[model].append(data_filtered[model] if model in data_filtered else None)

    # Convert week labels to datetime for proper plotting
    week_dates = pd.to_datetime(filtered_weeks)

    # Plot the data
    plt.figure(figsize=(12, 6))

    # Plot each model's predictions
    # for model, values in model_predictions.items():
    #     plt.plot(week_dates, values, marker='o', label=model)

    for model, values in model_predictions.items():
        if model_colors and model in model_colors:
            plt.plot(week_dates, values, marker='o', label=model, color=model_colors[model])
        else:
            plt.plot(week_dates, values, marker='o', label=model)  # default color

    plt.xlabel("Week")
    plt.ylabel("Predicted Value")
    plt.title(f"Weekly Predictions for Shift ({shift_type})={shift}, Length={length}")
    plt.legend()
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.show()

def plot_weekly_evaluation(weekly_prediction_future, models, shift, length, evaluation_metric_suffix, shift_type = 'Responsiveness', model_colors=None):
    """
    Plots weekly evaluation metrics (e.g., MAPE or MSE) from different models for a specified shift and length.

    Parameters:
    - weekly_prediction_future (dict): Dictionary containing weekly evaluation metrics.
    - models (dict): Dictionary mapping model names to their implementations.
    - shift (int): The shift value to filter the data.
    - length (float): The length value to filter the data.
    - evaluation_metric_suffix (str): The suffix for the evaluation metric (e.g., "_MAPE" or "_MSE").
    """

    print('Shift:', shift, 'prediction_length:', length)

    # Extract weeks (keys)
    weeks = list(weekly_prediction_future.keys())

    # Initialize dictionary to store evaluation metrics for each model
    model_evaluation = {model + evaluation_metric_suffix: [] for model in ['MLAMA', 'ARIMA'] + list(models.keys())}

    filtered_weeks = []

    # Loop through each week and extract the evaluation metrics
    for week in weeks:
        data = weekly_prediction_future.get(week)  # Get week's data safely
        if data is None:
            continue  # Skip if there's no data

        # Apply filtering based on shift and Length
        data_filtered = data[(data['Shift'] == shift) & (data['Length'] == length)]

        if data_filtered.empty:
            continue  # Skip if no matching data

        filtered_weeks.append(week)  # Store filtered week

        # Extract and store evaluation metrics for each model
        for model in model_evaluation.keys():
            if model in data_filtered:
                value = data_filtered[model].iloc[0]  # Extract first row's value safely
                if isinstance(value, list):
                    value = value[0]  # Extract from list if it's inside a list
                model_evaluation[model].append(value)
            else:
                model_evaluation[model].append(None)  # Fill missing values with None

    # Convert week labels to datetime for proper plotting
    week_dates = pd.to_datetime(filtered_weeks)

    # Plot the data
    plt.figure(figsize=(12, 6))

    # Plot each model's evaluation metric
    # for model, values in model_evaluation.items():
    #     plt.plot(week_dates, values, marker='o', label=model)

    for model, values in model_evaluation.items():
        if model_colors and model in model_colors:
            plt.plot(week_dates, values, marker='o', label=model, color=model_colors[model])
        else:
            plt.plot(week_dates, values, marker='o', label=model)  # default color

    plt.xlabel("Week")
    plt.ylabel(f"Evaluation Metric {evaluation_metric_suffix}")
    plt.title(f"Weekly Evaluation for Shift ({shift_type})={shift}, Length={length}")
    plt.legend()
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.show()

def plot_weekly_difference(weekly_prediction_future, models, delay, length, shift_type = 'Responsiveness', model_colors=None):
    """
    Plots weekly differences (prediction - observed) from different models for a specified delay and length.

    Parameters:
    - weekly_prediction_future (dict): Dictionary containing weekly predictions and all other values.
    - models (dict): Dictionary mapping model names to their implementations.
    - delay (int): The delay value to filter the data.
    - length (float): The length value to filter the data.
    - model_colors (dict, optional): Optional dictionary mapping model names to specific plot colors.
    """

    weeks = list(weekly_prediction_future.keys())
    model_diff = {model: [] for model in ['ARIMA', 'MLAMA'] + list(models.keys())}
    filtered_weeks = []

    for week in weeks:
        data = weekly_prediction_future.get(week)
        data_filtered = data[(data['Shift'] == delay) & (data['Length'] == length)]
        if data_filtered.empty:
            continue

        filtered_weeks.append(week)
        observed_val = data_filtered['Observed'].iloc[0] if 'Observed' in data_filtered else None

        model_diff['ARIMA'].append(data_filtered['diff_ARIMA'].iloc[0] if 'diff_ARIMA' in data_filtered else None)

        if 'MLAMA' in data_filtered and observed_val is not None:
            mlama_val = data_filtered['MLAMA'].iloc[0]
            model_diff['MLAMA'].append(mlama_val - observed_val)
        else:
            model_diff['MLAMA'].append(None)

        for model in models.keys():
            if model in ['ARIMA', 'MLAMA']:
                continue
            diff_col = 'diff_' + model
            model_diff[model].append(data_filtered[diff_col].iloc[0] if diff_col in data_filtered else None)

    week_dates = pd.to_datetime(filtered_weeks)

    # Plot
    plt.figure(figsize=(12, 6))
    for model, values in model_diff.items():
        if model_colors and model in model_colors:
            plt.plot(week_dates, values, marker='o', label=model, color=model_colors[model])
        else:
            plt.plot(week_dates, values, marker='o', label=model)  # default color

    plt.xlabel("Week")
    plt.ylabel("Difference (Prediction - Observed)")
    plt.title(f"Weekly Differences for Shift ({shift_type}) = {delay}, Length = {length}")
    plt.xticks(rotation=45)
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()


# def plot_responsiveness_vs_metric(theDD, metric_name):
#   # Filter only metric data for plotting
#   theDD_metric = theDD[theDD['Metric'] == metric_name]
#   # P1 Plot 1: Adaptability vs MAPE
#   plt.figure(figsize=(10, 6))
#   sns.lineplot(data=theDD_metric, x='Adaptability', y='Value', hue='Algorithm', linewidth=2.0)
#   plt.ylabel('S'+metric_name)
#   plt.xlabel('Adaptability/Responsiveness is x-axis. Delayed train+test, how many additional weeks are added for training,  \n'
#             'so testing starts from later point in time, test size depends on prediction_length,\n'
#             'for all the waves and prediction length averaged to calculate MAPE. \n'
#             'Number of Weeks of Data Since the Local Min/Max')
#   plt.title('a. Responsiveness')
#   plt.show()

def plot_responsiveness_vs_metric(theDD, metric_name):
    # Filter only metric data for plotting
    theDD_metric = theDD[theDD['Metric'] == metric_name].copy()

    # Ensure MLAMA is plotted last
    algo_order = sorted(theDD_metric['Algorithm'].unique(), key=lambda x: (x != 'MLAMA', x))

    # P1 Plot 1: Adaptability vs Metric
    plt.figure(figsize=(10, 6))
    sns.lineplot(data=theDD_metric, x='Adaptability', y='Value', hue='Algorithm', hue_order=algo_order, linewidth=2.0)

    plt.ylabel('S' + metric_name)
    plt.xlabel('Adaptability/Responsiveness is x-axis. Delayed train+test, how many additional weeks are added for training,  \n'
               'so testing starts from later point in time, test size depends on prediction_length,\n'
               'for all the waves and prediction length averaged to calculate MAPE. \n'
               'Number of Weeks of Data Since the Local Min/Max')
    plt.title('a. Responsiveness')
    plt.show()


def plot_prediction_length_vs_metric(theD_long, metric_name, shift_type = 'Responsiveness'):
    suffix = '_' + metric_name
    theDD_metric_length = theD_long[theD_long['Algorithm'].str.endswith(suffix)].copy()
    theDD_metric_length['Algorithm'] = theDD_metric_length['Algorithm'].str.replace(suffix, '', regex=False)

    # Group data
    theDD_metric_length = theDD_metric_length.groupby(['Algorithm', 'Prediction Length']).agg({'Value': 'mean'}).reset_index()

    # Ensure MLAMA is plotted last
    algo_order = sorted(theDD_metric_length['Algorithm'].unique(), key=lambda x: (x != 'MLAMA', x))

    # Plot with adjusted order
    plt.figure(figsize=(10, 6))
    sns.lineplot(data=theDD_metric_length, x='Prediction Length', y='Value', hue='Algorithm', hue_order=algo_order, linewidth=2.0)

    plt.ylabel(metric_name)
    plt.xlabel(f'Number of Weeks in Forecast, averaged for all shift ({shift_type}), wave')
    plt.title(f'Prediction Length vs {metric_name}')
    plt.show()

def plot_model_weights(stan_optimal_weights, shift_type = 'Responsiveness', plot_type='bar', order="shift_pred", title=""):
    """
    Plots model weights across shifts and prediction lengths.

    Parameters:
        stan_optimal_weights (dict): Dictionary with keys as "Shift PredictionLength" (str)
                                     and values as tuples of (model_names, weight_values).
        plot_type (str): Type of plot to generate. Options: 'bar', 'lineplot'.
        order (str): Ordering of x-axis. Options: "shift_pred" or "pred_shift".

    Returns:
        None
    """
    # Extract keys and values
    keys = list(stan_optimal_weights.keys())
    model_names, weight_values = zip(*stan_optimal_weights.values())  # Unpack names & weights
    weights = np.array(weight_values)  # Convert to NumPy array

    # Convert keys into separate shift and prediction length
    shifts, pred_lengths = zip(*[map(int, key.split()) for key in keys])

    # Sort data based on order preference
    if order == "shift_pred":
        sorted_indices = np.lexsort((pred_lengths, shifts))
    elif order == "pred_shift":
        sorted_indices = np.lexsort((shifts, pred_lengths))
    else:
        raise ValueError("Invalid order. Choose 'shift_pred' or 'pred_shift'.")

    # Apply sorting
    shifts = [shifts[i] for i in sorted_indices]
    pred_lengths = [pred_lengths[i] for i in sorted_indices]
    weights = weights[sorted_indices]
    keys = [keys[i] for i in sorted_indices]

    # Extract correct model names (assuming they are the same across keys)
    model_names = model_names[0]

    # Format x-axis labels based on ordering preference
    if order == "shift_pred":
        x_labels = [f"({s}, {p})" for s, p in zip(shifts, pred_lengths)]
        xlabel = f"(Shift ({shift_type}), Prediction Length)"
    else:
        x_labels = [f"({p}, {s})" for s, p in zip(shifts, pred_lengths)]
        xlabel = f"(Prediction Length, Shift ({shift_type})"

    if plot_type == 'bar':
        # Bar Plot (Side by Side)
        fig, ax = plt.subplots(figsize=(12, 6))
        x = np.arange(len(x_labels))  # X-axis positions
        width = 0.15  # Bar width

        for i, model in enumerate(model_names):
            ax.bar(x + i * width, weights[:, i], width=width, label=model)

        ax.set_xticks(x + (len(model_names) - 1) * width / 2)
        ax.set_xticklabels(x_labels, rotation=45, ha="right")
        ax.set_ylabel('Weight')
        ax.set_xlabel(xlabel)
        ax.set_title('Model Weights' +title)
        ax.legend(title="Models")
        ax.grid(axis="y", linestyle="--", alpha=0.7)

    elif plot_type == 'lineplot':
        # Line Plot
        plt.figure(figsize=(10, 5))

        for i, model in enumerate(model_names):
            model_weights = [weights[j][i] for j in range(len(weights))]
            plt.plot(x_labels, model_weights, label=model, marker='o')

        plt.xticks(rotation=45, ha="right")
        plt.xlabel(xlabel)
        plt.ylabel('Weight')
        plt.title('Model Weights')
        plt.legend(title="Models")
        plt.grid(linestyle="--", alpha=0.7)

    else:
        raise ValueError("Invalid plot_type. Choose 'bar' or 'lineplot'.")

    plt.show()

def plot_model_weights_all_weeks(model_weights, shift_type='Responsiveness', plot_type='bar', order='shift_pred'):
    """
    Plots model weights for each week contained in the model_weights dictionary.

    Parameters:
        model_weights (dict): Nested dictionary structured as:
                              {
                                '2025-01-05': {
                                    '0 1': (['ARIMA', 'RF', 'xgb'], [0.29, 0.33, 0.37]),
                                    ...
                                },
                                ...
                              }
        shift_type (str): Descriptive label for 'Shift' in x-axis (default: 'Responsiveness').
        plot_type (str): 'bar' or 'lineplot' for each week's visualization.
        order (str): 'shift_pred' or 'pred_shift' for x-axis ordering.

    Returns:
        None
    """
    for week, weight_dict in model_weights.items():
        print(f"📅 Plotting weights for week: {week}")
        plot_model_weights(weight_dict, shift_type=shift_type, plot_type=plot_type, order=order)#, title = "week: {week}"

import matplotlib.pyplot as plt
from collections import defaultdict
import numpy as np

def plot_weights_by_shift_length_over_weeks(model_weights, shift_type='Responsiveness', plot_type='bar'):
    """
    For each shift length, plot model weights (ARIMA, RF, xgb) across all weeks.

    Parameters:
        model_weights (dict): Nested dictionary structured as:
                              {
                                '2025-01-05': {
                                    '0 1': (['ARIMA', 'RF', 'xgb'], [0.29, 0.33, 0.37]),
                                    ...
                                },
                                ...
                              }
        shift_type (str): Descriptor to include in plot titles.
        plot_type (str): 'line' or 'bar' to control the type of plot.

    Returns:
        None
    """
    # Organize data: { shift_length -> { model -> [(week, weight)] } }
    shift_model_time_series = defaultdict(lambda: defaultdict(list))

    for week, shift_dict in model_weights.items():
        for shift_length, (models, weights) in shift_dict.items():
            for model, weight in zip(models, weights):
                shift_model_time_series[shift_length][model].append((week, weight))

    # Plot for each shift length
    for shift_length, model_data in shift_model_time_series.items():
        plt.figure(figsize=(10, 6))
        sorted_weeks = sorted({week for model in model_data.values() for week, _ in model})
        x = np.arange(len(sorted_weeks))  # positions for bars or x-axis ticks

        if plot_type == 'bar':
            bar_width = 0.2
            offsets = np.linspace(-bar_width, bar_width, len(model_data))

            for offset, (model, week_weight_pairs) in zip(offsets, model_data.items()):
                weeks, weights = zip(*sorted(week_weight_pairs))
                weights_ordered = [dict(week_weight_pairs).get(w, 0) for w in sorted_weeks]
                plt.bar(x + offset, weights_ordered, width=bar_width, label=model)

            plt.xticks(x, sorted_weeks, rotation=45)

        else:  # 'line' plot
            for model, week_weight_pairs in model_data.items():
                weeks, weights = zip(*sorted(week_weight_pairs))
                plt.plot(weeks, weights, marker='o', label=model)

        plt.title(f'Model Weights Over Weeks - Shift ({shift_type}) Length: {shift_length}')
        plt.xlabel('Week')
        plt.ylabel('Weight')
        plt.ylim(0, 1)
        plt.grid(True, linestyle='--', alpha=0.6)
        plt.legend()
        plt.tight_layout()
        plt.show()