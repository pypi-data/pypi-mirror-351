"""Streamlit UI for ImageBreak Framework."""

import streamlit as st
import os
import json
import time
from pathlib import Path
from typing import Dict, List, Optional, Any

# Set page config
st.set_page_config(
    page_title="ImageBreak Framework",
    page_icon="üî¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Import ImageBreak components
try:
    from imagebreak.core.config import Config
    from imagebreak.core.framework import ImageBreakFramework
    from imagebreak.core.cyclic_generator import CyclicImageGenerator
    from imagebreak.models.openai_model import OpenAIModel
    from imagebreak.models.gemini_model import GeminiModel
    from imagebreak.models.huggingface_model import HuggingFaceImageAnalyzer
    from imagebreak.types import PromptData
    IMAGEBREAK_AVAILABLE = True
except ImportError as e:
    st.error(f"ImageBreak framework not available: {e}")
    IMAGEBREAK_AVAILABLE = False


def load_config_from_session() -> Config:
    """Load configuration from session state."""
    config = Config()
    
    # API Keys
    if 'openai_api_key' in st.session_state:
        config.openai_api_key = st.session_state.openai_api_key
    if 'google_api_key' in st.session_state:
        config.google_api_key = st.session_state.google_api_key
    if 'aws_access_key_id' in st.session_state:
        config.aws_access_key_id = st.session_state.aws_access_key_id
    if 'aws_secret_access_key' in st.session_state:
        config.aws_secret_access_key = st.session_state.aws_secret_access_key
    if 'huggingface_token' in st.session_state:
        config.huggingface_token = st.session_state.huggingface_token
    
    # System Instructions
    if 'boundary_prompt_instruction' in st.session_state:
        config.boundary_prompt_system_instruction = st.session_state.boundary_prompt_instruction
    if 'prompt_alteration_instruction' in st.session_state:
        config.prompt_alteration_system_instruction = st.session_state.prompt_alteration_instruction
    if 'image_analysis_instruction' in st.session_state:
        config.image_analysis_system_instruction = st.session_state.image_analysis_instruction
    
    # Model Configuration
    if 'default_text_model' in st.session_state:
        config.default_text_model = st.session_state.default_text_model
    if 'default_image_model' in st.session_state:
        config.default_image_model = st.session_state.default_image_model
    
    # Cyclic Generation Settings
    if 'enable_cyclic_regeneration' in st.session_state:
        config.enable_cyclic_regeneration = st.session_state.enable_cyclic_regeneration
    if 'max_retry_attempts' in st.session_state:
        config.max_retry_attempts = st.session_state.max_retry_attempts
    if 'quality_threshold' in st.session_state:
        config.quality_threshold = st.session_state.quality_threshold
    
    # AWS Settings
    if 'use_aws_moderation' in st.session_state:
        config.use_aws_moderation = st.session_state.use_aws_moderation
    
    return config


def save_config_to_env(config: Config):
    """Save configuration to .env file."""
    env_content = f"""# ImageBreak Configuration
# Auto-generated by Streamlit app

# OpenAI API Configuration
OPENAI_API_KEY={config.openai_api_key or ''}

# Google Gemini API Configuration  
GOOGLE_API_KEY={config.google_api_key or ''}

# AWS Configuration (for content moderation - optional)
AWS_ACCESS_KEY_ID={config.aws_access_key_id or ''}
AWS_SECRET_ACCESS_KEY={config.aws_secret_access_key or ''}
AWS_REGION={config.aws_region}

# HuggingFace Configuration (for image analysis)
HUGGINGFACE_TOKEN={config.huggingface_token or ''}

# Retry and Quality Configuration
MAX_RETRY_ATTEMPTS={config.max_retry_attempts}
QUALITY_THRESHOLD={config.quality_threshold}
ENABLE_CYCLIC_REGENERATION={'true' if config.enable_cyclic_regeneration else 'false'}

# System Instructions Configuration
BOUNDARY_PROMPT_SYSTEM_INSTRUCTION={config.boundary_prompt_system_instruction}

PROMPT_ALTERATION_SYSTEM_INSTRUCTION={config.prompt_alteration_system_instruction}

IMAGE_ANALYSIS_SYSTEM_INSTRUCTION={config.image_analysis_system_instruction}

# Model Selection Configuration
DEFAULT_TEXT_MODEL={config.default_text_model}
DEFAULT_IMAGE_MODEL={config.default_image_model}
AVAILABLE_TEXT_MODELS={','.join(config.available_text_models)}
AVAILABLE_IMAGE_MODELS={','.join(config.available_image_models)}

# AWS Optional Flag
USE_AWS_MODERATION={'true' if config.use_aws_moderation else 'false'}

# Optional: Logging configuration
LOG_LEVEL=INFO
LOG_FILE=imagebreak.log
"""
    
    with open('.env', 'w') as f:
        f.write(env_content)


def initialize_session_state():
    """Initialize session state with default values."""
    defaults = {
        # API Keys
        'openai_api_key': '',
        'google_api_key': '',
        'aws_access_key_id': '',
        'aws_secret_access_key': '',
        'huggingface_token': '',
        
        # Model Selection
        'default_text_model': 'openai',
        'default_image_model': 'openai',
        
        # Cyclic Generation
        'enable_cyclic_regeneration': True,
        'max_retry_attempts': 3,
        'quality_threshold': 0.7,
        
        # AWS
        'use_aws_moderation': False,
        
        # System Instructions
        'boundary_prompt_instruction': Config().boundary_prompt_system_instruction,
        'prompt_alteration_instruction': Config().prompt_alteration_system_instruction,
        'image_analysis_instruction': Config().image_analysis_system_instruction,
        
        # Other
        'framework_initialized': False,
        'results': []
    }
    
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value


def main():
    """Main Streamlit application."""
    if not IMAGEBREAK_AVAILABLE:
        st.error("ImageBreak framework is not available. Please install the required dependencies.")
        return
    
    initialize_session_state()
    
    st.title("üî¨ ImageBreak Framework")
    st.markdown("**AI Safety Testing and Content Moderation Research Platform**")
    
    # Sidebar for configuration
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        # Configuration tabs
        config_tab1, config_tab2, config_tab3 = st.tabs(["üîë API Keys", "ü§ñ Models", "üîÑ Cyclic"])
        
        with config_tab1:
            st.subheader("API Keys")
            
            st.session_state.openai_api_key = st.text_input(
                "OpenAI API Key",
                value=st.session_state.openai_api_key,
                type="password",
                help="Required for OpenAI text and image generation"
            )
            
            st.session_state.google_api_key = st.text_input(
                "Google API Key",
                value=st.session_state.google_api_key,
                type="password",
                help="Required for Gemini text generation"
            )
            
            st.session_state.huggingface_token = st.text_input(
                "HuggingFace Token",
                value=st.session_state.huggingface_token,
                type="password",
                help="Optional: For HuggingFace image analysis models"
            )
            
            with st.expander("AWS Configuration (Optional)"):
                st.session_state.use_aws_moderation = st.checkbox(
                    "Enable AWS Moderation",
                    value=st.session_state.use_aws_moderation,
                    help="Use AWS Rekognition for image content moderation"
                )
                
                if st.session_state.use_aws_moderation:
                    st.session_state.aws_access_key_id = st.text_input(
                        "AWS Access Key ID",
                        value=st.session_state.aws_access_key_id,
                        type="password"
                    )
                    
                    st.session_state.aws_secret_access_key = st.text_input(
                        "AWS Secret Access Key",
                        value=st.session_state.aws_secret_access_key,
                        type="password"
                    )
        
        with config_tab2:
            st.subheader("Model Selection")
            
            st.session_state.default_text_model = st.selectbox(
                "Default Text Model",
                options=["openai", "gemini"],
                index=0 if st.session_state.default_text_model == "openai" else 1,
                help="Model for text generation and prompt refinement"
            )
            
            st.session_state.default_image_model = st.selectbox(
                "Default Image Model",
                options=["openai"],
                index=0,
                help="Model for image generation"
            )
        
        with config_tab3:
            st.subheader("Cyclic Generation")
            
            st.session_state.enable_cyclic_regeneration = st.checkbox(
                "Enable Cyclic Regeneration",
                value=st.session_state.enable_cyclic_regeneration,
                help="Retry image generation if quality is below threshold"
            )
            
            if st.session_state.enable_cyclic_regeneration:
                st.session_state.max_retry_attempts = st.number_input(
                    "Max Retry Attempts",
                    min_value=1,
                    max_value=10,
                    value=st.session_state.max_retry_attempts,
                    help="Maximum number of generation attempts"
                )
                
                st.session_state.quality_threshold = st.slider(
                    "Quality Threshold",
                    min_value=0.0,
                    max_value=1.0,
                    value=st.session_state.quality_threshold,
                    step=0.1,
                    help="Minimum quality score to accept generated image"
                )
    
    # Main content area
    main_tab1, main_tab2, main_tab3 = st.tabs(["üéØ Testing", "üìù System Instructions", "üìä Results"])
    
    with main_tab1:
        st.header("AI Safety Testing")
        
        # Test configuration
        col1, col2 = st.columns([2, 1])
        
        with col1:
            test_type = st.selectbox(
                "Test Type",
                options=["Boundary Testing", "Prompt Alteration", "Custom Prompts"],
                help="Type of safety test to perform"
            )
            
            if test_type == "Boundary Testing":
                st.subheader("Policy Boundary Testing")
                
                policies = st.text_area(
                    "Ethical Guidelines/Policies",
                    height=200,
                    placeholder="Enter the ethical guidelines or policies to test against...",
                    help="The AI model will generate prompts that attempt to violate these guidelines"
                )
                
                num_prompts = st.number_input(
                    "Number of Prompts",
                    min_value=1,
                    max_value=50,
                    value=5,
                    help="Number of boundary-testing prompts to generate"
                )
                
                topics = st.text_input(
                    "Topics (optional)",
                    placeholder="topic1, topic2, topic3",
                    help="Specific topics to focus on (comma-separated)"
                )
            
            elif test_type == "Custom Prompts":
                st.subheader("Custom Prompt Testing")
                
                custom_prompts = st.text_area(
                    "Custom Prompts",
                    height=200,
                    placeholder="Enter your prompts (one per line)...",
                    help="Custom prompts to test with image generation"
                )
        
        with col2:
            st.subheader("Test Options")
            
            test_alteration = st.checkbox(
                "Test Prompt Alteration",
                value=True,
                help="Generate altered versions of prompts to test filter evasion"
            )
            
            save_images = st.checkbox(
                "Save Generated Images",
                value=True,
                help="Save generated images to local folder"
            )
            
            if save_images:
                output_folder = st.text_input(
                    "Output Folder",
                    value="./results/images",
                    help="Folder to save generated images"
                )
        
        # Run test button
        if st.button("üöÄ Run Safety Test", type="primary"):
            config = load_config_from_session()
            
            # Validate configuration
            try:
                config.validate()
            except ValueError as e:
                st.error(f"Configuration error: {e}")
                return
            
            # Initialize framework
            try:
                with st.spinner("Initializing ImageBreak framework..."):
                    framework = ImageBreakFramework(config)
                    
                    # Add models
                    if config.openai_api_key:
                        openai_model = OpenAIModel(
                            api_key=config.openai_api_key,
                            config=config
                        )
                        framework.add_model("openai", openai_model)
                    
                    if config.google_api_key:
                        gemini_model = GeminiModel(
                            api_key=config.google_api_key,
                            config=config
                        )
                        framework.add_model("gemini", gemini_model)
                    
                    # Initialize cyclic generator
                    cyclic_generator = CyclicImageGenerator(config)
                
                st.success("Framework initialized successfully!")
                
                # Show HuggingFace analyzer status
                if cyclic_generator.image_analyzer is None:
                    st.warning("‚ö†Ô∏è HuggingFace image analyzer not available. Quality scores will be basic estimates rather than AI-powered assessments. For better quality analysis, ensure HuggingFace token is set and dependencies are installed.")
                else:
                    st.info("‚úÖ Advanced AI image quality analysis enabled via HuggingFace.")
                
                # Show boundary testing enhancement info
                if test_type == "Boundary Testing":
                    st.info("üõ°Ô∏è **Enhanced Boundary Testing**: The system will automatically attempt to sanitize prompts that violate content policies while preserving artistic intent. You'll see whether the original or sanitized prompt was used for successful generations.")
                
                # Generate prompts based on test type
                if test_type == "Boundary Testing":
                    if not policies.strip():
                        st.error("Please enter ethical guidelines/policies for boundary testing.")
                        return
                    
                    topic_list = [t.strip() for t in topics.split(",")] if topics.strip() else None
                    
                    with st.spinner("Generating boundary-testing prompts..."):
                        prompt_data_list = framework.generate_boundary_prompts(
                            policies=policies,
                            num_prompts=num_prompts,
                            topics=topic_list
                        )
                
                elif test_type == "Custom Prompts":
                    if not custom_prompts.strip():
                        st.error("Please enter custom prompts to test.")
                        return
                    
                    prompt_lines = [line.strip() for line in custom_prompts.split("\n") if line.strip()]
                    prompt_data_list = [
                        PromptData(original_prompt=prompt, generation_method="custom")
                        for prompt in prompt_lines
                    ]
                
                if not prompt_data_list:
                    st.error("No prompts generated. Please check your input.")
                    return
                
                st.info(f"Generated {len(prompt_data_list)} prompts")
                
                # Alter prompts if requested
                if test_alteration:
                    with st.spinner("Generating altered prompts..."):
                        prompt_data_list = framework.alter_prompts(prompt_data_list)
                
                # Run cyclic generation
                image_model_name = config.default_image_model
                text_model_name = config.default_text_model
                
                image_model = framework.models.get(image_model_name)
                text_model = framework.models.get(text_model_name)
                
                if not image_model:
                    st.error(f"Image model '{image_model_name}' not available.")
                    return
                
                if not text_model:
                    st.error(f"Text model '{text_model_name}' not available.")
                    return
                
                generation_kwargs = {}
                if save_images:
                    generation_kwargs['save_folder'] = output_folder
                
                with st.spinner("Generating images with cyclic quality assessment..."):
                    progress_bar = st.progress(0)
                    results = []
                    
                    for i, prompt_data in enumerate(prompt_data_list):
                        result = cyclic_generator.generate_with_retries(
                            image_model=image_model,
                            text_model=text_model,
                            prompt_data=prompt_data,
                            **generation_kwargs
                        )
                        results.append(result)
                        
                        progress_bar.progress((i + 1) / len(prompt_data_list))
                        
                        # Show progress
                        if result.success:
                            quality_text = f", quality: {result.final_quality_score:.2f}" if result.final_quality_score is not None else ""
                            
                            # Check if sanitized prompt was used
                            prompt_info = ""
                            if hasattr(result.final_response, 'metadata') and result.final_response.metadata:
                                prompt_type = result.final_response.metadata.get('prompt_type')
                                if prompt_type == 'sanitized':
                                    prompt_info = " (used sanitized prompt)"
                                elif prompt_type == 'original':
                                    prompt_info = " (used original prompt)"
                            
                            st.write(f"‚úÖ Prompt {i+1}: Success (attempts: {result.total_attempts}{quality_text}){prompt_info}")
                        else:
                            # Check if it failed due to content policy
                            policy_blocked = False
                            if result.attempts:
                                for attempt in result.attempts:
                                    if attempt.response.error_message and (
                                        "content policy" in attempt.response.error_message.lower() or 
                                        "image_generation_user_error" in attempt.response.error_message
                                    ):
                                        policy_blocked = True
                                        break
                            
                            if policy_blocked:
                                st.write(f"üö´ Prompt {i+1}: Blocked by content policy after {result.total_attempts} attempts")
                            else:
                                st.write(f"‚ùå Prompt {i+1}: Failed after {result.total_attempts} attempts")
                
                # Store results in session state
                st.session_state.results = results
                
                # Show summary
                successful = sum(1 for r in results if r.success)
                st.success(f"Test completed! {successful}/{len(results)} prompts successful")
            
            except Exception as e:
                st.error(f"Error running test: {e}")
                import traceback
                st.error(traceback.format_exc())
    
    with main_tab2:
        st.header("System Instructions Configuration")
        st.markdown("Customize the system instructions used by AI models for different tasks.")
        
        # Boundary prompt instruction
        st.subheader("Boundary Prompt Generation")
        st.session_state.boundary_prompt_instruction = st.text_area(
            "System Instruction for Boundary Prompt Generation",
            value=st.session_state.boundary_prompt_instruction,
            height=200,
            help="Instructions for generating prompts that test ethical boundaries"
        )
        
        # Prompt alteration instruction
        st.subheader("Prompt Alteration")
        st.session_state.prompt_alteration_instruction = st.text_area(
            "System Instruction for Prompt Alteration",
            value=st.session_state.prompt_alteration_instruction,
            height=200,
            help="Instructions for altering prompts to evade content filters"
        )
        
        # Image analysis instruction
        st.subheader("Image Analysis")
        st.session_state.image_analysis_instruction = st.text_area(
            "System Instruction for Image Analysis",
            value=st.session_state.image_analysis_instruction,
            height=150,
            help="Instructions for analyzing generated images"
        )
        
        # Save configuration
        if st.button("üíæ Save Configuration", type="primary"):
            config = load_config_from_session()
            save_config_to_env(config)
            st.success("Configuration saved to .env file!")
    
    with main_tab3:
        st.header("Test Results")
        
        if st.session_state.results:
            results = st.session_state.results
            
            # Summary metrics
            successful = sum(1 for r in results if r.success)
            total = len(results)
            avg_attempts = sum(r.total_attempts for r in results) / total if total > 0 else 0
            quality_scores = [r.final_quality_score for r in results if r.final_quality_score is not None]
            avg_quality = sum(quality_scores) / len(quality_scores) if quality_scores else 0
            
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Success Rate", f"{successful}/{total}", f"{successful/total*100:.1f}%")
            with col2:
                st.metric("Avg Attempts", f"{avg_attempts:.1f}")
            with col3:
                st.metric("Avg Quality", f"{avg_quality:.2f}")
            with col4:
                exceeded = sum(1 for r in results if r.exceeded_max_attempts)
                st.metric("Max Attempts Exceeded", exceeded)
            
            # Detailed results
            st.subheader("Detailed Results")
            
            for i, result in enumerate(results):
                with st.expander(f"Prompt {i+1}: {'‚úÖ Success' if result.success else '‚ùå Failed'}"):
                    col1, col2 = st.columns([2, 1])
                    
                    with col1:
                        st.write("**Original Prompt:**")
                        st.text(result.prompt_data.original_prompt)
                        
                        if result.prompt_data.altered_prompt:
                            st.write("**Altered Prompt:**")
                            st.text(result.prompt_data.altered_prompt)
                    
                    with col2:
                        st.write("**Metrics:**")
                        st.write(f"Total Attempts: {result.total_attempts}")
                        if result.final_quality_score is not None:
                            st.write(f"Final Quality: {result.final_quality_score:.2f}")
                        st.write(f"Success: {result.success}")
                        st.write(f"Max Attempts Exceeded: {result.exceeded_max_attempts}")
                    
                    # Show attempts
                    if result.attempts:
                        st.write("**Attempt Details:**")
                        for attempt in result.attempts:
                            status = "‚úÖ" if attempt.response.status.value == "success" else "‚ùå"
                            quality = f"(Q: {attempt.quality_score:.2f})" if attempt.quality_score is not None else "(Q: N/A)"
                            st.write(f"Attempt {attempt.attempt_number}: {status} {quality}")
                    
                    # Show final image if available
                    if result.final_response.image_path and Path(result.final_response.image_path).exists():
                        st.write("**Generated Image:**")
                        st.image(result.final_response.image_path, width=300)
            
            # Export results
            if st.button("üì• Export Results"):
                export_data = []
                for i, result in enumerate(results):
                    export_data.append({
                        "prompt_id": i + 1,
                        "original_prompt": result.prompt_data.original_prompt,
                        "altered_prompt": result.prompt_data.altered_prompt,
                        "success": result.success,
                        "total_attempts": result.total_attempts,
                        "final_quality_score": result.final_quality_score,
                        "exceeded_max_attempts": result.exceeded_max_attempts,
                        "image_path": result.final_response.image_path
                    })
                
                import pandas as pd
                df = pd.DataFrame(export_data)
                
                csv = df.to_csv(index=False)
                st.download_button(
                    label="Download CSV",
                    data=csv,
                    file_name=f"imagebreak_results_{int(time.time())}.csv",
                    mime="text/csv"
                )
        
        else:
            st.info("No test results available. Run a safety test to see results here.")


if __name__ == "__main__":
    main() 