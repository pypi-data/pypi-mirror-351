from typing import List, Optional, Tuple

class SecretKey:
    def __init__(self, seed: bytes) -> None: ...
    def public(self) -> 'PublicKey': ...
    def prove_ietf(self, input_data: bytes, aux: Optional[bytes] = None) -> Tuple[bytes, bytes]: ...
    def prove_pedersen(self, input_data: bytes, aux: Optional[bytes] = None) -> Tuple[bytes, bytes]: ...
    def prove_ring(self, input_data: bytes, ring: List[bytes], aux: Optional[bytes] = None, index: Optional[int] = None) -> Tuple[bytes, bytes]: ...

class PublicKey:
    def verify_ietf(self, input_data: bytes, output: bytes, proof: bytes, aux: Optional[bytes] = None) -> bool: ...
    def verify_pedersen(self, input_data: bytes, output: bytes, proof: bytes, aux: Optional[bytes] = None) -> bool: ...
    def verify_ring(self, input_data: bytes, output: bytes, proof: bytes, ring: List[bytes], aux: Optional[bytes] = None) -> bool: ...
    def get_ring_commitment(self, ring: List[bytes]) -> bytes: ...
    def verify_ring_with_commitment(self, input_data: bytes, output: bytes, proof: bytes, commitment: bytes, aux: Optional[bytes] = None) -> bool: ...
    def to_bytes(self) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes) -> 'PublicKey': ...

class VRFInput:
    def __init__(self, data: bytes) -> None: ...

class VRFProof:
    output: bytes
    def to_bytes(self) -> bytes: ...
    def hash(self) -> bytes: ...

class RingProof:
    output: bytes
    def to_bytes(self) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes, output: bytes) -> 'RingProof': ...

class RingCommitment:
    def to_bytes(self) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes) -> 'RingCommitment': ... 