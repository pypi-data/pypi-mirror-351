# Copyright 2025 Luminary Cloud, Inc. All Rights Reserved.
from typing import Any
from google.protobuf.message import Message as _ProtoMessage


# Gives derived classes the ability to generate the code that would set the values of their members.
# Evidently this is most suited for dataclasses.
# Note that to allow recursion, the lines generated by this class DO NOT contain the name of the
# object being generated, e.g. they will be of the form " = Type()", ".field = val".
# Derived classes can use _to_code_helper to insert an adequate object name.
class CodeRepr:
    def to_code(self, hide_defaults: bool = True) -> str:
        # Returns the code representation of a value with special cases for enums and classes
        # that also implement "to_code" (thus triggering recursion), otherwise uses the default
        # conversion to string.
        def to_string(val: Any) -> str:
            if "<enum " in str(type(val)):
                str_val = val.__repr__()
                return str_val.split(": ")[0][1:]
            try:
                return val.to_code(hide_defaults)
            except:
                return str(val)

        # Returns the code to set the value of a given field of the class.
        def generate(field: str, val: Any) -> str:
            str_val = to_string(val)
            code = ""
            if issubclass(type(val), _ProtoMessage):
                # Special case for protos.
                # TODO(pedro): This is not working 100%.
                code += "# NOTE: Google protobuf types are not fully supported yet.\n"
                code += f".{field} = {type(val).__name__}()\n"
                for line in str_val.split("\n"):
                    if ":" in line:
                        mod_line = line.replace(":", " =")
                        code += f".{field}.{mod_line}\n"
            elif str_val.endswith("\n"):
                # Special case for fields with their own "to_code".
                for line in str_val.split("\n"):
                    if line.startswith("new_") or line.startswith("#"):
                        code += f"{line}\n"
                    elif line.startswith(".new_"):
                        code += f"{line[1:]}\n"
                    elif line:
                        code += f".{field}{line}\n"
            elif isinstance(val, str):
                code += f'.{field} = "{str_val}"\n'
            else:
                code += f".{field} = {str_val}\n"
            return code

        # Returns the code representation of map keys, with special cases for enums and strings.
        def map_key(key: Any) -> str:
            if isinstance(key, str):
                return f'"{key}"'
            if "<enum " in str(type(key)):
                str_key = key.__repr__()
                return str_key.split(": ")[0][1:]
            return str(key)

        # Helper to generate short names for temporary objects that are built and inserted into
        # containers.
        def short_name(field: str) -> str:
            if not "_" in field:
                return field
            return "".join([word[0] for word in field.split("_")])

        # Create the top level object (default constructed), we do some manipulation of module paths
        # (extracted from the type info) to make them consistent with the aliased imports in some
        # __init__ files.
        if "luminarycloud" in str(type(self)):
            path = (
                str(type(self))
                .split("'")[1]
                .replace("luminarycloud.params.simulation", "params")
                .replace("luminarycloud.outputs.output_definitions", "outputs")
            )
            names = path.split(".")
            if names[-2].endswith("_"):
                path = path.replace(names[-2] + ".", "")
            code = f" = {path}()\n"
        else:
            code = f" = {type(self).__name__}()\n"

        default = type(self)()
        for field, val in vars(self).items():
            # Skip default values.
            if hide_defaults and val == vars(default).get(field):
                continue
            field_short_name = short_name(field)
            if isinstance(val, dict):
                code += "# Clear the map and insert new items.\n"
                code += f".{field} = {{}}\n"
                for key, value in val.items():
                    # Simplify the code for maps of built-in types by not creating a temporary
                    # instance.
                    if isinstance(value, (bool, int, float)):
                        code += f".{field}[{map_key(key)}] = {value}\n"
                    elif isinstance(value, str):
                        code += f'.{field}[{map_key(key)}] = "{value}"\n'
                    else:
                        code += f"# Create a new {type(value).__name__} instance and insert it.\n"
                        code += generate(f"new_{field_short_name}", value)
                        code += f".{field}[{map_key(key)}] = new_{field_short_name}\n"
            elif isinstance(val, list):
                # Similar to maps, for classes with more complex representations create temporaries
                # and append, otherwise use the default list representation (which also covers
                # empty lists).
                if len(val) > 0 and to_string(val[0]).endswith("\n"):
                    code += f"# Clear the list of {type(val[0]).__name__} and append new items.\n"
                    code += f".{field} = []\n"
                    for value in val:
                        code += f"# Create a new {type(value).__name__} instance and append it.\n"
                        code += generate(f"new_{field_short_name}", value)
                        code += f".{field}.append(new_{field_short_name})\n"
                else:
                    code += f".{field} = {to_string(val)}\n"
            else:
                code += generate(field, val)
        return code

    # See the class description.
    def _to_code_helper(self, obj_name: str = "obj", hide_defaults: bool = True) -> str:
        code = ""
        for line in CodeRepr.to_code(self, hide_defaults).split("\n"):
            if line:
                if line.startswith(".new_"):
                    code += f"{line[1:]}\n"
                elif line[0] == "." or line.startswith(" = "):
                    code += f"{obj_name}{line}\n"
                else:
                    # Handles comments and temporary objects.
                    code += f"{line}\n"
        return code
