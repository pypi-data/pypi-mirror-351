import copy
from typing import Any, Callable, Optional, Union, cast, List

import jsonc
from pydantic import BaseModel
from .distribution import Distribution, DistributionConfig

__all__ = [
    "MemoryConfigGenerator",
    "MemoryT",
    "StatusAttribute",
]


class StatusAttribute(BaseModel):
    name: str  # the name of the attribute
    type: type  # the type of the attribute
    default: Any  # the default value of the attribute
    description: str  # the description of the attribute
    whether_embedding: bool = False  # whether the attribute is vectorized
    embedding_template: Optional[str] = None  # the template to generate the value


MemoryT = Union[tuple[type, Any], tuple[type, Any, bool], tuple[type, Any, bool, str]]
"""
MemoryT is a tuple of (type, value, use embedding model, embedding template)
- type: the type of the value
- value: the value
- use embedding model (optional): whether the value is generated by embedding model
- embedding template (optional): the template to generate the value
"""


class MemoryConfigGenerator:
    """
    Generate memory configuration.
    """

    def __init__(
        self,
        config_func: Callable[
            [dict[str, Distribution], Optional[list[StatusAttribute]]],
            tuple[dict[str, MemoryT], dict[str, Union[MemoryT, float]], dict[str, Any]],
        ],
        class_config: Optional[list[StatusAttribute]] = None,
        file: Optional[str] = None,
        distributions: dict[str, Union[Distribution, DistributionConfig]] = {},
    ):
        """
        Initialize the memory config generator.

        - **Args**:
            - `config_func` (Callable): The function to generate the memory configuration.
            - `file` (Optional[str]): The path to the file containing the memory configuration.
            - `distributions` (dict[str, Distribution]): The distributions to use for the memory configuration. Default is empty dict.
        """
        self._memory_config_func = config_func
        self._class_config = class_config
        self._file_path = file
        if file is not None:
            self._memory_data = _memory_config_load_file(file)
        else:
            self._memory_data = None
        distributions = copy.deepcopy(distributions)
        # change DistributionConfig to Distribution
        for field, distribution in distributions.items():
            if isinstance(distribution, DistributionConfig):
                distributions[field] = Distribution.from_config(distribution)
        self._distributions = cast(dict[str, Distribution], distributions)

    def merge_distributions(self, distributions: dict[str, Union[Distribution, DistributionConfig]]):
        """
        Merge the distributions for the memory config generator.
        """
        distributions = copy.deepcopy(distributions)
        # change DistributionConfig to Distribution
        for field, distribution in distributions.items():
            if field in self._distributions:
                raise ValueError(f"Distribution {field} is already set")
            else:
                if isinstance(distribution, DistributionConfig):
                    distributions[field] = Distribution.from_config(distribution)
                self._distributions[field] = distributions[field] # type: ignore

    def generate(self, i: int):
        """
        Generate memory configuration.

        Args:
            i (int): The index of the memory configuration to generate. Used to find the i-th memory configuration in the file.

        Returns:
            tuple[dict[str, MemoryT], dict[str, MemoryT], dict[str, Any]]: The memory configuration.
        """
        extra_attrs, profile, base = self._memory_config_func(
            self._distributions, self._class_config
        )
        if self._memory_data is not None:
            if i >= len(self._memory_data):
                raise ValueError(
                    f"Index out of range. Expected index <= {len(self._memory_data)}, got: {i}"
                )
            memory_data = self._memory_data[i]
        else:
            memory_data = {}
        return _memory_config_merge(memory_data, extra_attrs, profile, base)

    def get_agent_data_from_file(self) -> List[dict]:
        """
        Get agent data from file.

        - **Description**:
            - Retrieves the raw agent data from the file specified during initialization.
            - This is used when agents need to be created with IDs from the file.

        - **Returns**:
            - `List[dict]`: A list of agent data dictionaries from the file.

        - **Raises**:
            - `ValueError`: If no file was specified during initialization.
        """
        if self._file_path is None:
            raise ValueError("No file was specified during initialization")

        if self._memory_data is None:
            self._memory_data = _memory_config_load_file(self._file_path)

        return self._memory_data


def _memory_config_load_file(file_path: str):
    """
    Loads the memory configuration from the given file.
    - **Description**:
        - Loads the memory configuration from the given file.
        - Supports both .json and .jsonl file types.
        - For .json files, returns the parsed JSON content.
        - For .jsonl files, returns a list of parsed JSON objects from each line.

    - **Args**:
        - `file_path` (str): The path to the file containing the memory configuration.

    - **Returns**:
        - `memory_data` (Union[dict, list]): The memory data - either a single object or list of objects.

    - **Raises**:
        - `ValueError`: If the file type is not supported.
    """
    with open(file_path, "r") as f:
        data_str = f.read()

    # Check file extension
    if file_path.endswith(".json"):
        memory_data = jsonc.loads(data_str)
        if not isinstance(memory_data, list):
            raise ValueError(
                f"Invalid memory data. Expected a list, got: {memory_data}"
            )
        return memory_data
    elif file_path.endswith(".jsonl"):
        memory_data = []
        for line in data_str.splitlines():
            if line.strip():  # Skip empty lines
                memory_data.append(jsonc.loads(line))
        return memory_data
    else:
        raise ValueError(
            f"Unsupported file type. Only .json or .jsonl files are supported. Got: {file_path}"
        )


def _memory_config_merge(
    file_data: dict,
    base_extra_attrs: dict[str, MemoryT],
    base_profile: dict[str, Union[MemoryT, float]],
    base_base: dict[str, Any],
) -> dict[str, Any]:
    """
    Merges memory configuration from file with base configuration.

    - **Description**:
        - Takes file data and merges it with base configuration components.
        - Special handling for 'home' and 'work' fields which may need to be placed in correct section.

    - **Args**:
        - `file_data` (dict): Memory configuration data loaded from file.
        - `base_extra_attrs` (dict): Base extra attributes configuration.
        - `base_profile` (dict): Base profile configuration.
        - `base_base` (dict): Base memory configuration.

    - **Returns**:
        - `dict`: Merged memory configuration with proper structure.
    """
    # Create copies to avoid modifying the originals
    extra_attrs = base_extra_attrs.copy()
    profile = base_profile.copy()
    base = base_base.copy()

    # Special handling for home and work locations
    location_fields = ["home", "work"]

    for key, value in file_data.items():
        # Check where this key exists in the base configuration
        if key in extra_attrs:
            extra_attrs[key] = value
        elif key in profile:
            profile[key] = value
        elif key in location_fields:
            # Typically these would go in profile, but follow your specific needs
            base[key] = {"aoi_position": {"aoi_id": value}}
        else:
            # For any new fields not in base config, add to extra_attrs
            extra_attrs[key] = value

    return {"extra_attributes": extra_attrs, "profile": profile, "base": base}
