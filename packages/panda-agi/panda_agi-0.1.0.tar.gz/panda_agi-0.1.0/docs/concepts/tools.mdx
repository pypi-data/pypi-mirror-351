---
title: 'Tools'
description: 'Understanding tools and capabilities in PandaAGI SDK'
---

## What are Tools?

Tools are the hands and eyes of your AI agents. They extend agent capabilities beyond text generation, allowing them to interact with the real world through web browsing, file operations, API calls, and more.

<CardGroup cols={3}>
  <Card
    title="Search Tools"
    icon="magnifying-glass"
  >
    Web search, knowledge base queries, and information retrieval
  </Card>
  <Card
    title="Navigation Tools"
    icon="compass"
  >
    Web browsing, page interaction, and content extraction
  </Card>
  <Card
    title="File System Tools"
    icon="folder"
  >
    File operations, code execution, and workspace management
  </Card>
</CardGroup>

## Built-in Tools

### Search Tools

<AccordionGroup>
  <Accordion title="WebSearchTool">
    Performs web searches using various search engines:
    
    ```python
    from panda_agi.tools.search import WebSearchTool
    
    search_tool = WebSearchTool(
        engine="google",  # google, bing, duckduckgo
        max_results=10,
        safe_search=True
    )
    
    agent = Agent(
        name="SearchAgent",
        tools=[search_tool]
    )
    ```
    
    **Capabilities:**
    - Multi-engine search support
    - Result filtering and ranking
    - Safe search options
    - Custom search parameters
  </Accordion>

  <Accordion title="KnowledgeSearchTool">
    Searches internal knowledge bases and documents:
    
    ```python
    from panda_agi.tools.search import KnowledgeSearchTool
    
    kb_tool = KnowledgeSearchTool(
        knowledge_base="company_docs",
        embedding_model="text-embedding-ada-002"
    )
    ```
    
    **Capabilities:**
    - Vector-based semantic search
    - Document indexing
    - Relevance scoring
    - Custom knowledge bases
  </Accordion>
</AccordionGroup>

### Navigation Tools

<AccordionGroup>
  <Accordion title="WebNavigationTool">
    Browses websites and extracts content:
    
    ```python
    from panda_agi.tools.navigation import WebNavigationTool
    
    nav_tool = WebNavigationTool(
        headless=True,
        timeout=30,
        user_agent="PandaAGI/1.0"
    )
    ```
    
    **Capabilities:**
    - Page content extraction
    - Link following
    - Form interaction
    - Screenshot capture
    - JavaScript execution
  </Accordion>

  <Accordion title="APINavigationTool">
    Interacts with REST APIs:
    
    ```python
    from panda_agi.tools.navigation import APINavigationTool
    
    api_tool = APINavigationTool(
        base_url="https://api.example.com",
        auth_token="your-token",
        rate_limit=100
    )
    ```
    
    **Capabilities:**
    - HTTP method support (GET, POST, PUT, DELETE)
    - Authentication handling
    - Rate limiting
    - Response parsing
  </Accordion>
</AccordionGroup>

### File System Tools

<AccordionGroup>
  <Accordion title="FileSystemTool">
    Manages files and directories:
    
    ```python
    from panda_agi.tools.file_system import FileSystemTool
    
    fs_tool = FileSystemTool(
        workspace="/workspace",
        allowed_extensions=[".py", ".txt", ".md"],
        max_file_size="10MB"
    )
    ```
    
    **Capabilities:**
    - File read/write operations
    - Directory management
    - File search and filtering
    - Permission management
    - Size and type restrictions
  </Accordion>

  <Accordion title="CodeExecutionTool">
    Executes code in various languages:
    
    ```python
    from panda_agi.tools.file_system import CodeExecutionTool
    
    code_tool = CodeExecutionTool(
        languages=["python", "javascript", "bash"],
        timeout=30,
        memory_limit="512MB"
    )
    ```
    
    **Capabilities:**
    - Multi-language support
    - Sandboxed execution
    - Output capture
    - Error handling
    - Resource limits
  </Accordion>
</AccordionGroup>

## Tool Configuration

### Basic Configuration

```python
from panda_agi.tools.search import WebSearchTool

# Basic configuration
tool = WebSearchTool()

# Custom configuration
tool = WebSearchTool(
    engine="google",
    max_results=5,
    timeout=10,
    safe_search=True,
    region="US",
    language="en"
)
```

### Advanced Configuration

```python
from panda_agi.tools.navigation import WebNavigationTool

tool = WebNavigationTool(
    # Browser settings
    headless=True,
    user_agent="Custom Agent",
    viewport_size=(1920, 1080),
    
    # Performance settings
    timeout=30,
    page_load_timeout=15,
    
    # Security settings
    disable_images=True,
    disable_javascript=False,
    
    # Proxy settings
    proxy="http://proxy.example.com:8080"
)
```

## Custom Tools

Create your own tools for specific use cases:

### Simple Custom Tool

```python
from panda_agi.tools.base import BaseTool
from typing import Dict, Any

class WeatherTool(BaseTool):
    name = "weather"
    description = "Get current weather information for a location"
    
    def __init__(self, api_key: str):
        self.api_key = api_key
    
    def execute(self, location: str) -> Dict[str, Any]:
        # Implementation here
        response = self._fetch_weather(location)
        return {
            "location": location,
            "temperature": response["temp"],
            "conditions": response["conditions"],
            "humidity": response["humidity"]
        }
    
    def _fetch_weather(self, location: str) -> Dict[str, Any]:
        # API call implementation
        pass
```

### Advanced Custom Tool

```python
from panda_agi.tools.base import BaseTool
from panda_agi.tools.mixins import CacheMixin, RateLimitMixin

class DatabaseTool(BaseTool, CacheMixin, RateLimitMixin):
    name = "database"
    description = "Query database for information"
    
    def __init__(self, connection_string: str):
        super().__init__()
        self.connection_string = connection_string
        self.setup_cache(ttl=300)  # 5 minute cache
        self.setup_rate_limit(max_calls=100, window=3600)  # 100/hour
    
    @cached
    @rate_limited
    def execute(self, query: str) -> Dict[str, Any]:
        # Database query implementation
        results = self._execute_query(query)
        return {
            "query": query,
            "results": results,
            "row_count": len(results)
        }
```

## Tool Composition

Combine multiple tools for complex workflows:

### Sequential Tool Usage

```python
from panda_agi.client import Agent
from panda_agi.tools.search import WebSearchTool
from panda_agi.tools.navigation import WebNavigationTool
from panda_agi.tools.file_system import FileSystemTool

# Research workflow agent
research_agent = Agent(
    name="ResearchAgent",
    description="""
    Research a topic by:
    1. Searching for relevant information
    2. Visiting and analyzing key sources
    3. Saving findings to a report file
    """,
    tools=[
        WebSearchTool(max_results=5),
        WebNavigationTool(),
        FileSystemTool()
    ]
)

# Agent will automatically use tools in sequence
response = research_agent.run("Research the latest developments in quantum computing")
```

### Parallel Tool Usage

```python
from panda_agi.tools.parallel import ParallelToolExecutor

# Execute multiple searches simultaneously
parallel_executor = ParallelToolExecutor([
    WebSearchTool(engine="google"),
    WebSearchTool(engine="bing"),
    WebSearchTool(engine="duckduckgo")
])

agent = Agent(
    name="MultiSearchAgent",
    tools=[parallel_executor]
)
```

## Tool Security

### Sandboxing

Tools run in isolated environments for security:

```python
from panda_agi.tools.file_system import FileSystemTool
from panda_agi.envs import SandboxEnvironment

# Sandboxed file operations
sandbox = SandboxEnvironment(
    allowed_paths=["/workspace"],
    denied_paths=["/etc", "/home"],
    max_disk_usage="1GB"
)

fs_tool = FileSystemTool(environment=sandbox)
```

### Permission Management

```python
from panda_agi.tools.permissions import PermissionManager

# Configure tool permissions
permissions = PermissionManager()
permissions.allow_tool("WebSearchTool", domains=["*.wikipedia.org", "*.github.com"])
permissions.deny_tool("FileSystemTool", paths=["/etc/*", "/home/*"])

agent = Agent(
    name="SecureAgent",
    tools=[WebSearchTool(), FileSystemTool()],
    permissions=permissions
)
```

## Tool Monitoring

### Performance Monitoring

```python
from panda_agi.tools.monitoring import ToolMonitor

monitor = ToolMonitor()

# Monitor tool performance
@monitor.track_performance
def execute_tool(tool, *args, **kwargs):
    return tool.execute(*args, **kwargs)

# View metrics
print(monitor.get_metrics())
# {
#   "WebSearchTool": {
#     "avg_execution_time": 2.3,
#     "success_rate": 0.95,
#     "total_calls": 150
#   }
# }
```

### Error Tracking

```python
from panda_agi.tools.monitoring import ErrorTracker

error_tracker = ErrorTracker()

try:
    result = tool.execute(params)
except Exception as e:
    error_tracker.log_error(tool.name, e, params)
    raise

# Analyze errors
error_report = error_tracker.generate_report()
```

## Best Practices

<AccordionGroup>
  <Accordion title="Tool Selection">
    Choose the right tools for your agent's purpose:
    
    ```python
    # For research agents
    research_tools = [WebSearchTool(), WebNavigationTool()]
    
    # For development agents
    dev_tools = [FileSystemTool(), CodeExecutionTool()]
    
    # For data analysis agents
    analysis_tools = [DatabaseTool(), VisualizationTool()]
    ```
  </Accordion>

  <Accordion title="Resource Management">
    Set appropriate limits to prevent abuse:
    
    ```python
    tool = WebSearchTool(
        max_results=10,        # Limit search results
        timeout=30,           # Prevent hanging
        rate_limit=100        # Calls per hour
    )
    ```
  </Accordion>

  <Accordion title="Error Handling">
    Implement robust error handling:
    
    ```python
    class RobustTool(BaseTool):
        def execute(self, *args, **kwargs):
            try:
                return self._execute(*args, **kwargs)
            except ConnectionError:
                return {"error": "Network connection failed"}
            except TimeoutError:
                return {"error": "Operation timed out"}
            except Exception as e:
                return {"error": f"Unexpected error: {str(e)}"}
    ```
  </Accordion>

  <Accordion title="Caching">
    Use caching for expensive operations:
    
    ```python
    from functools import lru_cache
    
    class CachedTool(BaseTool):
        @lru_cache(maxsize=100)
        def execute(self, query: str):
            # Expensive operation
            return self._expensive_operation(query)
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Events"
    icon="bolt"
    href="/concepts/events"
  >
    Learn about tool event streaming
  </Card>
  <Card
    title="Tool Reference"
    icon="book"
    href="/tools/overview"
  >
    Explore all available tools
  </Card>
</CardGroup> 