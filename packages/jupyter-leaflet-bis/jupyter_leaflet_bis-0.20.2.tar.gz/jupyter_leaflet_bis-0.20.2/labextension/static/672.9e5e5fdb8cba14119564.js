"use strict";
(self["webpackChunkjupyter_leaflet"] = self["webpackChunkjupyter_leaflet"] || []).push([[672],{

/***/ 433:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<?xml version=\"1.0\" encoding=\"UTF-8\"?>%0A<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">%0A    <%21-- Generator: Sketch 52.5 %2867469%29 - http://www.bohemiancoding.com/sketch -->%0A    <title>Atoms/Icons/Tools/Circle</title>%0A    <desc>Created with Sketch.</desc>%0A    <defs>%0A        <path d=\"M18.2897751,6.78602275 C18.8924131,6.29464981 19.661797,6 20.5,6 C22.4329966,6 24,7.56700338 24,9.5 C24,10.338203 23.7053502,11.1075869 23.2139772,11.7102249 C23.719599,12.8712053 24,14.1528571 24,15.5 C24,20.7467051 19.7467051,25 14.5,25 C9.25329488,25 5,20.7467051 5,15.5 C5,10.2532949 9.25329488,6 14.5,6 C15.8471429,6 17.1287947,6.28040098 18.2897751,6.78602275 Z M17.1504228,8.4817586 C16.3263581,8.17039236 15.4330777,8 14.5,8 C10.3578644,8 7,11.3578644 7,15.5 C7,19.6421356 10.3578644,23 14.5,23 C18.6421356,23 22,19.6421356 22,15.5 C22,14.5669223 21.8296076,13.6736419 21.5182414,12.8495772 C21.1960383,12.9473968 20.8541622,13 20.5,13 C18.5670034,13 17,11.4329966 17,9.5 C17,9.14583778 17.0526032,8.80396169 17.1504228,8.4817586 Z M14.5,17 C13.6715729,17 13,16.3284271 13,15.5 C13,14.6715729 13.6715729,14 14.5,14 C15.3284271,14 16,14.6715729 16,15.5 C16,16.3284271 15.3284271,17 14.5,17 Z M20.5,11 C21.3284271,11 22,10.3284271 22,9.5 C22,8.67157288 21.3284271,8 20.5,8 C19.6715729,8 19,8.67157288 19,9.5 C19,10.3284271 19.6715729,11 20.5,11 Z\" id=\"path-1\"></path>%0A    </defs>%0A    <g id=\"Symbols\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">%0A        <g id=\"Atoms/Icons/Tools/Circle\" transform=\"translate%28-3.000000, -3.000000%29\">%0A            <mask id=\"mask-2\" fill=\"white\">%0A                <use xlink:href=\"%23path-1\"></use>%0A            </mask>%0A            <use id=\"Mask\" fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23path-1\"></use>%0A            <g id=\"Atoms/Color/Grey\" mask=\"url%28%23mask-2%29\" fill=\"%235B5B5B\">%0A                <rect id=\"Rectangle\" x=\"0\" y=\"0\" width=\"30\" height=\"30\"></rect>%0A            </g>%0A        </g>%0A    </g>%0A</svg>";

/***/ }),

/***/ 1226:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><defs><style>.cls-1{fill:none;stroke:%235b5b5b;stroke-linecap:round;stroke-linejoin:round;stroke-width:2.5px;}</style></defs><title>Text</title><g id=\"Ebene_2\" data-name=\"Ebene 2\"><polyline class=\"cls-1\" points=\"19.64 7.27 19.64 4 12 4 12 20 15.91 20 8.09 20 12 20 12 4 4.36 4 4.36 7.27\"/></g></svg>";

/***/ }),

/***/ 1425:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<?xml version=\"1.0\" encoding=\"UTF-8\"?>%0A<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">%0A    <%21-- Generator: Sketch 52.5 %2867469%29 - http://www.bohemiancoding.com/sketch -->%0A    <title>Atoms/Icons/Tools/Eraser</title>%0A    <desc>Created with Sketch.</desc>%0A    <defs>%0A        <path d=\"M17.7874219,18.4812552 L11.6480079,13.3498184 L6.40466009,19.3816001 L10.5539156,22.9884929 L13.86934,22.9884929 L17.7874219,18.4812552 Z M16.5074252,22.9884929 L26.0000002,22.9884929 L26.0000002,24.9884929 L10.0000002,24.9884929 L9.80708313,24.9884929 L5.09254204,20.8910192 C4.25891285,20.1663564 4.17057814,18.9031112 4.89524093,18.069482 L16.0482444,5.23941916 C16.7729072,4.40578998 18.0361525,4.31745526 18.8697816,5.04211806 L24.9074583,10.2905903 C25.7410875,11.0152531 25.8294222,12.2784983 25.1047594,13.1121275 L16.5074252,22.9884929 Z\" id=\"path-1\"></path>%0A    </defs>%0A    <g id=\"Symbols\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">%0A        <g id=\"Atoms/Icons/Tools/Eraser\" transform=\"translate%28-3.000000, -3.000000%29\">%0A            <mask id=\"mask-2\" fill=\"white\">%0A                <use xlink:href=\"%23path-1\"></use>%0A            </mask>%0A            <use id=\"Combined-Shape\" fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23path-1\"></use>%0A        </g>%0A    </g>%0A</svg>";

/***/ }),

/***/ 1588:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<?xml version=\"1.0\" encoding=\"UTF-8\"?>%0A<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">%0A    <%21-- Generator: Sketch 52.5 %2867469%29 - http://www.bohemiancoding.com/sketch -->%0A    <title>Atoms/Icons/Tools/Scissors</title>%0A    <desc>Created with Sketch.</desc>%0A    <defs>%0A        <path d=\"M12.9691574,13.4939435 L21.0317032,5.54167013 L23.4649499,5.67722957 L17.0470713,14.5106816 L27.5660336,17.1333535 L25.7891944,18.8012588 L14.5854951,17.8987506 L13.6487955,19.188007 C13.794639,19.2650958 13.9367985,19.3534417 14.0741377,19.4532245 C15.6379648,20.5894114 15.9846357,22.7782052 14.8484488,24.3420324 C13.7122619,25.9058595 11.5234681,26.2525304 9.95964096,25.1163435 C8.39581384,23.9801565 8.04914296,21.7913627 9.18532986,20.2275356 C9.74587276,19.4560145 10.5626188,18.9807475 11.4341218,18.8336407 L12.6805656,17.1180579 L12.5239724,16.3747216 L11.9506932,15.3012391 L9.89310646,14.7882251 C9.13093796,15.2357261 8.19977854,15.3966447 7.27445355,15.1659352 C5.39887519,14.698301 4.25751094,12.7987519 4.72514515,10.9231736 C5.19277935,9.04759519 7.09232846,7.90623094 8.96790682,8.37386515 C10.8434852,8.84149935 11.9848494,10.7410485 11.5172152,12.6166268 C11.4761464,12.7813449 11.4240335,12.9404001 11.3618627,13.0931999 L12.9691574,13.4939435 Z M7.75829735,13.2253438 C8.56211664,13.4257584 9.37620912,12.9366023 9.57662378,12.132783 C9.77703844,11.3289637 9.28788233,10.5148713 8.48406303,10.3144566 C7.68024373,10.1140419 6.86615126,10.603198 6.6657366,11.4070173 C6.46532194,12.2108366 6.95447805,13.0249291 7.75829735,13.2253438 Z M10.8033639,21.4031061 C10.3164266,22.0733177 10.4649998,23.0113722 11.1352115,23.4983095 C11.8054231,23.9852467 12.7434776,23.8366735 13.2304148,23.1664619 C13.7173521,22.4962502 13.5687788,21.5581957 12.8985672,21.0712585 C12.2283556,20.5843212 11.2903011,20.7328945 10.8033639,21.4031061 Z\" id=\"path-1\"></path>%0A    </defs>%0A    <g id=\"Symbols\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">%0A        <g id=\"Atoms/Icons/Tools/Scissors\" transform=\"translate%28-3.000000, -3.000000%29\">%0A            <mask id=\"mask-2\" fill=\"white\">%0A                <use xlink:href=\"%23path-1\"></use>%0A            </mask>%0A            <use id=\"Mask\" fill=\"%235B5B5B\" fill-rule=\"nonzero\" transform=\"translate%2816.093194, 15.663351%29 rotate%28-32.000000%29 translate%28-16.093194, -15.663351%29 \" xlink:href=\"%23path-1\"></use>%0A        </g>%0A    </g>%0A</svg>";

/***/ }),

/***/ 1999:
/***/ ((module) => {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC";

/***/ }),

/***/ 2299:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">%0A  <defs>%0A    <path id=\"move-a\" d=\"M21,14 L21,10 L27,15 L21,20 L21,16 L16,16 L16,21 L20,21 L15,27 L10,21 L14,21 L14,16 L9,16 L9,20 L3,15 L9,10 L9,14 L14,14 L14,9 L10,9 L15,3 L20,9 L16,9 L16,14 L21,14 Z\"/>%0A  </defs>%0A  <g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate%28-3 -3%29\">%0A    <mask id=\"move-b\" fill=\"%23fff\">%0A      <use xlink:href=\"%23move-a\"/>%0A    </mask>%0A    <use fill=\"%23D8D8D8\" xlink:href=\"%23move-a\"/>%0A    <g fill=\"%235B5B5B\" mask=\"url%28%23move-b%29\">%0A      <rect width=\"30\" height=\"30\"/>%0A    </g>%0A  </g>%0A</svg>%0A";

/***/ }),

/***/ 2964:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<?xml version=\"1.0\" encoding=\"UTF-8\"?>%0A%0A<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" stroke=\"%235B5B5B\" stroke-width=\"8\"%0A     fill=\"none\">%0A<circle cx=\"50\" cy=\"50\" r=\"35\"/>%0A  <circle cx=\"50\" cy=\"50\" r=\"3\" fill=\"%235B5B5B\"/>%0A</svg>";

/***/ }),

/***/ 3427:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<?xml version=\"1.0\" encoding=\"UTF-8\"?>%0A<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">%0A    <%21-- Generator: Sketch 57.1 %2883088%29 - https://sketch.com -->%0A    <title>Atoms/Icons/Tools/Magnet</title>%0A    <desc>Created with Sketch.</desc>%0A    <defs>%0A        <path d=\"M21.9994759,10.9428183 L21.9999985,16.3710417 C22,16.6872007 22,17.0058278 22,17.3269411 C22,21.5646545 18.6421356,25 14.5,25 C10.3578644,25 7,21.5646545 7,17.3269411 L7.00087508,10.9907507 L11.0022808,10.9984125 C11.0017033,11.6980114 11.001247,12.4168248 11.0008992,13.1554887 L11,17.3269411 C11,19.3756809 12.5876841,21 14.5,21 C16.4123159,21 18,19.3756809 18,17.3269411 C18,15.0702032 17.9995696,12.9619668 17.998539,10.9910032 L21.9994759,10.9428183 Z M10,7 C10.5522847,7 11,7.44771525 11,8 L11,10 L7,10 L7,8 C7,7.44771525 7.44771525,7 8,7 L10,7 Z M21,7 C21.5522847,7 22,7.44771525 22,8 L22,10 L18,10 L18,8 C18,7.44771525 18.4477153,7 19,7 L21,7 Z\" id=\"path-1\"></path>%0A    </defs>%0A    <g id=\"Symbols\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">%0A        <g id=\"Atoms/Icons/Tools/Magnet\" transform=\"translate%28-3.000000, -3.000000%29\">%0A            <mask id=\"mask-2\" fill=\"white\">%0A                <use xlink:href=\"%23path-1\"></use>%0A            </mask>%0A            <use id=\"Mask\" fill=\"%235B5B5B\" fill-rule=\"nonzero\" transform=\"translate%2814.500000, 16.000000%29 rotate%2845.000000%29 translate%28-14.500000, -16.000000%29 \" xlink:href=\"%23path-1\"></use>%0A        </g>%0A    </g>%0A</svg>";

/***/ }),

/***/ 3553:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  LeafletAntPathModel: () => (/* reexport */ LeafletAntPathModel),
  LeafletAntPathView: () => (/* reexport */ LeafletAntPathView),
  LeafletAttributionControlModel: () => (/* reexport */ LeafletAttributionControlModel),
  LeafletAttributionControlView: () => (/* reexport */ LeafletAttributionControlView),
  LeafletAwesomeIconModel: () => (/* reexport */ LeafletAwesomeIconModel),
  LeafletAwesomeIconView: () => (/* reexport */ LeafletAwesomeIconView),
  LeafletCircleMarkerModel: () => (/* reexport */ LeafletCircleMarkerModel),
  LeafletCircleMarkerView: () => (/* reexport */ LeafletCircleMarkerView),
  LeafletCircleModel: () => (/* reexport */ LeafletCircleModel),
  LeafletCircleView: () => (/* reexport */ LeafletCircleView),
  LeafletControlModel: () => (/* reexport */ LeafletControlModel),
  LeafletControlView: () => (/* reexport */ LeafletControlView),
  LeafletDivIconModel: () => (/* reexport */ LeafletDivIconModel),
  LeafletDivIconView: () => (/* reexport */ LeafletDivIconView),
  LeafletDrawControlModel: () => (/* reexport */ LeafletDrawControlModel),
  LeafletDrawControlView: () => (/* reexport */ LeafletDrawControlView),
  LeafletFeatureGroupModel: () => (/* reexport */ LeafletFeatureGroupModel),
  LeafletFeatureGroupView: () => (/* reexport */ LeafletFeatureGroupView),
  LeafletFullScreenControlModel: () => (/* reexport */ LeafletFullScreenControlModel),
  LeafletFullScreenControlView: () => (/* reexport */ LeafletFullScreenControlView),
  LeafletGeoJSONModel: () => (/* reexport */ LeafletGeoJSONModel),
  LeafletGeoJSONView: () => (/* reexport */ LeafletGeoJSONView),
  LeafletGeomanDrawControlModel: () => (/* reexport */ LeafletGeomanDrawControlModel),
  LeafletGeomanDrawControlView: () => (/* reexport */ LeafletGeomanDrawControlView),
  LeafletHeatmapModel: () => (/* reexport */ LeafletHeatmapModel),
  LeafletHeatmapView: () => (/* reexport */ LeafletHeatmapView),
  LeafletIconModel: () => (/* reexport */ LeafletIconModel),
  LeafletIconView: () => (/* reexport */ LeafletIconView),
  LeafletImageOverlayModel: () => (/* reexport */ LeafletImageOverlayModel),
  LeafletImageOverlayView: () => (/* reexport */ LeafletImageOverlayView),
  LeafletImageServiceModel: () => (/* reexport */ LeafletImageServiceModel),
  LeafletImageServiceView: () => (/* reexport */ LeafletImageServiceView),
  LeafletLayerGroupModel: () => (/* reexport */ LeafletLayerGroupModel),
  LeafletLayerGroupView: () => (/* reexport */ LeafletLayerGroupView),
  LeafletLayerModel: () => (/* reexport */ LeafletLayerModel),
  LeafletLayerView: () => (/* reexport */ LeafletLayerView),
  LeafletLayersControlModel: () => (/* reexport */ LeafletLayersControlModel),
  LeafletLayersControlView: () => (/* reexport */ LeafletLayersControlView),
  LeafletLegendControlModel: () => (/* reexport */ LeafletLegendControlModel),
  LeafletLegendControlView: () => (/* reexport */ LeafletLegendControlView),
  LeafletLocalTileLayerModel: () => (/* reexport */ LeafletLocalTileLayerModel),
  LeafletLocalTileLayerView: () => (/* reexport */ LeafletLocalTileLayerView),
  LeafletMagnifyingGlassModel: () => (/* reexport */ LeafletMagnifyingGlassModel),
  LeafletMagnifyingGlassView: () => (/* reexport */ LeafletMagnifyingGlassView),
  LeafletMapModel: () => (/* reexport */ LeafletMapModel),
  LeafletMapStyleModel: () => (/* reexport */ LeafletMapStyleModel),
  LeafletMapView: () => (/* reexport */ LeafletMapView),
  LeafletMarkerClusterModel: () => (/* reexport */ LeafletMarkerClusterModel),
  LeafletMarkerClusterView: () => (/* reexport */ LeafletMarkerClusterView),
  LeafletMarkerModel: () => (/* reexport */ LeafletMarkerModel),
  LeafletMarkerView: () => (/* reexport */ LeafletMarkerView),
  LeafletMeasureControlModel: () => (/* reexport */ LeafletMeasureControlModel),
  LeafletMeasureControlView: () => (/* reexport */ LeafletMeasureControlView),
  LeafletPMTilesLayerModel: () => (/* reexport */ LeafletPMTilesLayerModel),
  LeafletPMTilesLayerView: () => (/* reexport */ LeafletPMTilesLayerView),
  LeafletPathModel: () => (/* reexport */ LeafletPathModel),
  LeafletPathView: () => (/* reexport */ LeafletPathView),
  LeafletPolygonModel: () => (/* reexport */ LeafletPolygonModel),
  LeafletPolygonView: () => (/* reexport */ LeafletPolygonView),
  LeafletPolylineModel: () => (/* reexport */ LeafletPolylineModel),
  LeafletPolylineView: () => (/* reexport */ LeafletPolylineView),
  LeafletPopupModel: () => (/* reexport */ LeafletPopupModel),
  LeafletPopupView: () => (/* reexport */ LeafletPopupView),
  LeafletRasterLayerModel: () => (/* reexport */ LeafletRasterLayerModel),
  LeafletRasterLayerView: () => (/* reexport */ LeafletRasterLayerView),
  LeafletRectangleModel: () => (/* reexport */ LeafletRectangleModel),
  LeafletRectangleView: () => (/* reexport */ LeafletRectangleView),
  LeafletScaleControlModel: () => (/* reexport */ LeafletScaleControlModel),
  LeafletScaleControlView: () => (/* reexport */ LeafletScaleControlView),
  LeafletSearchControlModel: () => (/* reexport */ LeafletSearchControlModel),
  LeafletSearchControlView: () => (/* reexport */ LeafletSearchControlView),
  LeafletSplitMapControlModel: () => (/* reexport */ LeafletSplitMapControlModel),
  LeafletSplitMapControlView: () => (/* reexport */ LeafletSplitMapControlView),
  LeafletTileLayerModel: () => (/* reexport */ LeafletTileLayerModel),
  LeafletTileLayerView: () => (/* reexport */ LeafletTileLayerView),
  LeafletUILayerModel: () => (/* reexport */ LeafletUILayerModel),
  LeafletUILayerView: () => (/* reexport */ LeafletUILayerView),
  LeafletVectorLayerModel: () => (/* reexport */ LeafletVectorLayerModel),
  LeafletVectorLayerView: () => (/* reexport */ LeafletVectorLayerView),
  LeafletVectorTileLayerModel: () => (/* reexport */ LeafletVectorTileLayerModel),
  LeafletVectorTileLayerView: () => (/* reexport */ LeafletVectorTileLayerView),
  LeafletVelocityModel: () => (/* reexport */ LeafletVelocityModel),
  LeafletVelocityView: () => (/* reexport */ LeafletVelocityView),
  LeafletVideoOverlayModel: () => (/* reexport */ LeafletVideoOverlayModel),
  LeafletVideoOverlayView: () => (/* reexport */ LeafletVideoOverlayView),
  LeafletWMSLayerModel: () => (/* reexport */ LeafletWMSLayerModel),
  LeafletWMSLayerView: () => (/* reexport */ LeafletWMSLayerView),
  LeafletWidgetControlModel: () => (/* reexport */ LeafletWidgetControlModel),
  LeafletWidgetControlView: () => (/* reexport */ LeafletWidgetControlView),
  LeafletZoomControlModel: () => (/* reexport */ LeafletZoomControlModel),
  LeafletZoomControlView: () => (/* reexport */ LeafletZoomControlView),
  version: () => (/* binding */ version)
});

// EXTERNAL MODULE: ./package.json
var package_0 = __webpack_require__(8330);
// EXTERNAL MODULE: consume shared module (default) leaflet-ant-path@^1.3.0 (strict) (fallback: ./node_modules/leaflet-ant-path/dist/leaflet-ant-path.js)
var leaflet_ant_path_js_ = __webpack_require__(4051);
// EXTERNAL MODULE: consume shared module (default) leaflet@^1.9.4 (singleton) (fallback: ./node_modules/leaflet/dist/leaflet-src.js)
var leaflet_src_js_ = __webpack_require__(4800);
var leaflet_src_js_default = /*#__PURE__*/__webpack_require__.n(leaflet_src_js_);
// EXTERNAL MODULE: consume shared module (default) leaflet-defaulticon-compatibility@~0.1.1 (strict) (fallback: ./node_modules/leaflet-defaulticon-compatibility/src/Icon.Default.compatibility.js)
var Icon_Default_compatibility_js_ = __webpack_require__(6842);
// EXTERNAL MODULE: consume shared module (default) leaflet-draw@^1.0.4 (strict) (fallback: ./node_modules/leaflet-draw/dist/leaflet.draw.js)
var leaflet_draw_js_ = __webpack_require__(2276);
// EXTERNAL MODULE: consume shared module (default) leaflet-fullscreen@^1.0.2 (strict) (fallback: ./node_modules/leaflet-fullscreen/dist/Leaflet.fullscreen.js)
var Leaflet_fullscreen_js_ = __webpack_require__(4609);
// EXTERNAL MODULE: consume shared module (default) leaflet-measure@^3.1.0 (strict) (fallback: ./node_modules/leaflet-measure/dist/leaflet-measure.js)
var leaflet_measure_js_ = __webpack_require__(4234);
// EXTERNAL MODULE: consume shared module (default) leaflet-rotatedmarker@~0.2.0 (strict) (fallback: ./node_modules/leaflet-rotatedmarker/leaflet.rotatedMarker.js)
var leaflet_rotatedMarker_js_ = __webpack_require__(7315);
// EXTERNAL MODULE: consume shared module (default) leaflet-search@=2.9.8 (strict) (fallback: ./node_modules/leaflet-search/dist/leaflet-search.src.js)
var leaflet_search_src_js_ = __webpack_require__(2176);
// EXTERNAL MODULE: consume shared module (default) leaflet-splitmap@^1.0.3 (strict) (fallback: ./node_modules/leaflet-splitmap/src/index.js)
var index_js_ = __webpack_require__(4176);
// EXTERNAL MODULE: consume shared module (default) leaflet-transform@^1.0.3 (strict) (fallback: ./node_modules/leaflet-transform/src/index.js)
var src_index_js_ = __webpack_require__(8960);
// EXTERNAL MODULE: consume shared module (default) leaflet-velocity@^1.2.4 (strict) (fallback: ./node_modules/leaflet-velocity/dist/leaflet-velocity.js)
var leaflet_velocity_js_ = __webpack_require__(4062);
// EXTERNAL MODULE: consume shared module (default) leaflet.awesome-markers@^2.0.5 (strict) (fallback: ./node_modules/leaflet.awesome-markers/dist/leaflet.awesome-markers.js)
var leaflet_awesome_markers_js_ = __webpack_require__(2389);
// EXTERNAL MODULE: consume shared module (default) leaflet.markercluster@^1.2.0 (strict) (fallback: ./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js)
var leaflet_markercluster_src_js_ = __webpack_require__(9181);
// EXTERNAL MODULE: consume shared module (default) leaflet.vectorgrid@^1.3.0 (strict) (fallback: ./node_modules/leaflet.vectorgrid/dist/Leaflet.VectorGrid.bundled.min.js)
var Leaflet_VectorGrid_bundled_min_js_ = __webpack_require__(1698);
// EXTERNAL MODULE: consume shared module (default) proj4@^2.6.0 (strict) (fallback: ./node_modules/proj4/lib/index.js)
var lib_index_js_ = __webpack_require__(7729);
// EXTERNAL MODULE: consume shared module (default) proj4leaflet@^1.0.1 (strict) (fallback: ./node_modules/proj4leaflet/src/proj4leaflet.js)
var proj4leaflet_js_ = __webpack_require__(5354);
// EXTERNAL MODULE: consume shared module (default) protomaps-leaflet@^1.24.0 (strict) (fallback: ./node_modules/protomaps-leaflet/dist/protomaps-leaflet.module.js)
var protomaps_leaflet_module_js_ = __webpack_require__(2730);
;// ./lib/leaflet-heat.js
// The code below was copied from the following sources:
// https://github.com/Leaflet/Leaflet.heat/blob/gh-pages/src/HeatLayer.js
// https://github.com/mourner/simpleheat/blob/gh-pages/simpleheat.js
//
// Copyright (c) 2015, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice, this list of
//       conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice, this list
//       of conditions and the following disclaimer in the documentation and/or other materials
//       provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
// TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// @ts-nocheck

function simpleheat(canvas) {
    if (!(this instanceof simpleheat))
        return new simpleheat(canvas);
    this._canvas = canvas =
        typeof canvas === 'string' ? document.getElementById(canvas) : canvas;
    this._ctx = canvas.getContext('2d');
    this._width = canvas.width;
    this._height = canvas.height;
    this._max = 1;
    this._data = [];
}
simpleheat.prototype = {
    defaultRadius: 25,
    defaultGradient: {
        0.4: 'blue',
        0.6: 'cyan',
        0.7: 'lime',
        0.8: 'yellow',
        1.0: 'red',
    },
    data: function (data) {
        this._data = data;
        return this;
    },
    max: function (max) {
        this._max = max;
        return this;
    },
    add: function (point) {
        this._data.push(point);
        return this;
    },
    clear: function () {
        this._data = [];
        return this;
    },
    radius: function (r, blur) {
        blur = blur === undefined ? 15 : blur;
        // create a grayscale blurred circle image that we'll use for drawing points
        var circle = (this._circle = this._createCanvas()), ctx = circle.getContext('2d'), r2 = (this._r = r + blur);
        circle.width = circle.height = r2 * 2;
        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
        ctx.shadowBlur = blur;
        ctx.shadowColor = 'black';
        ctx.beginPath();
        ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
        return this;
    },
    resize: function () {
        this._width = this._canvas.width;
        this._height = this._canvas.height;
    },
    gradient: function (grad) {
        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
        var canvas = this._createCanvas(), ctx = canvas.getContext('2d'), gradient = ctx.createLinearGradient(0, 0, 0, 256);
        canvas.width = 1;
        canvas.height = 256;
        for (var i in grad) {
            gradient.addColorStop(+i, grad[i]);
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1, 256);
        this._grad = ctx.getImageData(0, 0, 1, 256).data;
        return this;
    },
    draw: function (minOpacity) {
        if (!this._circle)
            this.radius(this.defaultRadius);
        if (!this._grad)
            this.gradient(this.defaultGradient);
        var ctx = this._ctx;
        ctx.clearRect(0, 0, this._width, this._height);
        // draw a grayscale heatmap by putting a blurred circle at each data point
        for (var i = 0, len = this._data.length, p; i < len; i++) {
            p = this._data[i];
            ctx.globalAlpha = Math.min(Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity), 1);
            ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);
        }
        // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient
        var colored = ctx.getImageData(0, 0, this._width, this._height);
        this._colorize(colored.data, this._grad);
        ctx.putImageData(colored, 0, 0);
        return this;
    },
    _colorize: function (pixels, gradient) {
        for (var i = 0, len = pixels.length, j; i < len; i += 4) {
            j = pixels[i + 3] * 4; // get gradient color from opacity value
            if (j) {
                pixels[i] = gradient[j];
                pixels[i + 1] = gradient[j + 1];
                pixels[i + 2] = gradient[j + 2];
            }
        }
    },
    _createCanvas: function () {
        if (typeof document !== 'undefined') {
            return document.createElement('canvas');
        }
        else {
            // create a new canvas instance in node.js
            // the canvas class needs to have a default constructor without any parameter
            return new this._canvas.constructor();
        }
    },
};
L.HeatLayer = (L.Layer ? L.Layer : L.Class).extend({
    options: {
        minOpacity: 0.05,
        maxZoom: 18,
        radius: 25,
        blur: 15,
        max: 1.0,
    },
    initialize: function (latlngs, options) {
        this._latlngs = latlngs;
        L.setOptions(this, options);
    },
    setLatLngs: function (latlngs) {
        this._latlngs = latlngs;
        return this.redraw();
    },
    addLatLng: function (latlng) {
        this._latlngs.push(latlng);
        return this.redraw();
    },
    setOptions: function (options) {
        L.setOptions(this, options);
        if (this._heat) {
            this._updateOptions();
        }
        return this.redraw();
    },
    redraw: function () {
        if (this._heat && !this._frame && this._map && !this._map._animating) {
            this._frame = L.Util.requestAnimFrame(this._redraw, this);
        }
        return this;
    },
    onAdd: function (map) {
        this._map = map;
        if (!this._canvas) {
            this._initCanvas();
        }
        if (this.options.pane) {
            this.getPane().appendChild(this._canvas);
        }
        else {
            map._panes.overlayPane.appendChild(this._canvas);
        }
        map.on('moveend', this._reset, this);
        if (map.options.zoomAnimation && L.Browser.any3d) {
            map.on('zoomanim', this._animateZoom, this);
        }
        this._reset();
    },
    onRemove: function (map) {
        if (this.options.pane) {
            this.getPane().removeChild(this._canvas);
        }
        else {
            map.getPanes().overlayPane.removeChild(this._canvas);
        }
        map.off('moveend', this._reset, this);
        if (map.options.zoomAnimation) {
            map.off('zoomanim', this._animateZoom, this);
        }
    },
    addTo: function (map) {
        map.addLayer(this);
        return this;
    },
    _initCanvas: function () {
        var canvas = (this._canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer leaflet-layer'));
        var originProp = L.DomUtil.testProp([
            'transformOrigin',
            'WebkitTransformOrigin',
            'msTransformOrigin',
        ]);
        canvas.style[originProp] = '50% 50%';
        var size = this._map.getSize();
        canvas.width = size.x;
        canvas.height = size.y;
        var animated = this._map.options.zoomAnimation && L.Browser.any3d;
        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
        this._heat = simpleheat(canvas);
        this._updateOptions();
    },
    _updateOptions: function () {
        this._heat.radius(this.options.radius || this._heat.defaultRadius, this.options.blur);
        if (this.options.gradient) {
            this._heat.gradient(this.options.gradient);
        }
        if (this.options.max) {
            this._heat.max(this.options.max);
        }
    },
    _reset: function () {
        var topLeft = this._map.containerPointToLayerPoint([0, 0]);
        L.DomUtil.setPosition(this._canvas, topLeft);
        var size = this._map.getSize();
        if (this._heat._width !== size.x) {
            this._canvas.width = this._heat._width = size.x;
        }
        if (this._heat._height !== size.y) {
            this._canvas.height = this._heat._height = size.y;
        }
        this._redraw();
    },
    _redraw: function () {
        if (!this._map) {
            return;
        }
        var data = [], r = this._heat._r, size = this._map.getSize(), bounds = new L.Bounds(L.point([-r, -r]), size.add([r, r])), max = this.options.max === undefined ? 1 : this.options.max, maxZoom = this.options.maxZoom === undefined
            ? this._map.getMaxZoom()
            : this.options.maxZoom, v = 1 /
            Math.pow(2, Math.max(0, Math.min(maxZoom - this._map.getZoom(), 12))), cellSize = r / 2, grid = [], panePos = this._map._getMapPanePos(), offsetX = panePos.x % cellSize, offsetY = panePos.y % cellSize, i, len, p, cell, x, y, j, len2, k;
        // console.time('process');
        for (i = 0, len = this._latlngs.length; i < len; i++) {
            p = this._map.latLngToContainerPoint(this._latlngs[i]);
            if (bounds.contains(p)) {
                x = Math.floor((p.x - offsetX) / cellSize) + 2;
                y = Math.floor((p.y - offsetY) / cellSize) + 2;
                var alt = this._latlngs[i].alt !== undefined
                    ? this._latlngs[i].alt
                    : this._latlngs[i][2] !== undefined
                        ? +this._latlngs[i][2]
                        : 1;
                k = alt * v;
                grid[y] = grid[y] || [];
                cell = grid[y][x];
                if (!cell) {
                    grid[y][x] = [p.x, p.y, k];
                }
                else {
                    cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x
                    cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y
                    cell[2] += k; // cumulated intensity value
                }
            }
        }
        for (i = 0, len = grid.length; i < len; i++) {
            if (grid[i]) {
                for (j = 0, len2 = grid[i].length; j < len2; j++) {
                    cell = grid[i][j];
                    if (cell) {
                        data.push([
                            Math.round(cell[0]),
                            Math.round(cell[1]),
                            Math.min(cell[2], max),
                        ]);
                    }
                }
            }
        }
        // console.timeEnd('process');
        // console.time('draw ' + data.length);
        this._heat.data(data).draw(this.options.minOpacity);
        // console.timeEnd('draw ' + data.length);
        this._frame = null;
    },
    _animateZoom: function (e) {
        var scale = this._map.getZoomScale(e.zoom), offset = this._map
            ._getCenterOffset(e.center)
            ._multiplyBy(-scale)
            .subtract(this._map._getMapPanePos());
        if (L.DomUtil.setTransform) {
            L.DomUtil.setTransform(this._canvas, offset, scale);
        }
        else {
            this._canvas.style[L.DomUtil.TRANSFORM] =
                L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
        }
    },
});
L.heatLayer = function (latlngs, options) {
    return new L.HeatLayer(latlngs, options);
};

//# sourceMappingURL=leaflet-heat.js.map
;// ./lib/leaflet-imageservice.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

(leaflet_src_js_default()).ImageService = leaflet_src_js_default().Layer.extend({
    options: {
        url: '',
        f: 'image',
        format: 'jpgpng',
        pixelType: 'UNKNOWN',
        noData: [],
        noDataInterpretation: '',
        interpolation: '',
        compressionQuality: '',
        bandIds: [],
        time: [],
        renderingRule: {},
        mosaicRule: {},
        endpoint: '',
        attribution: '',
        crs: null,
        interactive: false,
        updateInterval: 200,
    },
    initialize: function (options) {
        leaflet_src_js_default().Util.setOptions(this, options);
    },
    updateUrl: function () {
        // update the url for the current bounds
        if (this.options.endpoint === 'Esri') {
            this._url = this.options.url + '/exportImage' + this._buildParams();
        }
        else {
            this._url = this.options.url;
        }
        this._bounds = this.toLatLngBounds(this._getBounds());
        this._topLeft = this._map.getPixelBounds().min;
        return this;
    },
    onAdd: function (map) {
        this._map = map;
        this.updateUrl();
        if (!this._image) {
            this._initImage();
        }
        this._map.on('moveend', () => {
            leaflet_src_js_default().Util.throttle(this.update(), this.options.updateInterval, this);
        });
        if (this.options.interactive) {
            leaflet_src_js_default().DomUtil.addClass(this._image, 'leaflet-interactive');
            this.addInteractiveTarget(this._image);
        }
        this.getPane().appendChild(this._image);
        this._reset();
    },
    onRemove: function () {
        leaflet_src_js_default().DomUtil.remove(this._image);
        if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
        }
    },
    bringToFront: function () {
        // bring layer to the top of all overlays
        if (this._map) {
            leaflet_src_js_default().DomUtil.toFront(this._image);
        }
        return this;
    },
    bringToBack: function () {
        // bring layer to the bottom of all overlays
        if (this._map) {
            leaflet_src_js_default().DomUtil.toBack(this._image);
        }
        return this;
    },
    setUrl: function (url) {
        // change the URL of the image
        if (this.options.endpoint === 'Esri') {
            this._url = url + '/exportImage' + this._buildParams();
        }
        else {
            this._url = url;
        }
        if (this._image) {
            this._image.src = url;
        }
        return this;
    },
    getEvents: function () {
        const events = {
            zoom: this._reset,
            viewreset: this._reset,
        };
        return events;
    },
    getBounds: function () {
        // get bounds
        return this._bounds;
    },
    toLatLngBounds: function (a, b) {
        // convert bounds to LatLngBounds object
        if (a instanceof (leaflet_src_js_default()).LatLngBounds) {
            return a;
        }
        return new (leaflet_src_js_default()).LatLngBounds(a, b);
    },
    getElement: function () {
        // get image element
        return this._image;
    },
    getCenter: function () {
        // get map center
        return this._bounds.getCenter();
    },
    _getBBox: function () {
        // get the bounding box of the current map formatted for exportImage
        const pixelbounds = this._map.getPixelBounds();
        const sw = this._map.unproject(pixelbounds.getBottomLeft());
        const ne = this._map.unproject(pixelbounds.getTopRight());
        return [
            this._map.options.crs.project(ne).x,
            this._map.options.crs.project(ne).y,
            this._map.options.crs.project(sw).x,
            this._map.options.crs.project(sw).y,
        ];
    },
    _getBounds: function () {
        // get the bounds of the current map
        return [
            [this._map.getBounds().getSouth(), this._map.getBounds().getWest()],
            [this._map.getBounds().getNorth(), this._map.getBounds().getEast()],
        ];
    },
    _getSize: function () {
        // get the size of the current map
        const size = this._map.getSize();
        return [size.x, size.y];
    },
    _getEPSG: function () {
        // get the EPSG code (numeric) of the current map
        const epsg = this.options.crs.code;
        const spatial_reference = parseInt(epsg.split(':')[1], 10);
        return spatial_reference;
    },
    _getTime: function () {
        // get start and end times and convert to seconds since epoch
        const startTime = new Date(this.options.time[0]).getTime().valueOf();
        const endTime = new Date(this.options.time[1]).getTime().valueOf();
        return [startTime, endTime];
    },
    _buildParams: function () {
        // parameters for image server query
        const params = {
            bbox: this._getBBox().join(','),
            size: this._getSize().join(','),
            bboxSR: this._getEPSG(),
            imageSR: this._getEPSG(),
            f: this.options.f,
        };
        // add string parameters
        if (this.options.format) {
            params['format'] = this.options.format;
        }
        if (this.options.pixelType) {
            params['pixelType'] = this.options.pixelType;
        }
        if (this.options.noDataInterpretation) {
            params['noDataInterpretation'] = this.options.noDataInterpretation;
        }
        if (this.options.interpolation) {
            params['interpolation'] = this.options.interpolation;
        }
        if (this.options.compressionQuality) {
            params['compressionQuality'] = this.options.compressionQuality;
        }
        // merge list parameters
        if (this.options.noData.length) {
            params['noData'] = this.options.noData.join(',');
        }
        if (this.options.bandIds.length) {
            params['bandIds'] = this.options.bandIds.join(',');
        }
        if (this.options.time.length) {
            params['time'] = this._getTime().join(',');
        }
        // convert dictionary parameters to JSON
        if (Object.keys(this.options.renderingRule).length) {
            params['renderingRule'] = JSON.stringify(this.options.renderingRule);
        }
        if (Object.keys(this.options.mosaicRule).length) {
            params['mosaicRule'] = JSON.stringify(this.options.mosaicRule);
        }
        // return the formatted query string
        return leaflet_src_js_default().Util.getParamString(params);
    },
    _initImage: function () {
        const wasElementSupplied = this._url.tagName === 'IMG';
        const img = (this._image = leaflet_src_js_default().DomUtil.create('img'));
        leaflet_src_js_default().DomUtil.addClass(img, 'leaflet-image-layer');
        img.onselectstart = (leaflet_src_js_default()).Util.falseFn;
        img.onmousemove = (leaflet_src_js_default()).Util.falseFn;
        img.onload = leaflet_src_js_default().Util.bind(this.fire, this, 'load');
        if (wasElementSupplied) {
            this._url = img.src;
            return;
        }
        img.src = this._url;
    },
    _reset: function () {
        const img = this._image;
        const size = this._getSize();
        img.style.width = size[0] + 'px';
        img.style.height = size[1] + 'px';
        if (this._getEPSG() === 3857) {
            const bounds = new (leaflet_src_js_default()).Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast()));
            leaflet_src_js_default().DomUtil.setPosition(img, bounds.min ?? new leaflet_src_js_.Point(0, 0));
        }
        else {
            const pixelorigin = this._topLeft.subtract(this._map.getPixelOrigin());
            leaflet_src_js_default().DomUtil.setPosition(img, pixelorigin);
        }
    },
    update: function () {
        if (!this._map) {
            return;
        }
        // don't update if currently panning
        if (this._map._panTransition && this._map._panTransition._inProgress) {
            return;
        }
        // update the url for the current bounds
        this.updateUrl();
        // update image source
        if (this._image && this._map) {
            this._image.src = this._url;
            this._reset();
        }
    },
});
(leaflet_src_js_default()).imageService = function (options) {
    return new (leaflet_src_js_default()).ImageService(options);
};
//# sourceMappingURL=leaflet-imageservice.js.map
;// ./lib/leaflet-magnifyingglass.js
// The code below was copied from the following source:
// https://github.com/bbecquet/Leaflet.MagnifyingGlass

(leaflet_src_js_default()).MagnifyingGlass = leaflet_src_js_default().Layer.extend({
    options: {
        radius: 100,
        zoomOffset: 3,
        layers: [],
        fixedPosition: false,
        latLng: [0, 0],
        fixedZoom: -1,
    },
    initialize: function (options) {
        leaflet_src_js_default().Util.setOptions(this, options);
        this._fixedZoom = this.options.fixedZoom != -1;
        this._mainMap = null;
        this._glassMap = null;
    },
    getMap: function () {
        return this._glassMap;
    },
    _createMiniMap: function (elt) {
        return new (leaflet_src_js_default()).Map(elt, {
            layers: this.options.layers,
            zoom: this._getZoom(),
            maxZoom: this._mainMap.getMaxZoom(),
            minZoom: this._mainMap.getMinZoom(),
            crs: this._mainMap.options.crs,
            fadeAnimation: false,
            // disable every controls and interaction means
            attributionControl: false,
            zoomControl: false,
            boxZoom: false,
            touchZoom: false,
            scrollWheelZoom: false,
            doubleClickZoom: false,
            dragging: false,
            keyboard: false,
        });
    },
    _getZoom: function () {
        return this._fixedZoom
            ? this.options.fixedZoom
            : this._mainMap.getZoom() + this.options.zoomOffset;
    },
    _updateZoom: function () {
        this._glassMap.setZoom(this._getZoom());
    },
    setRadius: function (radius) {
        this.options.radius = radius;
        if (this._wrapperElt) {
            this._wrapperElt.style.width = this.options.radius * 2 + 'px';
            this._wrapperElt.style.height = this.options.radius * 2 + 'px';
        }
    },
    setLatLng: function (latLng) {
        this.options.latLng = latLng;
        this._update(latLng);
    },
    _updateFromMouse: function (evt) {
        this._update(evt.latlng, evt.layerPoint);
    },
    _updateFixed: function () {
        this._update(this.options.latLng);
    },
    _update: function (latLng, layerPoint) {
        // update mini map view, forcing no animation
        this._glassMap.setView(latLng, this._getZoom(), {
            pan: { animate: false },
        });
        // update the layer element position on the main map,
        // using the one provided or reprojecting it
        layerPoint = layerPoint || this._mainMap.latLngToLayerPoint(latLng);
        this._wrapperElt.style.left = layerPoint.x - this.options.radius + 'px';
        this._wrapperElt.style.top = layerPoint.y - this.options.radius + 'px';
    },
    /**
    As defined by ILayer
    */
    onAdd: function (map) {
        this._mainMap = map;
        // create a wrapper element and a container for the map inside it
        this._wrapperElt = leaflet_src_js_default().DomUtil.create('div', 'leaflet-magnifying-glass');
        var glassMapElt = leaflet_src_js_default().DomUtil.create('div', '', this._wrapperElt);
        // Webkit border-radius clipping workaround (see CSS)
        if ((leaflet_src_js_default()).Browser.webkit)
            leaflet_src_js_default().DomUtil.addClass(glassMapElt, 'leaflet-magnifying-glass-webkit');
        // build the map
        this._glassMap = this._createMiniMap(glassMapElt);
        // forward some DOM events as Leaflet events
        leaflet_src_js_default().DomEvent.addListener(this._wrapperElt, 'click', this._fireClick, this);
        var opts = this.options;
        this.setRadius(opts.radius);
        this.setLatLng(opts.latLng);
        this._glassMap.whenReady(() => {
            if (opts.fixedPosition) {
                this._mainMap.on('zoomend', this._updateFixed, this);
                // for now, hide the elements during zoom transitions
                leaflet_src_js_default().DomUtil.addClass(this._wrapperElt, 'leaflet-zoom-hide');
            }
            else {
                this._mainMap.on('mousemove', this._updateFromMouse, this);
                if (!this._fixedZoom) {
                    this._mainMap.on('zoomend', this._updateZoom, this);
                }
            }
        }, this);
        // add the magnifying glass as a layer to the top-most pane
        map.getPanes().popupPane.appendChild(this._wrapperElt);
        // needed after the element has been added, otherwise tile loading is messy
        this._glassMap.invalidateSize();
        return this;
    },
    _fireClick: function (domMouseEvt) {
        this.fire('click', domMouseEvt);
        leaflet_src_js_default().DomEvent.stopPropagation(domMouseEvt);
    },
    /**
    As defined by ILayer
    */
    onRemove: function (map) {
        map.off('viewreset', this._updateFixed, this);
        map.off('mousemove', this._updateFromMouse, this);
        map.off('zoomend', this._updateZoom, this);
        // layers must be explicitely removed before map destruction,
        // otherwise they can't be reused if the mg is re-added
        for (var i = 0, l = this.options.layers.length; i < l; i++) {
            this._glassMap.removeLayer(this.options.layers[i]);
        }
        this._glassMap.remove();
        leaflet_src_js_default().DomEvent.removeListener(this._wrapperElt, 'click', this._fireClick);
        map.getPanes().popupPane.removeChild(this._wrapperElt);
        this._mainMap = null;
        return this;
    },
});
(leaflet_src_js_default()).magnifyingGlass = function (options) {
    return new (leaflet_src_js_default()).MagnifyingGlass(options);
};
//# sourceMappingURL=leaflet-magnifyingglass.js.map
;// ./lib/leaflet.js



















leaflet_src_js_default().Layer.include({
    _refreshTileUrl: function (tile, url) {
        //use a image in background, so that only replace the actual tile, once image is loaded in cache!
        const img = new Image();
        img.onload = () => {
            leaflet_src_js_default().Util.requestAnimFrame(() => {
                tile.el.src = url;
            });
        };
        img.src = url;
    },
    refresh: function () {
        //prevent _tileOnLoad/_tileReady re-triggering a opacity animation
        const wasAnimated = this._map._fadeAnimated;
        this._map._fadeAnimated = false;
        for (const key in this._tiles) {
            const tile = this._tiles[key];
            if (tile.current && tile.active) {
                const oldsrc = tile.el.src;
                const newsrc = this.getTileUrl(tile.coords);
                if (oldsrc != newsrc) {
                    //L.DomEvent.off(tile, 'load', this._tileOnLoad); ... this doesnt work!
                    this._refreshTileUrl(tile, newsrc);
                }
            }
        }
        if (wasAnimated) {
            setTimeout(() => {
                this._map._fadeAnimated = wasAnimated;
            }, 5000);
        }
    },
});
/* harmony default export */ const leaflet = ((leaflet_src_js_default()));
//# sourceMappingURL=leaflet.js.map
// EXTERNAL MODULE: consume shared module (default) @jupyter-widgets/base@^2 || ^3 || ^4 || ^5 || ^6 (singleton)
var base_2_3_4_5_6_singleton_ = __webpack_require__(4488);
// EXTERNAL MODULE: consume shared module (default) @lumino/messaging@^2.0.0 (singleton)
var messaging_2_0_singleton_ = __webpack_require__(6230);
// EXTERNAL MODULE: consume shared module (default) @lumino/widgets@^2.3.1-alpha.0 (singleton)
var widgets_2_3_1_alpha_singleton_ = __webpack_require__(5256);
;// ./lib/utils.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

function camel_case(input) {
    // Convert from foo_bar to fooBar
    return input.toLowerCase().replace(/_(.)/g, function (match, group1) {
        return group1.toUpperCase();
    });
}
class LeafletWidgetView extends base_2_3_4_5_6_singleton_.WidgetView {
}
class LeafletDOMWidgetView extends base_2_3_4_5_6_singleton_.DOMWidgetView {
}
class leafletViewCommon {
    get_options() {
        const o = this.model.get('options');
        const options = {};
        for (const key of o) {
            if (this.model.get(key) !== null) {
                options[camel_case(key)] = this.model.get(key);
            }
        }
        return options;
    }
}
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            const propertyDescriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);
            if (propertyDescriptor) {
                Object.defineProperty(derivedCtor.prototype, name, propertyDescriptor);
            }
        });
    });
}
applyMixins(LeafletWidgetView, [leafletViewCommon]);
applyMixins(LeafletDOMWidgetView, [leafletViewCommon]);
//# sourceMappingURL=utils.js.map
;// ./lib/layers/Layer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.







class LeafletLayerModel extends base_2_3_4_5_6_singleton_.WidgetModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletLayerView',
            _model_name: 'LeafletLayerModel',
            _view_module: 'jupyter-leaflet',
            _model_module: 'jupyter-leaflet',
            opacity: 1.0,
            bottom: false,
            options: [],
            name: '',
            base: false,
            popup: null,
            popup_min_width: 50,
            popup_max_width: 300,
            popup_max_height: null,
            pane: '',
            subitems: [],
            pm_ignore: true,
            snap_ignore: false,
        };
    }
}
LeafletLayerModel.serializers = {
    ...base_2_3_4_5_6_singleton_.WidgetModel.serializers,
    popup: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
    subitems: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletUILayerModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletUILayerView',
            _model_name: 'LeafletUILayerModel',
        };
    }
}
class LeafletLayerView extends LeafletWidgetView {
    create_obj() { }
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
        this.popup_content_promise = Promise.resolve();
    }
    remove_subitem_view(child_view) {
        if (child_view instanceof LeafletLayerView) {
            this.map_view.obj?.removeLayer(child_view.obj);
        }
        if (child_view instanceof LeafletControlView) {
            this.map_view.obj?.removeControl(child_view.obj);
        }
        child_view.remove();
    }
    async add_subitem_model(child_model) {
        const view = await this.create_child_view(child_model, {
            map_view: this,
        });
        if (view.obj instanceof leaflet_src_js_.Layer) {
            this.map_view.obj?.addLayer(view.obj);
        }
        if (view.obj instanceof leaflet_src_js_.Control) {
            this.map_view.obj?.addControl(view.obj);
        }
        //Trigger the displayed event of the child view.
        this.displayed.then(() => {
            view.trigger('displayed', this);
        });
        return view;
    }
    async render() {
        await Promise.resolve(this.create_obj());
        this.leaflet_events();
        this.model_events();
        this.bind_popup(this.model.get('popup'));
        this.listenTo(this.model, 'change:popup', (model, value_2) => {
            this.bind_popup(value_2);
        });
        this.update_pane();
        this.subitem_views = new base_2_3_4_5_6_singleton_.ViewList(this.add_subitem_model, this.remove_subitem_view, this);
        this.subitem_views.update(this.model.get('subitems'));
    }
    update_pane() {
        const pane = this.model.get('pane');
        if (pane !== '') {
            leaflet.setOptions(this.obj, { pane });
        }
    }
    leaflet_events() {
        // If the layer is interactive
        if (this.obj.on) {
            this.obj.on(
            // TODO: Calls wrong overload without 'as any'
            'click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu preclick', (event) => {
                this.send({
                    event: 'interaction',
                    type: event.type,
                    coordinates: [event.latlng.lat, event.latlng.lng],
                });
            });
            this.obj.on('popupopen', () => {
                // This is a workaround for making maps rendered correctly in popups
                window.dispatchEvent(new Event('resize'));
            });
            //TODO: transform is from a plugin, working on base leaflet first
            // this layer is transformable
            //@ts-ignore
            if (this.obj.transform) {
                // add the handler only when the layer has been added
                this.obj.on('add', () => {
                    //@ts-ignore
                    this.update_transform();
                });
                this.obj.on('transformed', () => {
                    //@ts-ignore
                    this.model.set('locations', this.obj.getLatLngs());
                    this.touch();
                });
            }
        }
    }
    model_events() {
        let key;
        const o = this.model.get('options');
        for (let i = 0; i < o.length; i++) {
            key = o[i];
            this.listenTo(this.model, 'change:' + key, () => {
                leaflet.setOptions(this.obj, this.get_options());
            });
        }
        this.model.on_some_change(['popup_min_width', 'popup_max_width', 'popup_max_height'], this.update_popup, this);
        this.listenTo(this.model, 'change:pane', () => {
            this.map_view.rerender();
        });
        this.listenTo(this.model, 'change:subitems', () => {
            this.subitem_views.update(this.subitems);
        });
    }
    remove() {
        super.remove();
        this.subitem_views.remove();
        this.popup_content_promise.then(() => {
            if (this.popup_content) {
                this.popup_content.remove();
            }
        });
    }
    bind_popup(value) {
        if (this.popup_content) {
            this.obj.unbindPopup();
            this.popup_content.remove();
        }
        if (value) {
            this.popup_content_promise = this.popup_content_promise.then(async () => {
                const view = await this.create_child_view(value, {
                    map_view: this.map_view,
                });
                // If it's a Popup widget
                if (view.obj instanceof leaflet_src_js_.Popup) {
                    this.obj.bindPopup(view.obj, this.popup_options());
                }
                else {
                    messaging_2_0_singleton_.MessageLoop.sendMessage(view.pWidget, widgets_2_3_1_alpha_singleton_.Widget.Msg.BeforeAttach);
                    this.obj.bindPopup(view.el, this.popup_options());
                    messaging_2_0_singleton_.MessageLoop.sendMessage(view.pWidget, widgets_2_3_1_alpha_singleton_.Widget.Msg.AfterAttach);
                }
                this.popup_content = view;
                this.trigger('popup_content:created');
            });
        }
        return this.popup_content_promise;
    }
    popup_options() {
        return {
            minWidth: this.model.get('popup_min_width'),
            maxWidth: this.model.get('popup_max_width'),
            maxHeight: this.model.get('popup_max_height'),
        };
    }
    update_popup() {
        leaflet.setOptions(this.obj.getPopup(), this.popup_options());
        // Those TWO lines will enforce the options update
        this.obj.togglePopup();
        this.obj.togglePopup();
    }
}
class LeafletUILayerView extends LeafletLayerView {
}
//# sourceMappingURL=Layer.js.map
;// ./lib/layers/VectorLayer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

class LeafletVectorLayerModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletVectorLayerView',
            _model_name: 'LeafletVectorLayerModel',
        };
    }
}
class LeafletVectorLayerView extends LeafletLayerView {
}
//# sourceMappingURL=VectorLayer.js.map
;// ./lib/layers/AntPath.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// leaflet-ant-path does not have typescript definitions
//@ts-ignore



class LeafletAntPathModel extends LeafletVectorLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletAntPathView',
            _model_name: 'LeafletAntPathModel',
            use: 'polyline',
            delay: 400,
            weight: 5,
            dash_array: [10, 20],
            color: '#0000FF',
            pulse_color: '#FFFFFF',
            paused: false,
            reverse: false,
            hardware_accelerated: false,
            radius: 10,
        };
    }
}
class LeafletAntPathView extends LeafletVectorLayerView {
    create_obj() {
        this.obj = (0,leaflet_ant_path_js_.antPath)(this.model.get('locations'), this.get_ant_options());
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:locations', () => {
            this.obj.setLatLngs(this.model.get('locations'));
        });
        this.model.on_some_change(this.model.get('options'), () => {
            this.obj.setStyle(this.get_ant_options());
        }, this);
        this.obj.setStyle(this.get_ant_options());
    }
    get_ant_options() {
        const options = this.get_options();
        if (options.use != 'circle') {
            delete options.radius;
        }
        options.use = leaflet[options.use];
        return options;
    }
}
//# sourceMappingURL=AntPath.js.map
;// ./lib/layers/AwesomeIcon.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletAwesomeIconModel extends LeafletUILayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletAwesomeIconView',
            _model_name: 'LeafletAwesomeIconModel',
            name: 'home',
            marker_color: 'blue',
            icon_color: 'blue',
            spin: false,
        };
    }
}
class LeafletAwesomeIconView extends LeafletUILayerView {
    create_obj() {
        this.obj = leaflet.AwesomeMarkers.icon({
            prefix: 'fa',
            icon: this.model.get('name'),
            markerColor: this.model.get('marker_color'),
            iconColor: this.model.get('icon_color'),
            spin: this.model.get('spin'),
        });
    }
}
//# sourceMappingURL=AwesomeIcon.js.map
;// ./lib/layers/Path.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

class LeafletPathModel extends LeafletVectorLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletPathView',
            _model_name: 'LeafletPathModel',
            stroke: true,
            color: '#0033FF',
            weight: 5,
            fill: true,
            fill_color: null,
            fill_opacity: 0.2,
            dash_array: null,
            line_cap: 'round',
            line_join: 'round',
            pointer_events: '',
        };
    }
}
class LeafletPathView extends LeafletVectorLayerView {
    model_events() {
        super.model_events();
        let key;
        const o = this.model.get('options');
        for (let i = 0; i < o.length; i++) {
            key = o[i];
            this.listenTo(this.model, 'change:' + key, () => {
                this.obj.setStyle(this.get_options());
            });
        }
    }
}
//# sourceMappingURL=Path.js.map
;// ./lib/layers/CircleMarker.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


const DEFAULT_LOCATION = [0.0, 0.0];
class LeafletCircleMarkerModel extends LeafletPathModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletCircleMarkerView',
            _model_name: 'LeafletCircleMarkerModel',
            location: DEFAULT_LOCATION,
        };
    }
}
class LeafletCircleMarkerView extends LeafletPathView {
    create_obj() {
        this.obj = leaflet.circleMarker(this.model.get('location'), this.get_options());
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:location', () => {
            this.obj.setLatLng(this.model.get('location'));
        });
    }
}
//# sourceMappingURL=CircleMarker.js.map
;// ./lib/layers/Circle.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletCircleModel extends LeafletCircleMarkerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletCircleView',
            _model_name: 'LeafletCircleModel',
        };
    }
}
class LeafletCircleView extends LeafletCircleMarkerView {
    create_obj() {
        this.obj = leaflet.circle(this.model.get('location'), this.get_options());
    }
    model_events() {
        super.model_events();
        // Workaround for https://github.com/Leaflet/Leaflet/pull/6128
        this.listenTo(this.model, 'change:radius', () => {
            this.obj.setRadius(this.get_options().radius);
        });
    }
}
//# sourceMappingURL=Circle.js.map
;// ./lib/layers/DivIcon.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletDivIconModel extends LeafletUILayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletDivIconView',
            _model_name: 'LeafletDivIconModel',
            html: '',
            bg_pos: [0, 0],
            icon_size: null,
            icon_anchor: null,
            popup_anchor: [0, 0],
        };
    }
}
class LeafletDivIconView extends LeafletUILayerView {
    create_obj() {
        this.obj = leaflet.divIcon(this.get_options());
    }
}
//# sourceMappingURL=DivIcon.js.map
;// ./lib/layers/LayerGroup.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletLayerGroupModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletLayerGroupView',
            _model_name: 'LeafletLayerGroupModel',
            layers: [],
        };
    }
}
LeafletLayerGroupModel.serializers = {
    ...LeafletLayerModel.serializers,
    layers: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletLayerGroupView extends LeafletLayerView {
    create_obj() {
        this.obj = leaflet.layerGroup();
        this.layer_views = new base_2_3_4_5_6_singleton_.ViewList(this.add_layer_model, this.remove_layer_view, this);
        this.layer_views.update(this.model.get('layers'));
    }
    remove_layer_view(child_view) {
        this.obj.removeLayer(child_view.obj);
        child_view.remove();
    }
    async add_layer_model(child_model) {
        const child_view = await this.create_child_view(child_model);
        this.obj.addLayer(child_view.obj);
        return child_view;
    }
    model_events() {
        this.listenTo(this.model, 'change:layers', () => {
            this.layer_views.update(this.model.get('layers'));
        });
    }
}
//# sourceMappingURL=LayerGroup.js.map
;// ./lib/layers/FeatureGroup.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletFeatureGroupModel extends LeafletLayerGroupModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletFeatureGroupView',
            _model_name: 'LeafletFeatureGroupModel',
        };
    }
}
class LeafletFeatureGroupView extends LeafletLayerGroupView {
    create_obj() {
        this.obj = leaflet.featureGroup();
    }
}
//# sourceMappingURL=FeatureGroup.js.map
;// ./lib/layers/GeoJSON.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletGeoJSONModel extends LeafletFeatureGroupModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletGeoJSONView',
            _model_name: 'LeafletGeoJSONModel',
            data: {},
            style: {},
            visible: true,
            hover_style: {},
            point_style: {},
        };
    }
}
class LeafletGeoJSONView extends LeafletFeatureGroupView {
    create_obj() {
        const style = (feature) => {
            const model_style = this.model.get('style');
            const feature_style = feature?.properties.style || {};
            return {
                ...feature_style,
                ...model_style,
            };
        };
        // Use get_options to trigger default option fetch behaviour
        let options = this.get_options();
        const geojson_options = {
            style: style,
            onEachFeature: (feature, layer) => {
                const mouseevent = (e) => {
                    if (e.type == 'mouseover') {
                        layer.setStyle(this.model.get('hover_style'));
                        layer.once('mouseout', () => {
                            this.obj.resetStyle(layer);
                        });
                    }
                    this.send({
                        event: e.type,
                        feature: feature,
                        properties: feature.properties,
                        id: feature.id,
                        coordinates: [e.latlng.lat, e.latlng.lng],
                    });
                };
                const pmIgnore = this.model.get('pm_ignore');
                if (pmIgnore !== undefined) {
                    layer.pmIgnore = pmIgnore;
                    if (pmIgnore && layer.pm) {
                        layer.pm.disable();
                        delete layer.pm;
                    }
                }
                layer.on({
                    mouseover: mouseevent,
                    click: mouseevent,
                });
            },
        };
        options = { ...options, ...geojson_options };
        const point_style = this.model.get('point_style');
        if (Object.keys(point_style).length !== 0) {
            options.pointToLayer = function (feature, latlng) {
                return new leaflet.CircleMarker(latlng, point_style);
            };
        }
        this.obj = leaflet.geoJson(this.model.get('data'), options);
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:style', () => {
            this.obj.setStyle(this.model.get('style'));
        });
        this.listenTo(this.model, 'change:data', () => {
            this.obj.clearLayers();
            this.obj.addData(this.model.get('data'));
        });
        // TODO this "visible" toggle is misleading, it suggests that there is
        //  a visibility flag available in leaflet but actually it just doesn't add data.
        //  This can lead to wasteful usage since it's the same as simply not adding geojson data
        //  on the python side, except that in this case data will be transfered and then not used.
        this.listenTo(this.model, 'change:visible', () => {
            if (this.model.get('visible')) {
                this.obj.addData(this.model.get('data'));
            }
            else {
                this.obj.clearLayers();
            }
        });
    }
}
//# sourceMappingURL=GeoJSON.js.map
;// ./lib/layers/RasterLayer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

class LeafletRasterLayerModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletRasterLayerView',
            _model_name: 'LeafletRasterLayerModel',
            visible: true,
        };
    }
}
class LeafletRasterLayerView extends LeafletLayerView {
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:opacity', () => {
            if (this.model.get('visible')) {
                this.obj.setOpacity(this.model.get('opacity'));
            }
        });
        this.listenTo(this.model, 'change:visible', () => {
            if (this.model.get('visible')) {
                this.obj.setOpacity(this.model.get('opacity'));
            }
            else {
                this.obj.setOpacity(0);
            }
        });
        if (this.model.get('visible')) {
            this.obj.setOpacity(this.model.get('opacity'));
        }
        else {
            this.obj.setOpacity(0);
        }
    }
}
//# sourceMappingURL=RasterLayer.js.map
;// ./lib/layers/Heatmap.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletHeatmapModel extends LeafletRasterLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletHeatmapView',
            _model_name: 'LeafletHeatmapModel',
            locations: [],
            minOpacity: 0.05,
            maxZoom: 18,
            max: 1.0,
            radius: 25.0,
            blur: 15.0,
            gradient: {
                0.4: 'blue',
                0.6: 'cyan',
                0.7: 'lime',
                0.8: 'yellow',
                1.0: 'red',
            },
        };
    }
}
class LeafletHeatmapView extends LeafletLayerView {
    create_obj() {
        this.obj = leaflet.heatLayer(this.model.get('locations'), this.get_options());
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:locations', () => {
            this.obj.setLatLngs(this.model.get('locations'));
        });
    }
}
//# sourceMappingURL=Heatmap.js.map
;// ./lib/layers/Icon.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletIconModel extends LeafletUILayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletIconView',
            _model_name: 'LeafletIconModel',
            icon_url: '',
            shadow_url: '',
            icon_size: null,
            shadow_size: null,
            icon_anchor: null,
            shadow_anchor: null,
            popup_anchor: [0, 0],
        };
    }
}
class LeafletIconView extends LeafletUILayerView {
    create_obj() {
        this.obj = leaflet.icon(this.get_options());
    }
}
//# sourceMappingURL=Icon.js.map
;// ./lib/layers/ImageOverlay.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


const ImageOverlay_DEFAULT_LOCATION = [0.0, 0.0];
class LeafletImageOverlayModel extends LeafletRasterLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletImageOverlayView',
            _model_name: 'LeafletImageOverlayModel',
            url: '',
            bounds: [ImageOverlay_DEFAULT_LOCATION, ImageOverlay_DEFAULT_LOCATION],
            attribution: '',
        };
    }
}
class LeafletImageOverlayView extends LeafletRasterLayerView {
    create_obj() {
        this.obj = leaflet.imageOverlay(this.model.get('url'), this.model.get('bounds'), this.get_options());
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:url', () => {
            const url = this.model.get('url');
            this.obj.setUrl(url);
        });
        this.listenTo(this.model, 'change:bounds', () => {
            const bounds = this.model.get('bounds');
            this.obj.setBounds(bounds);
        });
    }
}
//# sourceMappingURL=ImageOverlay.js.map
;// ./lib/projections.js


function getProjection(proj) {
    if (proj.custom === false) {
        return leaflet_src_js_.CRS[proj.name];
    }
    else {
        return new leaflet.Proj.CRS(proj.name, proj.proj4def, {
            origin: proj.origin,
            resolutions: proj.resolutions,
            bounds: new leaflet.Bounds(proj.bounds),
        });
    }
}
//# sourceMappingURL=projections.js.map
;// ./lib/layers/ImageService.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletImageServiceModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletImageServiceView',
            _model_name: 'LeafletImageServiceModel',
            url: '',
            f: 'image',
            format: 'jpgpng',
            pixelType: 'UNKNOWN',
            noData: [],
            noDataInterpretation: '',
            interpolation: '',
            compressionQuality: '',
            bandIds: [],
            time: [],
            renderingRule: {},
            mosaicRule: {},
            endpoint: '',
            attribution: '',
            crs: null,
            interactive: false,
            updateInterval: 200,
        };
    }
}
class LeafletImageServiceView extends LeafletLayerView {
    create_obj() {
        const options = {
            ...this.get_options(),
            url: this.model.get('url'),
            crs: getProjection(this.model.get('crs')),
        };
        this.obj = leaflet.imageService(options);
    }
    model_events() {
        super.model_events();
        this.model.on('change:url', () => {
            this.obj.update();
        });
        for (let option in this.get_options()) {
            this.model.on('change:' + option, () => {
                this.obj.update();
            });
        }
    }
}
//# sourceMappingURL=ImageService.js.map
// EXTERNAL MODULE: consume shared module (default) spin.js@^4.1.0 (strict) (fallback: ./node_modules/spin.js/spin.js)
var spin_js_ = __webpack_require__(544);
;// ./lib/layers/TileLayer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletTileLayerModel extends LeafletRasterLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletTileLayerView',
            _model_name: 'LeafletTileLayerModel',
            bottom: true,
            url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            min_zoom: 0,
            max_zoom: 18,
            min_native_zoom: null,
            max_native_zoom: null,
            bounds: null,
            tile_size: 256,
            attribution: null,
            detect_retina: false,
            no_wrap: false,
            tms: false,
            show_loading: false,
            loading: false,
            zoom_offset: 0,
        };
    }
}
class LeafletTileLayerView extends LeafletRasterLayerView {
    create_obj() {
        this.obj = leaflet.tileLayer(this.model.get('url'), this.get_options());
        this.model.on('msg:custom', this.handle_message.bind(this));
    }
    leaflet_events() {
        super.leaflet_events();
        this.obj.on('loading', () => {
            this.model.set('loading', true);
            this.model.save_changes();
            if (this.model.get('show_loading')) {
                this.spinner = new spin_js_.Spinner().spin(this.map_view.el);
            }
        });
        this.obj.on('load', () => {
            this.model.set('loading', false);
            this.model.save_changes();
            this.send({
                event: 'load',
            });
            if (this.model.get('show_loading')) {
                this.spinner.stop();
            }
        });
        this.obj.on('remove', () => {
            if (this.model.get('show_loading')) {
                this.spinner.stop();
            }
        });
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:url', () => {
            this.obj.setUrl(this.model.get('url'), true);
            this.obj.refresh();
        });
    }
    handle_message(content) {
        if (content.msg == 'redraw') {
            this.obj.redraw();
        }
    }
}
//# sourceMappingURL=TileLayer.js.map
;// ./lib/layers/LocalTileLayer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

class LeafletLocalTileLayerModel extends LeafletTileLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletLocalTileLayerView',
            _model_name: 'LeafletLocalTileLayerModel',
            path: '',
        };
    }
}
class LeafletLocalTileLayerView extends LeafletTileLayerView {
    create_obj() {
        this.model.set('url', this.model.get('path'));
        this.model.save_changes();
        super.create_obj();
    }
}
//# sourceMappingURL=LocalTileLayer.js.map
;// ./lib/layers/MagnifyingGlass.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




class LeafletMagnifyingGlassModel extends LeafletRasterLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletMagnifyingGlassView',
            _model_name: 'LeafletMagnifyingGlassModel',
            radius: 100,
            zoomOffset: 3,
            fixedZoom: -1,
            fixedPosition: false,
            latLng: [],
            layers: [],
        };
    }
}
LeafletMagnifyingGlassModel.serializers = {
    ...base_2_3_4_5_6_singleton_.WidgetModel.serializers,
    layers: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletMagnifyingGlassView extends LeafletLayerView {
    remove_layer_view(child_view) {
        child_view.remove();
    }
    async add_layer_model(child_model) {
        const child_view = await this.create_child_view(child_model);
        return child_view.obj;
    }
    async create_obj() {
        this.layer_views = new base_2_3_4_5_6_singleton_.ViewList(this.add_layer_model, this.remove_layer_view, this);
        const layers = this.get_options().layers;
        const layers_views = await this.layer_views.update(layers);
        const options = this.get_options();
        options.layers = layers_views;
        this.obj = leaflet.magnifyingGlass(options);
    }
    model_events() {
        super.model_events();
        let key;
        const o = this.model.get('options');
        for (let i = 0; i < o.length; i++) {
            key = o[i];
            this.listenTo(this.model, 'change:' + key, () => {
                this.map_view.obj.removeLayer(this.obj);
                this.create_obj().then(() => {
                    this.map_view.obj.addLayer(this.obj);
                });
            });
        }
    }
}
//# sourceMappingURL=MagnifyingGlass.js.map
;// ./lib/layers/Marker.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



const Marker_DEFAULT_LOCATION = [0.0, 0.0];
class LeafletMarkerModel extends LeafletUILayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletMarkerView',
            _model_name: 'LeafletMarkerModel',
            location: Marker_DEFAULT_LOCATION,
            opacity: 1.0,
            visible: true,
            z_index_offset: 0,
            draggable: true,
            keyboard: true,
            title: '',
            alt: '',
            rise_on_hover: false,
            rise_offset: 250,
            rotation_angle: 0,
            rotation_origin: '',
            icon: null,
        };
    }
}
LeafletMarkerModel.serializers = {
    ...LeafletUILayerModel.serializers,
    icon: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletMarkerView extends LeafletUILayerView {
    initialize(parameters) {
        super.initialize(parameters);
        this.icon_promise = Promise.resolve();
    }
    create_obj() {
        this.obj = leaflet.marker(this.model.get('location'), this.get_options());
        this.obj.on('dragend', (event) => {
            const marker = event.target;
            const position = marker.getLatLng();
            this.model.set('location', [position.lat, position.lng]);
            this.touch();
        });
    }
    remove() {
        super.remove();
        this.icon_promise.then(() => {
            if (this.icon) {
                this.icon.remove();
            }
        });
    }
    set_icon(value) {
        if (this.icon) {
            this.icon.remove();
        }
        if (value) {
            this.icon_promise = this.icon_promise.then(async () => {
                const view = await this.create_child_view(value);
                this.obj.setIcon(view.obj);
                this.icon = view;
            });
        }
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:location', () => {
            this.obj.setLatLng(this.model.get('location'));
            this.send({
                event: 'move',
                location: this.model.get('location'),
            });
        });
        this.listenTo(this.model, 'change:z_index_offset', () => {
            this.obj.setZIndexOffset(this.model.get('z_index_offset'));
        });
        this.listenTo(this.model, 'change:opacity', () => {
            if (this.model.get('visible')) {
                this.obj.setOpacity(this.model.get('opacity'));
            }
        });
        this.listenTo(this.model, 'change:visible', () => {
            if (this.model.get('visible')) {
                this.obj.setOpacity(this.model.get('opacity'));
            }
            else {
                this.obj.setOpacity(0);
            }
        });
        this.listenTo(this.model, 'change:rotation_angle', () => {
            this.obj.setRotationAngle(this.model.get('rotation_angle'));
        });
        this.listenTo(this.model, 'change:rotation_origin', () => {
            this.obj.setRotationOrigin(this.model.get('rotation_origin'));
        });
        this.obj.setLatLng(this.model.get('location'));
        this.obj.setZIndexOffset(this.model.get('z_index_offset'));
        if (this.model.get('visible')) {
            this.obj.setOpacity(this.model.get('opacity'));
        }
        else {
            this.obj.setOpacity(0);
        }
        this.obj.setRotationAngle(this.model.get('rotation_angle'));
        this.obj.setRotationOrigin(this.model.get('rotation_origin'));
        this.listenTo(this.model, 'change:icon', () => {
            this.set_icon(this.model.get('icon'));
        });
        this.set_icon(this.model.get('icon'));
    }
}
//# sourceMappingURL=Marker.js.map
;// ./lib/layers/MarkerCluster.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletMarkerClusterModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletMarkerClusterView',
            _model_name: 'LeafletMarkerClusterModel',
            markers: [],
            show_coverage_on_hover: true,
            zoom_to_bounds_on_click: true,
            spiderfy_on_max_zoom: true,
            remove_outside_visible_bounds: true,
            animate: true,
            animate_adding_markers: false,
            disableClusteringAtZoom: 18,
            maxClusterRadius: 80,
            single_marker_mode: false,
            spiderfy_distance_multiplier: 1,
            polygon_options: {},
            chunked_loading: false,
            chunk_interval: 200,
            chunk_delay: 50,
            spider_leg_polyline_options: {
                weight: 1.5,
                color: '#333',
                opacity: 0.5,
            },
        };
    }
}
LeafletMarkerClusterModel.serializers = {
    ...base_2_3_4_5_6_singleton_.WidgetModel.serializers,
    markers: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletMarkerClusterView extends LeafletLayerView {
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:markers', (model) => {
            this.marker_views.update(model.get('markers'));
        });
    }
    remove_layer_view(child_view) {
        this.obj.removeLayer(child_view.obj);
        child_view.remove();
    }
    async add_layer_model(child_model) {
        const child_view = await this.create_child_view(child_model, {
            map_view: this.map_view,
        });
        this.obj.addLayer(child_view.obj);
        return child_view;
    }
    create_obj() {
        const options = this.get_options();
        this.obj = leaflet.markerClusterGroup(options);
        // Intercept the creation of the cluster group to disable leaflet.pm
        // (so that GeomanDrawControl will not be able to edit it)
        const clusterGroup = leaflet.markerClusterGroup(options);
        const originalAddLayer = clusterGroup._featureGroup.addLayer;
        clusterGroup._featureGroup.addLayer = function (layer) {
            if (
            // A cluster "bubble" is a marker with a child count
            layer instanceof leaflet.Marker &&
                typeof layer.getChildCount === 'function') {
                layer.pmIgnore = true;
                // Disable the leaflet.pm functionality for the cluster bubble
                if (layer.pm) {
                    layer.pm.disable();
                    delete layer.pm;
                }
            }
            return originalAddLayer.call(this, layer);
        };
        this.obj = clusterGroup;
        this.marker_views = new base_2_3_4_5_6_singleton_.ViewList(this.add_layer_model, this.remove_layer_view, this);
        this.marker_views.update(this.model.get('markers'));
    }
}
//# sourceMappingURL=MarkerCluster.js.map
;// ./lib/layers/PMTilesLayer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// protomaps-leaflet does not have typescript definitions


class LeafletPMTilesLayerModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletPMTilesLayerView',
            _model_name: 'LeafletPMTilesLayerModel',
            url: '',
            attribution: '',
            style: {},
        };
    }
}
class LeafletPMTilesLayerView extends LeafletLayerView {
    create_obj() {
        const options = {
            ...this.get_options(),
            url: this.model.get('url'),
            //@ts-ignore
            ...(0,protomaps_leaflet_module_js_.json_style)(this.model.get('style')),
        };
        this.obj = (0,protomaps_leaflet_module_js_.leafletLayer)(options);
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:url', () => {
            this.obj.setUrl(this.model.get('url'));
        });
    }
    handle_message(content) {
        if (content.msg == 'add_inspector') {
            this.obj.addInspector(this.map_view.obj);
        }
    }
}
//# sourceMappingURL=PMTilesLayer.js.map
;// ./lib/layers/Polyline.js


class LeafletPolylineModel extends LeafletPathModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletPolylineView',
            _model_name: 'LeafletPolylineModel',
            locations: [],
            smooth_factor: 1.0,
            no_clip: true,
        };
    }
}
class LeafletPolylineView extends LeafletPathView {
    create_obj() {
        this.obj = leaflet.polyline(this.model.get('locations'), this.get_options());
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:locations', () => {
            this.obj.setLatLngs(this.model.get('locations'));
            if (this.obj.transform) {
                this.obj.transform.reset();
            }
        });
        this.model.on_some_change(['scaling', 'uniform_scaling', 'rotation'], this.update_transform, this);
        this.listenTo(this.model, 'change:draggable', () => {
            if (this.obj.dragging) {
                this.obj.dragging[this.model.get('draggable') ? 'enable' : 'disable']();
            }
        });
        this.listenTo(this.model, 'change:transform', () => {
            if (this.obj.transform) {
                this.obj.transform[this.model.get('transform') ? 'enable' : 'disable']();
            }
        });
    }
    update_transform() {
        if (this.obj.transform) {
            this.obj.transform
                .setOptions({
                scaling: this.model.get('scaling'),
                uniformScaling: this.model.get('uniform_scaling'),
                rotation: this.model.get('rotation'),
            })
                .enable();
        }
    }
}
//# sourceMappingURL=Polyline.js.map
;// ./lib/layers/Polygon.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletPolygonModel extends LeafletPolylineModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletPolygonView',
            _model_name: 'LeafletPolygonModel',
        };
    }
}
class LeafletPolygonView extends LeafletPathView {
    create_obj() {
        this.obj = leaflet.polygon(this.model.get('locations'), this.get_options());
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:locations', () => {
            this.obj.setLatLngs(this.model.get('locations'));
            if (this.obj.transform) {
                this.obj.transform.reset();
            }
        });
        this.model.on_some_change(['scaling', 'uniform_scaling', 'rotation'], this.update_transform, this);
        this.listenTo(this.model, 'change:draggable', () => {
            if (this.obj.dragging) {
                this.obj.dragging[this.model.get('draggable') ? 'enable' : 'disable']();
            }
        });
        this.listenTo(this.model, 'change:transform', () => {
            if (this.obj.transform) {
                this.obj.transform[this.model.get('transform') ? 'enable' : 'disable']();
            }
        });
    }
    update_transform() {
        if (this.obj.transform) {
            this.obj.transform
                .setOptions({
                scaling: this.model.get('scaling'),
                uniformScaling: this.model.get('uniform_scaling'),
                rotation: this.model.get('rotation'),
            })
                .enable();
        }
    }
}
//# sourceMappingURL=Polygon.js.map
;// ./lib/layers/Popup.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





const Popup_DEFAULT_LOCATION = [0.0, 0.0];
class LeafletPopupModel extends LeafletUILayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletPopupView',
            _model_name: 'LeafletPopupModel',
            location: Popup_DEFAULT_LOCATION,
            child: null,
            min_width: 50,
            max_width: 300,
            max_height: null,
        };
    }
}
LeafletPopupModel.serializers = {
    ...LeafletUILayerModel.serializers,
    child: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletPopupView extends LeafletUILayerView {
    create_obj() {
        this.obj = leaflet.popup(this.get_options()).setLatLng(this.model.get('location'));
        this.model.on('msg:custom', this.handle_message.bind(this));
    }
    initialize(parameters) {
        super.initialize(parameters);
        this.child_promise = Promise.resolve();
    }
    render() {
        super.render();
        return this.set_child(this.model.get('child'));
    }
    remove() {
        super.remove();
        this.child_promise.then(() => {
            if (this.child) {
                this.child.remove();
            }
        });
    }
    set_child(value) {
        if (this.child) {
            this.child.remove();
        }
        if (value) {
            this.child_promise = this.child_promise.then(async () => {
                const view = await this.create_child_view(value);
                messaging_2_0_singleton_.MessageLoop.sendMessage(view.pWidget, widgets_2_3_1_alpha_singleton_.Widget.Msg.BeforeAttach);
                this.obj.setContent(view.el);
                messaging_2_0_singleton_.MessageLoop.sendMessage(view.pWidget, widgets_2_3_1_alpha_singleton_.Widget.Msg.AfterAttach);
                this.force_update();
                this.child = view;
                this.trigger('child:created');
            });
        }
        return this.child_promise;
    }
    leaflet_events() {
        super.leaflet_events();
        this.obj.on('add', () => {
            // This is a workaround for making maps rendered correctly in popups
            window.dispatchEvent(new Event('resize'));
        });
    }
    model_events() {
        super.model_events();
        this.model.on('change:child', () => {
            this.set_child(this.model.get('child'));
        });
        this.model.on_some_change(['min_width', 'max_width', 'max_height'], this.update_popup, this);
    }
    update_popup() {
        leaflet.setOptions(this.obj, this.get_options());
        this.force_update();
    }
    force_update() {
        // This is a workaround for enforcing the options update
        if (this.map_view.obj.hasLayer(this.obj)) {
            this.map_view.obj.closePopup(this.obj);
            this.map_view.obj.openPopup(this.obj);
        }
        else {
            this.map_view.obj.openPopup(this.obj);
            this.map_view.obj.closePopup(this.obj);
        }
    }
    handle_message(content) {
        //const objContent = this.obj.getContent();
        // Check that object has actual Content
        if (content.msg == 'open'
        //&& objContent && !(objContent instanceof Function)
        ) {
            // TODO: Using Content object here introduces a bug
            //@ts-ignore
            this.map_view.obj.openPopup(this.obj, content.location);
        }
        else if (content.msg == 'close') {
            this.map_view.obj.closePopup(this.obj);
        }
    }
}
//# sourceMappingURL=Popup.js.map
;// ./lib/layers/Rectangle.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletRectangleModel extends LeafletPolygonModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletRectangleView',
            _model_name: 'LeafletRectangleModel',
            bounds: [],
        };
    }
}
class LeafletRectangleView extends LeafletPolygonView {
    create_obj() {
        this.obj = leaflet.rectangle(this.model.get('bounds'), this.get_options());
    }
}
//# sourceMappingURL=Rectangle.js.map
;// ./lib/layers/VectorTileLayer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletVectorTileLayerModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletVectorTileLayerView',
            _model_name: 'LeafletVectorTileLayerModel',
            url: '',
            vectorTileLayerStyles: {},
            min_zoom: 0,
            max_zoom: 18,
            min_native_zoom: null,
            max_native_zoom: null,
            interactive: false,
            visible: true,
            opacity: 1.0,
            rendererFactory: leaflet.svg.tile,
            getFeatureId: null,
        };
    }
}
class LeafletVectorTileLayerView extends LeafletLayerView {
    async set_vector_tile_layer_styles(options) {
        if ('layerStyles' in options) {
            let x = options['layerStyles'];
            options['vectorTileLayerStyles'] = x;
            if (typeof x === 'string') {
                try {
                    let blobCode = `const jsStyle=${x}; export { jsStyle };`;
                    const blob = new Blob([blobCode], { type: 'text/javascript' });
                    const url = URL.createObjectURL(blob);
                    const module = await import(/* webpackIgnore: true*/ url);
                    const jsStyle = module.jsStyle;
                    options['vectorTileLayerStyles'] = jsStyle;
                }
                catch (error) {
                    options['vectorTileLayerStyles'] = {};
                }
            }
        }
        return options;
    }
    async create_obj() {
        let options = {
            ...this.get_options(),
        };
        if ('featureId' in options) {
            let idVar = options['featureId'];
            options['getFeatureId'] = function (feat) {
                return feat.properties[idVar];
            };
        }
        if ('renderer' in options) {
            let r = options['renderer'];
            if (r === 'canvas') {
                options['rendererFactory'] = leaflet.canvas.tile;
            }
            else {
                options['rendererFactory'] = leaflet.svg.tile;
            }
        }
        options = await this.set_vector_tile_layer_styles(options);
        this.obj = leaflet.vectorGrid.protobuf(this.model.get('url'), options);
        this.model.on('msg:custom', this.handle_message.bind(this));
        if (this.model.get('visible') == false) {
            this.obj.setOpacity(0);
        }
        this.model.on('change:layer_styles', async () => {
            let options = {
                ...this.get_options(),
            };
            options = await this.set_vector_tile_layer_styles(options);
            this.obj.options.vectorTileLayerStyles = options['vectorTileLayerStyles'];
            if (this.model.get('visible') == false) {
                this.obj.setOpacity(0);
            }
            this.obj.redraw();
        });
        this.model.on('change:feature_style', () => {
            const feature_style = this.model.get('feature_style');
            const reset = feature_style['reset'];
            if (reset) {
                this.obj.resetFeatureStyle(feature_style['id']);
            }
            else {
                this.obj.setFeatureStyle(feature_style['id'], feature_style['layerStyle']);
            }
        });
        this.obj.on('click mouseover mouseout', (event) => {
            this.send({
                event: 'interaction',
                type: event.type,
                coordinates: [event.latlng.lat, event.latlng.lng],
                properties: event.propagatedFrom.properties,
                options: event.propagatedFrom.options,
            });
        });
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:url', () => {
            this.obj.setUrl(this.model.get('url'));
        });
        this.listenTo(this.model, 'change:opacity', () => {
            if (this.model.get('visible')) {
                this.obj.setOpacity(this.model.get('opacity'));
            }
        });
        this.listenTo(this.model, 'change:visible', () => {
            if (this.model.get('visible')) {
                this.obj.setOpacity(this.model.get('opacity'));
            }
            else {
                this.obj.setOpacity(0);
            }
        });
    }
    handle_message(content) {
        if (content.msg == 'redraw') {
            this.obj.redraw();
        }
    }
}
//# sourceMappingURL=VectorTileLayer.js.map
;// ./lib/layers/Velocity.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
//leaflet-velocity does not have typescript definitions



class LeafletVelocityModel extends LeafletLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletVelocityView',
            _model_name: 'LeafletVelocityModel',
            displayValues: true,
            displayOptions: {
                velocityType: 'Global Wind',
                position: 'bottomleft',
                emptyString: 'No velocity data',
                angleConvention: 'bearingCW',
                displayPosition: 'bottomleft',
                displayEmptyString: 'No velocity data',
                speedUnit: 'kt',
            },
            data: [],
            minVelocity: 0,
            maxVelocity: 10,
            velocityScale: 0.005,
            colorScale: [],
        };
    }
}
class LeafletVelocityView extends LeafletLayerView {
    create_obj() {
        const options = this.get_options();
        options.data = this.model.get('data');
        //@ts-ignore
        this.obj = L.velocityLayer(options);
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:data', () => {
            const data = this.model.get('data');
            this.obj.setData(data);
        });
        // Separate display_options from the options to perform a shallow copy.
        const key = 'display_options';
        this.listenTo(this.model, 'change:' + key, () => {
            const options = {};
            options[camel_case(key)] = { ...this.model.get(key) };
            (0,leaflet_src_js_.setOptions)(this.obj, options);
        });
    }
}
//# sourceMappingURL=Velocity.js.map
;// ./lib/layers/VideoOverlay.js


const VideoOverlay_DEFAULT_LOCATION = [0.0, 0.0];
class LeafletVideoOverlayModel extends LeafletRasterLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletVideoOverlayView',
            _model_name: 'LeafletVideoOverlayModel',
            url: '',
            bounds: [VideoOverlay_DEFAULT_LOCATION, VideoOverlay_DEFAULT_LOCATION],
            attribution: '',
        };
    }
}
class LeafletVideoOverlayView extends LeafletRasterLayerView {
    create_obj() {
        this.obj = leaflet.videoOverlay(this.model.get('url'), this.model.get('bounds'), this.get_options());
        this.obj.on('load', () => {
            const MyPauseControl = leaflet.Control.extend({
                onAdd: () => {
                    const button = leaflet.DomUtil.create('button');
                    button.innerHTML = '&#10074&#10074';
                    leaflet.DomEvent.on(button, 'click', () => {
                        this.obj.getElement()?.pause();
                    });
                    return button;
                },
            });
            const MyPlayControl = leaflet.Control.extend({
                onAdd: () => {
                    const button = leaflet.DomUtil.create('button');
                    button.innerHTML = '&#9658';
                    leaflet.DomEvent.on(button, 'click', () => {
                        this.obj.getElement()?.play();
                    });
                    return button;
                },
            });
            new MyPauseControl().addTo(this.map_view.obj);
            new MyPlayControl().addTo(this.map_view.obj);
        });
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:url', () => {
            const url = this.model.get('url');
            const bounds = this.model.get('bounds');
            const options = this.get_options();
            this.map_view.obj.removeLayer(this.obj);
            this.obj = leaflet.videoOverlay(url, bounds, options);
            this.map_view.obj.addLayer(this.obj);
        });
        this.listenTo(this.model, 'change:bounds', () => {
            const url = this.model.get('url');
            const bounds = this.model.get('bounds');
            const options = this.get_options();
            this.map_view.obj.removeLayer(this.obj);
            this.obj = leaflet.videoOverlay(url, bounds, options);
            this.map_view.obj.addLayer(this.obj);
        });
    }
}
//# sourceMappingURL=VideoOverlay.js.map
;// ./lib/layers/WMSLayer.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletWMSLayerModel extends LeafletTileLayerModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletWMSLayerView',
            _model_name: 'LeafletWMSLayerModel',
            layers: '',
            styles: '',
            format: 'image/jpeg',
            transparent: false,
            crs: null,
            uppercase: false,
        };
    }
}
class LeafletWMSLayerView extends LeafletTileLayerView {
    create_obj() {
        this.obj = leaflet.tileLayer.wms(this.model.get('url'), {
            ...this.get_options(),
            crs: getProjection(this.model.get('crs')),
        });
    }
    model_events() {
        super.model_events();
        for (let option in this.get_options()) {
            this.model.on('change:' + option, () => {
                this.obj.setParams(this.get_options(), true);
                this.obj.refresh();
            });
        }
    }
}
//# sourceMappingURL=WMSLayer.js.map
;// ./lib/controls/Control.js



class LeafletControlModel extends base_2_3_4_5_6_singleton_.WidgetModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletControlView',
            _model_name: 'LeafletControlModel',
            _view_module: 'jupyter-leaflet',
            _model_module: 'jupyter-leaflet',
            options: [],
            position: 'topleft',
        };
    }
}
class LeafletControlView extends LeafletWidgetView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    async render() {
        await Promise.resolve(this.create_obj());
        this.leaflet_events();
        this.model_events();
    }
    leaflet_events() { }
    model_events() {
        let key;
        const o = this.model.get('options');
        for (let i = 0; i < o.length; i++) {
            key = o[i];
            this.listenTo(this.model, 'change:' + key, () => {
                leaflet.setOptions(this.obj, this.get_options());
            });
        }
    }
}
//# sourceMappingURL=Control.js.map
;// ./lib/controls/AttributionControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletAttributionControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletAttributionControlView',
            _model_name: 'LeafletAttributionControlModel',
        };
    }
}
class LeafletAttributionControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        this.obj = leaflet.control.attribution(this.get_options());
    }
}
//# sourceMappingURL=AttributionControl.js.map
;// ./lib/controls/DrawControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.



class LeafletDrawControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletDrawControlView',
            _model_name: 'LeafletDrawControlModel',
            polyline: { shapeOptions: {} },
            polygon: { shapeOptions: {} },
            circle: {},
            circlemarker: {},
            rectangle: {},
            marker: {},
            data: [],
            edit: true,
            remove: true,
        };
    }
}
LeafletDrawControlModel.serializers = {
    ...LeafletControlModel.serializers,
    layer: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletDrawControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        this.feature_group = leaflet.geoJson([], {
            style: function (feature) {
                return feature?.properties.style;
            },
        });
        this.data_to_layers();
        this.map_view.obj.addLayer(this.feature_group);
        let polyline = this.model.get('polyline');
        if (!Object.keys(polyline).length) {
            polyline = false;
        }
        let polygon = this.model.get('polygon');
        if (!Object.keys(polygon).length) {
            polygon = false;
        }
        let circle = this.model.get('circle');
        if (!Object.keys(circle).length) {
            circle = false;
        }
        let circlemarker = this.model.get('circlemarker');
        if (!Object.keys(circlemarker).length) {
            circlemarker = false;
        }
        let rectangle = this.model.get('rectangle');
        if (!Object.keys(rectangle).length) {
            rectangle = false;
        }
        let marker = this.model.get('marker');
        if (!Object.keys(marker).length) {
            marker = false;
        }
        this.obj = new leaflet.Control.Draw({
            position: this.model.get('position'),
            edit: {
                featureGroup: this.feature_group,
                edit: this.model.get('edit'),
                remove: this.model.get('remove'),
            },
            draw: {
                polyline: polyline,
                polygon: polygon,
                circle: circle,
                circlemarker: circlemarker,
                rectangle: rectangle,
                marker: marker,
            },
        });
        this.map_view.obj.on('draw:created', (e) => {
            const layer = e.layer;
            const geo_json = layer.toGeoJSON();
            geo_json.properties.style = layer.options;
            this.send({
                event: 'draw:created',
                geo_json: geo_json,
            });
            this.feature_group.addLayer(layer);
            this.layers_to_data();
        });
        this.map_view.obj.on('draw:edited', (e) => {
            const layers = e.layers;
            layers.eachLayer((layer) => {
                const geo_json = layer.toGeoJSON();
                geo_json.properties.style = layer.options;
                this.send({
                    event: 'draw:edited',
                    geo_json: geo_json,
                });
            });
            this.layers_to_data();
        });
        this.map_view.obj.on('draw:deleted', (e) => {
            const layers = e.layers;
            layers.eachLayer((layer) => {
                const geo_json = layer.toGeoJSON();
                geo_json.properties.style = layer.options;
                this.send({
                    event: 'draw:deleted',
                    geo_json: geo_json,
                });
            });
            this.layers_to_data();
        });
        this.model.on('msg:custom', this.handle_message.bind(this));
        this.model.on('change:data', this.data_to_layers.bind(this));
    }
    remove() {
        this.map_view.obj.removeLayer(this.feature_group);
        this.map_view.obj.off('draw:created');
        this.map_view.obj.off('draw:edited');
        this.map_view.obj.off('draw:deleted');
        this.model.off('msg:custom');
        this.model.off('change:data');
    }
    data_to_layers() {
        const data = this.model.get('data');
        this.feature_group.clearLayers();
        this.feature_group.addData(data);
    }
    layers_to_data() {
        let newData = [];
        this.feature_group.eachLayer((layer) => {
            const geoJson = layer.toGeoJSON();
            geoJson.properties.style = layer.options;
            newData.push(geoJson);
        });
        this.model.set('data', newData);
        this.model.save_changes();
    }
    handle_message(content) {
        if (content.msg == 'clear') {
            this.feature_group.eachLayer((layer) => {
                this.feature_group.removeLayer(layer);
            });
        }
        else if (content.msg == 'clear_polylines') {
            this.feature_group.eachLayer((layer) => {
                if (layer instanceof leaflet.Polyline && !(layer instanceof leaflet.Polygon)) {
                    this.feature_group.removeLayer(layer);
                }
            });
        }
        else if (content.msg == 'clear_polygons') {
            this.feature_group.eachLayer((layer) => {
                if (layer instanceof leaflet.Polygon && !(layer instanceof leaflet.Rectangle)) {
                    this.feature_group.removeLayer(layer);
                }
            });
        }
        else if (content.msg == 'clear_circles') {
            this.feature_group.eachLayer((layer) => {
                if (layer instanceof leaflet.CircleMarker) {
                    this.feature_group.removeLayer(layer);
                }
            });
        }
        else if (content.msg == 'clear_circle_markers') {
            this.feature_group.eachLayer((layer) => {
                if (layer instanceof leaflet.CircleMarker && !(layer instanceof leaflet.Circle)) {
                    this.feature_group.removeLayer(layer);
                }
            });
        }
        else if (content.msg == 'clear_rectangles') {
            this.feature_group.eachLayer((layer) => {
                if (layer instanceof leaflet.Rectangle) {
                    this.feature_group.removeLayer(layer);
                }
            });
        }
        else if (content.msg == 'clear_markers') {
            this.feature_group.eachLayer((layer) => {
                if (layer instanceof leaflet.Marker) {
                    this.feature_group.removeLayer(layer);
                }
            });
        }
        this.layers_to_data();
    }
}
//# sourceMappingURL=DrawControl.js.map
// EXTERNAL MODULE: ./node_modules/leaflet/dist/leaflet.css
var dist_leaflet = __webpack_require__(3872);
// EXTERNAL MODULE: consume shared module (default) @geoman-io/leaflet-geoman-free@^2.18.0 (strict) (fallback: ./node_modules/@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.js)
var leaflet_geoman_js_ = __webpack_require__(4612);
// EXTERNAL MODULE: ./node_modules/@geoman-io/leaflet-geoman-free/dist/leaflet-geoman.css
var leaflet_geoman = __webpack_require__(1052);
;// ./lib/controls/GeomanDrawControl.js






class LeafletGeomanDrawControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletGeomanDrawControlView',
            _model_name: 'LeafletGeomanDrawControlModel',
            current_mode: null,
            hide_controls: false,
            data: [],
            marker: {},
            circlemarker: { pathOptions: {} },
            circle: {},
            polyline: { pathOptions: {} },
            rectangle: {},
            polygon: { pathOptions: {} },
            text: {},
            edit: true,
            drag: false,
            remove: true,
            cut: false,
            rotate: false,
            // TODO enable limit markers
            // limitMarkersToCount: -1,
        };
    }
}
LeafletGeomanDrawControlModel.serializers = {
    ...LeafletControlModel.serializers,
    layer: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletGeomanDrawControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        const model = this.model;
        this.setControlOptions();
        this.feature_group = leaflet.geoJson([], {
            style: function (feature) {
                if (feature?.properties != undefined) {
                    return feature.properties.style;
                }
                else {
                    return {};
                }
            },
            pointToLayer: function (feature, latlng) {
                let options;
                if (feature?.properties?.style?.textMarker) {
                    options = {
                        textMarker: feature.properties.style.textMarker,
                        text: feature.properties.style.text,
                    };
                }
                else {
                    options = feature.properties?.options;
                }
                switch (feature.properties.type) {
                    case 'marker':
                        if (!options) {
                            options = model.get('marker')?.markerStyle;
                        }
                        return new leaflet.Marker(latlng, options);
                    case 'circle':
                        return new leaflet.Circle(latlng, feature.properties.style.radius, options);
                    case 'circlemarker':
                        if (!options) {
                            options = model.get('circlemarker')?.pathOptions;
                        }
                        return new leaflet.CircleMarker(latlng, options);
                    // Below might work funny sometimes?
                    // TODO: Check
                    default:
                        return new leaflet.Marker(latlng, options);
                }
            },
        });
        // Click event handler
        this.feature_group.on('click', (e) => {
            this.send({
                event: 'click',
                geo_json: this.layer_to_json(e.sourceTarget),
                latlng: e.latlng,
            });
        });
        // Hover style
        this.feature_group.on('mouseover', (e) => {
            const layer = e.sourceTarget;
            layer.setStyle(this.model.get('hover_style'));
            layer.once('mouseout', () => {
                this.feature_group.resetStyle(layer);
            });
        });
        this.data_to_layers();
        this.map_view.obj.addLayer(this.feature_group);
        this.setMode();
        this.map_view.obj.on('pm:create', (e) => {
            var layer = e.layer;
            this.send({
                event: 'pm:create',
                geo_json: this.layer_to_json(layer),
            });
            // Without this, the text layer will not be editable after creation. We only create the layer after
            // the text has been edited.
            if (e.shape === 'Text') {
                if (!layer.pm.enabled())
                    layer.pm.enable();
                layer.pm.focus();
                layer.on('pm:textblur', (e) => {
                    this.send({
                        event: 'pm:textchange',
                        geo_json: this.layer_to_json(layer),
                    });
                    this.feature_group.addLayer(layer);
                    this.layers_to_data();
                    this.model.save_changes();
                });
                return;
            }
            this.feature_group.addLayer(layer);
            this.layers_to_data();
            this.model.save_changes();
        });
        this.map_view.obj.on('pm:remove', (e) => {
            var eventLayer = e.layer;
            this.feature_group.removeLayer(eventLayer);
            this.send({
                event: 'pm:remove',
                geo_json: this.layer_to_json(eventLayer),
            });
            this.layers_to_data();
        });
        this.map_view.obj.on('pm:cut', (e) => {
            var eventLayer = e.layer;
            // since cut returns original layer and new layer, we treat it differently
            var geo_json = [];
            this.feature_group.eachLayer((layer) => {
                if (layer._leaflet_id == e.originalLayer._leaflet_id) {
                    this.feature_group.removeLayer(layer);
                }
                else {
                    geo_json.push(this.layer_to_json(layer));
                }
            });
            this.feature_group.addLayer(eventLayer);
            geo_json.push(this.layer_to_json(eventLayer));
            this.send({
                event: 'pm:cut',
                geo_json: geo_json,
            });
            this.layers_to_data();
        });
        this.map_view.obj.on('pm:rotateend', (e) => {
            var eventLayer = e.layer;
            this.event_to_json('pm:rotateend', eventLayer);
            this.layers_to_data();
        });
        // add listeners for syncing modes
        this.map_view.obj.on('pm:globaldrawmodetoggled', (e) => {
            if (e.enabled &&
                this.model.get('current_mode') != null &&
                this.model.get('current_mode').split(':')[0] != 'draw') {
                this.model.set('current_mode', 'draw:' + e.shape);
                this.setMode();
            }
        });
        this.map_view.obj.on('pm:globaleditmodetoggled', (e) => {
            if (e.enabled && this.model.get('current_mode') != 'edit') {
                this.model.set('current_mode', 'edit');
                this.setMode();
            }
        });
        this.map_view.obj.on('pm:globaldragmodetoggled', (e) => {
            if (e.enabled && this.model.get('current_mode') != 'drag') {
                this.model.set('current_mode', 'drag');
                this.setMode();
            }
        });
        this.map_view.obj.on('pm:globalremovalmodetoggled', (e) => {
            if (e.enabled && this.model.get('current_mode') != 'remove') {
                this.model.set('current_mode', 'remove');
                this.setMode();
            }
        });
        this.map_view.obj.on('pm:globalcutmodetoggled', (e) => {
            if (e.enabled && this.model.get('current_mode') != 'cut') {
                this.model.set('current_mode', 'cut');
                this.setMode();
            }
        });
        this.map_view.obj.on('pm:globalrotatemodetoggled', (e) => {
            if (e.enabled && this.model.get('current_mode') != 'rotate') {
                this.model.set('current_mode', 'rotate');
                this.setMode();
            }
        });
        this.model.on('change:current_mode', this.setMode.bind(this));
        this.model.on('msg:custom', this.handle_message.bind(this));
        this.model.on('change:data', this.data_to_layers.bind(this));
        this.obj = this;
    }
    setControlOptions() {
        var position = this.model.get('position');
        var drawMarker = this.model.get('marker');
        if (!Object.keys(drawMarker).length) {
            drawMarker = false;
        }
        else {
            // For backwards compatibility
            if ('shapeOptions' in drawMarker) {
                drawMarker.markerOptions = drawMarker.shapeOptions;
                delete drawMarker.shapeOptions;
            }
            this.map_view.obj.pm.Draw.Marker.setOptions(drawMarker);
        }
        var drawCircleMarker = this.model.get('circlemarker');
        if (!Object.keys(drawCircleMarker).length) {
            drawCircleMarker = false;
        }
        else {
            if ('shapeOptions' in drawCircleMarker) {
                drawCircleMarker.pathOptions = drawCircleMarker.shapeOptions;
                delete drawCircleMarker.shapeOptions;
            }
            this.map_view.obj.pm.Draw.CircleMarker.setOptions(drawCircleMarker);
        }
        var drawCircle = this.model.get('circle');
        if (!Object.keys(drawCircle).length) {
            drawCircle = false;
        }
        else {
            if ('shapeOptions' in drawCircle) {
                drawCircle.pathOptions = drawCircle.shapeOptions;
                delete drawCircle.shapeOptions;
            }
            this.map_view.obj.pm.Draw.Circle.setOptions(drawCircle);
        }
        var drawPolyline = this.model.get('polyline');
        if (!Object.keys(drawPolyline).length) {
            drawPolyline = false;
        }
        else {
            if ('shapeOptions' in drawPolyline) {
                drawPolyline.pathOptions = drawPolyline.shapeOptions;
                delete drawPolyline.shapeOptions;
            }
            this.map_view.obj.pm.Draw.Line.setOptions(drawPolyline);
        }
        var drawRectangle = this.model.get('rectangle');
        if (!Object.keys(drawRectangle).length) {
            drawRectangle = false;
        }
        else {
            if ('shapeOptions' in drawRectangle) {
                drawRectangle.pathOptions = drawRectangle.shapeOptions;
                delete drawRectangle.shapeOptions;
            }
            this.map_view.obj.pm.Draw.Rectangle.setOptions(drawRectangle);
        }
        var drawPolygon = this.model.get('polygon');
        if (!Object.keys(drawPolygon).length) {
            drawPolygon = false;
        }
        else {
            if ('shapeOptions' in drawPolygon) {
                drawPolygon.pathOptions = drawPolygon.shapeOptions;
                delete drawPolygon.shapeOptions;
            }
            this.map_view.obj.pm.Draw.Polygon.setOptions(drawPolygon);
        }
        var drawText = this.model.get('text');
        if (!Object.keys(drawText).length) {
            drawText = false;
        }
        var editMode = this.model.get('edit');
        var dragMode = this.model.get('drag');
        var removalMode = this.model.get('remove');
        var cutMode = this.model.get('cut');
        var rotateMode = this.model.get('rotate');
        this.controlOptions = {
            position: position,
            drawMarker: !(drawMarker == false),
            drawCircleMarker: !(drawCircleMarker == false),
            drawCircle: !(drawCircle == false),
            drawPolyline: !(drawPolyline == false),
            drawRectangle: !(drawRectangle == false),
            drawPolygon: !(drawPolygon == false),
            drawText: !(drawText == false),
            editMode: editMode,
            dragMode: dragMode,
            removalMode: removalMode,
            cutPolygon: cutMode,
            rotateMode: rotateMode,
        };
    }
    remove() {
        this.map_view.obj.off('pm:create');
        this.map_view.obj.off('pm:remove');
        this.map_view.obj.off('pm:cut');
        this.map_view.obj.off('pm:rotateend');
        this.model.off('msg:custom');
        this.model.off('change:data');
        this.map_view.obj.pm.removeControls();
        this.map_view.obj.removeLayer(this.feature_group);
        // this.map_view.obj.off('moveend');
        return this;
    }
    setMode() {
        var mode = this.model.get('current_mode');
        if (mode == null) {
            const currentShape = this.map_view.obj.pm.Draw.getActiveShape();
            if (currentShape) {
                this.map_view.obj.pm.disableDraw(currentShape);
            }
        }
        else if (mode.split(':').length > 1) {
            mode = mode.split(':')[1];
            this.map_view.obj.pm.enableDraw(mode, this.model.get(mode.toLowerCase()));
        }
        else if (mode == 'edit') {
            this.map_view.obj.pm.enableGlobalEditMode();
        }
        else if (mode == 'drag') {
            this.map_view.obj.pm.enableGlobalDragMode();
        }
        else if (mode == 'remove') {
            this.map_view.obj.pm.enableGlobalRemovalMode();
        }
        else if (mode == 'cut') {
            this.map_view.obj.pm.enableDraw('Cut');
        }
        else if (mode == 'rotate') {
            this.map_view.obj.pm.enableGlobalRotateMode();
        }
    }
    properties_type(layer) {
        switch (layer.constructor) {
            case leaflet.Rectangle:
                return 'rectangle';
            case leaflet.Circle:
                return 'circle';
            case leaflet.CircleMarker:
                return 'circlemarker';
            case leaflet.Polygon:
                return 'polygon';
            case leaflet.Polyline:
                return 'polyline';
            case leaflet.Marker:
                return 'marker';
        }
    }
    layer_to_json(layer) {
        var geo_json = layer.toGeoJSON();
        if (geo_json.properties == undefined) {
            geo_json.properties = {};
        }
        geo_json.properties.style = layer.options;
        geo_json.properties.type = this.properties_type(layer);
        return geo_json;
    }
    event_to_json(eventName, eventLayer) {
        var geo_json = [];
        this.feature_group.eachLayer((layer) => {
            if (layer._leaflet_id == eventLayer._leaflet_id) {
                geo_json.push(this.layer_to_json(eventLayer));
            }
            else {
                geo_json.push(this.layer_to_json(layer));
            }
        });
        this.send({
            event: eventName,
            geo_json: geo_json,
        });
    }
    data_to_layers() {
        const data = this.model.get('data');
        this.feature_group.clearLayers();
        this.feature_group.addData(data);
        // We add event listeners here, since these need to be added on a
        // per-layer basis.
        this.feature_group.eachLayer((layer) => {
            layer.on('pm:vertexadded', (e) => {
                var eventLayer = e.layer;
                this.event_to_json('pm:vertexadded', eventLayer);
                this.layers_to_data();
            });
            layer.on('pm:vertexremoved', (e) => {
                var eventLayer = e.layer;
                this.event_to_json('pm:vertexremoved', eventLayer);
                this.layers_to_data();
            });
            layer.on('pm:markerdragend', (e) => {
                var eventLayer = e.layer;
                this.event_to_json('pm:vertexdrag', eventLayer);
                this.layers_to_data();
            });
            layer.on('pm:dragend', (e) => {
                var eventLayer = e.layer;
                this.event_to_json('pm:drag', eventLayer);
                this.layers_to_data();
            });
            layer.on('pm:textblur', (e) => {
                var eventLayer = e.layer;
                this.event_to_json('pm:textchange', eventLayer);
                this.layers_to_data();
            });
        });
    }
    layers_to_data() {
        let newData = [];
        this.feature_group.eachLayer((layer) => {
            if (layer._pmTempLayer) {
                this.feature_group.removeLayer(layer);
            }
            else {
                const geoJson = layer.toGeoJSON();
                if (geoJson.properties == undefined) {
                    geoJson.properties = {};
                }
                // Sanitize layer options for serialization via `structuredClone`:
                // https://web.dev/structured-clone/#features-and-limitations
                const sanitizedLayerOptions = JSON.parse(JSON.stringify(layer.options));
                geoJson.properties.style = sanitizedLayerOptions;
                geoJson.properties.type = this.properties_type(layer);
                newData.push(geoJson);
            }
        });
        this.model.set('data', newData);
        this.model.save_changes();
    }
    handle_message(content) {
        switch (content.msg) {
            case 'clear': {
                this.feature_group.eachLayer((layer) => {
                    this.feature_group.removeLayer(layer);
                });
                break;
            }
            case 'clear_polygons': {
                this.feature_group.eachLayer((layer) => {
                    if (layer instanceof leaflet.Polygon && !(layer instanceof leaflet.Rectangle)) {
                        this.feature_group.removeLayer(layer);
                    }
                });
                break;
            }
            case 'clear_polylines': {
                this.feature_group.eachLayer((layer) => {
                    if (layer instanceof leaflet.Polyline && !(layer instanceof leaflet.Polygon)) {
                        this.feature_group.removeLayer(layer);
                    }
                });
                break;
            }
            case 'clear_circles': {
                this.feature_group.eachLayer((layer) => {
                    if (layer instanceof leaflet.CircleMarker) {
                        this.feature_group.removeLayer(layer);
                    }
                });
                break;
            }
            case 'clear_circle_markers': {
                this.feature_group.eachLayer((layer) => {
                    if (layer instanceof leaflet.CircleMarker && !(layer instanceof leaflet.Circle)) {
                        this.feature_group.removeLayer(layer);
                    }
                });
                break;
            }
            case 'clear_rectangles': {
                this.feature_group.eachLayer((layer) => {
                    if (layer instanceof leaflet.Rectangle) {
                        this.feature_group.removeLayer(layer);
                    }
                });
                break;
            }
            case 'clear_markers': {
                this.feature_group.eachLayer((layer) => {
                    if ((layer instanceof leaflet.Marker && !layer.options.textMarker) ||
                        layer instanceof leaflet.CircleMarker) {
                        this.feature_group.removeLayer(layer);
                    }
                });
                break;
            }
            case 'clear_text': {
                this.feature_group.eachLayer((layer) => {
                    if (layer instanceof leaflet.Marker && layer.options.textMarker) {
                        this.feature_group.removeLayer(layer);
                    }
                });
                break;
            }
        }
        this.layers_to_data();
    }
    model_events() {
        super.model_events();
        // Geoman needs to be forced to update by removing and re-adding the control
        // toolbar with the new options set. Ignore attrs that are not options.
        const excluded_keys = ['current_mode'];
        for (let key in this.model.attributes) {
            if (!(key.startsWith('_') || excluded_keys.includes(key))) {
                this.listenTo(this.model, 'change:' + key, () => {
                    this.setControlOptions();
                    this.map_view.obj.pm.removeControls();
                    if (!this.model.get('hide_controls')) {
                        this.map_view.obj.pm.addControls(this.controlOptions);
                    }
                });
            }
        }
    }
    getPosition() {
        return this.options.position;
    }
    setPosition(position) {
        this.setControlOptions();
        this.map_view.obj.pm.removeControls();
        if (!this.model.get('hide_controls')) {
            this.map_view.obj.pm.addControls(this.controlOptions);
        }
        return this;
    }
    getContainer() {
        return this.map_view.obj;
    }
    addTo(map) {
        if (!this.model.get('hide_controls')) {
            map.pm.addControls(this.controlOptions);
        }
        return this;
    }
}
//# sourceMappingURL=GeomanDrawControl.js.map
;// ./lib/controls/FullScreenControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletFullScreenControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletFullScreenControlView',
            _model_name: 'LeafletFullScreenControlModel',
        };
    }
}
class LeafletFullScreenControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        //@ts-ignore
        this.obj = leaflet.control.fullscreen(this.get_options());
    }
}
//# sourceMappingURL=FullScreenControl.js.map
;// ./lib/controls/LayersControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletLayersControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletLayersControlView',
            _model_name: 'LeafletLayersControlModel',
        };
    }
}
class LeafletLayersControlView extends LeafletControlView {
    /**
     * Core leaflet layers control maintains its own list of layers internally
     * causing issues when the layers of the underlying map changes
     * exogeneously, for example from a model change.
     *
     * For this reason, upon change of the underlying list of layers, we
     * destroy the layers control object and create a new one.
     */
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    toggle_obj() {
        if (this.obj) {
            this.obj.remove();
            //@ts-ignore
            delete this.obj;
            this.create_obj();
        }
    }
    model_events() {
        this.listenTo(this.map_view.model, 'change:layers', () => {
            this.toggle_obj();
        });
    }
    async create_obj() {
        const views = await Promise.all(this.map_view.layer_views.views);
        let baselayers = views.reduce((ov, view) => {
            if (view.model.get('base')) {
                ov[view.model.get('name')] = view.obj;
            }
            return ov;
        }, {});
        let overlays = views.reduce((ov_1, view_1) => {
            if (!view_1.model.get('base')) {
                ov_1[view_1.model.get('name')] = view_1.obj;
            }
            return ov_1;
        }, {});
        this.obj = leaflet.control.layers(baselayers, overlays, this.get_options());
        this;
        this.obj.addTo(this.map_view.obj);
    }
}
//# sourceMappingURL=LayersControl.js.map
;// ./lib/controls/LegendControl.js


leaflet.Control.Legend = leaflet.Control.extend({
    options: {
        position: 'bottomright',
    },
});
leaflet.control.legend = function (options) {
    return new leaflet.Control.Legend(options);
};
class LeafletLegendControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletLegendControlView',
            _model_name: 'LeafletLegendControlModel',
            title: 'Legend',
            legend: {
                'value 1': '#AAF',
                'value 2': '#55A',
                'value 3': '#005',
            },
            position: 'bottomright',
        };
    }
}
class LeafletLegendControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    async render() {
        this.create_obj();
        this.model.on('change:title', this.titleChanged, this);
        this.model.on('change:position', this.positionChanged, this);
        this.model.on('change:legend', this.legendChanged, this);
    }
    create_obj() {
        let jsLegend = leaflet.control.legend({ position: this.model.get('position') });
        jsLegend.onAdd = () => {
            let jsLegendName = 'leaflet-control-legend';
            let container = leaflet.DomUtil.create('div', jsLegendName);
            this.addContent(container);
            return container;
        };
        this.obj = jsLegend;
    }
    legendChanged() {
        let container = this.obj.getContainer();
        if (container) {
            leaflet.DomUtil.empty(container);
            this.addContent(container);
        }
    }
    positionChanged() {
        this.obj.setPosition(this.model.get('position'));
    }
    titleChanged() {
        let container = this.obj.getContainer();
        let titleContainer = container?.getElementsByTagName('h4')[0];
        if (titleContainer) {
            titleContainer.textContent = this.model.get('title');
        }
    }
    addContent(container) {
        let titleContainer = document.createElement('h4');
        titleContainer.textContent = this.model.get('title');
        container.appendChild(titleContainer);
        let legend = this.model.get('legend');
        for (let legendElement in legend) {
            let icon = document.createElement('i');
            icon.style.backgroundColor = legend[legendElement];
            container.appendChild(icon);
            container.innerHTML += `<p>${legendElement} </p></br>`;
        }
    }
}
//# sourceMappingURL=LegendControl.js.map
;// ./lib/controls/MeasureControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// leaflet-measure does not have typescript definitions


class LeafletMeasureControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletMeasureControlView',
            _model_name: 'LeafletMeasureControlModel',
            primary_length_unit: 'feet',
            secondary_length_unit: undefined,
            primary_area_unit: 'acres',
            secondar_area_unit: undefined,
            active_color: '#ABE67E',
            completed_color: '#C8F2BE',
            popup_options: {
                className: 'leaflet-measure-resultpopup',
                autoPanPadding: [10, 10],
            },
            capture_z_index: 10000,
            _custom_units: {},
        };
    }
}
class LeafletMeasureControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        //@ts-ignore
        this.obj = leaflet.control.measure(this.get_options());
        this.default_units = leaflet.extend({}, this.obj.options.units);
    }
    get_measure_control_options() {
        const options = this.get_options();
        options['units'] = leaflet.extend({}, this.default_units, this.model.get('_custom_units'));
        return options;
    }
    model_events() {
        let key;
        const o = this.model.get('options');
        for (let i = 0; i < o.length; i++) {
            key = o[i];
            this.listenTo(this.model, 'change:' + key, () => {
                // Workaround for https://github.com/ljagis/leaflet-measure/issues/112
                // and https://github.com/ljagis/leaflet-measure/issues/113
                // Once fixed, the next line should be replaced by: L.setOptions(this.obj, this.get_options());
                this.obj.initialize(this.get_measure_control_options());
            });
        }
    }
}
//# sourceMappingURL=MeasureControl.js.map
;// ./lib/controls/ScaleControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletScaleControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletScaleControlView',
            _model_name: 'LeafletScaleControlModel',
        };
    }
}
class LeafletScaleControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        this.obj = leaflet.control.scale(this.get_options());
    }
}
//# sourceMappingURL=ScaleControl.js.map
;// ./lib/controls/SearchControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// leaflet-search does not have typescript definitions



class LeafletSearchControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletSearchControlView',
            _model_name: 'LeafletSearchControlModel',
            url: null,
            jsonp_param: 'json_callback',
            property_name: 'display_name',
            property_loc: ['lat', 'lon'],
            auto_type: false,
            auto_collapse: false,
            zoom: null,
            animate_location: false,
            found_style: { fillColor: '#3f0', color: '#0f0' },
            marker: null,
            layer: null,
        };
    }
}
LeafletSearchControlModel.serializers = {
    ...LeafletControlModel.serializers,
    marker: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
    layer: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletSearchControlView extends LeafletControlView {
    async create_obj() {
        const layer = this.model.get('layer');
        const marker = this.model.get('marker');
        const layer_promise = layer !== null ? this.create_child_view(layer) : Promise.resolve(null);
        const marker_promise = marker !== null ? this.create_child_view(marker) : Promise.resolve(null);
        const result = await Promise.all([layer_promise, marker_promise]);
        const layer_view = result[0];
        const marker_view = result[1];
        const options = this.get_options();
        options.layer = layer_view !== null ? layer_view.obj : null;
        options.marker = marker_view !== null ? marker_view.obj : false;
        //@ts-ignore
        this.obj = leaflet.control.search(options);
    }
    leaflet_events() {
        this.obj.on('search:locationfound', (e) => {
            if (e.layer !== null) {
                const found_style = this.model.get('found_style');
                e.layer.setStyle(found_style);
                if (e.layer._popup) {
                    e.layer.openPopup();
                }
            }
            this.send({
                event: 'locationfound',
                text: e.text,
                feature: e.layer !== null ? e.layer.feature : null,
                location: [e.latlng.lat, e.latlng.lng],
            });
        });
    }
}
//# sourceMappingURL=SearchControl.js.map
;// ./lib/controls/SplitMapControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// leaflet-splitmap does not have typescript definitions



class LeafletSplitMapControlModel extends LeafletControlModel {
    default() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletSplitMapControlView',
            _model_name: 'LeafletSplitMapControlModel',
            left_layer: undefined,
            right_layer: undefined,
        };
    }
}
LeafletSplitMapControlModel.serializers = {
    ...LeafletControlModel,
    left_layer: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
    right_layer: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
function asArray(arg) {
    return Array.isArray(arg) ? arg : [arg];
}
class LeafletSplitMapControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        const left_models = asArray(this.model.get('left_layer'));
        const right_models = asArray(this.model.get('right_layer'));
        let layersModel = this.map_view.model.get('layers');
        layersModel = layersModel.concat(left_models, right_models);
        return this.map_view.layer_views.update(layersModel).then((views) => {
            const left_views = [];
            const right_views = [];
            views.forEach((view) => {
                if (left_models.includes(view.model)) {
                    left_views.push(view.obj);
                }
                if (right_models.includes(view.model)) {
                    right_views.push(view.obj);
                }
            });
            //@ts-ignore
            this.obj = leaflet.control.splitMap(left_views, right_views);
        });
    }
}
//# sourceMappingURL=SplitMapControl.js.map
;// ./lib/controls/WidgetControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.





class WidgetControl extends leaflet.Control {
    updateLayout(options) {
        if (!this._container) {
            return;
        }
        Object.keys(options).forEach((option) => {
            this._container.style[option] = options[option] + 'px';
        });
    }
    getContent() {
        return this._content;
    }
    setContent(content) {
        if (!this._map) {
            return;
        }
        this._content = content;
        this._container.appendChild(this._content);
        return this;
    }
    onAdd() {
        if (this.options.transparentBg)
            this._container = leaflet.DomUtil.create('div');
        else
            this._container = leaflet.DomUtil.create('div', 'leaflet-widgetcontrol');
        leaflet.DomEvent.disableClickPropagation(this._container);
        leaflet.DomEvent.disableScrollPropagation(this._container);
        return this._container;
    }
}
//@ts-ignore
leaflet.Control.WidgetControl = WidgetControl;
//@ts-ignore
leaflet.control.widgetcontrol = function (options) {
    //@ts-ignore
    return new leaflet.Control.WidgetControl(options);
};
class LeafletWidgetControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletWidgetControlView',
            _model_name: 'LeafletWidgetControlModel',
            widget: null,
            max_width: null,
            min_width: null,
            max_height: null,
            min_height: null,
            transparent_bg: false,
        };
    }
}
LeafletWidgetControlModel.serializers = {
    ...LeafletControlModel.serializers,
    widget: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletWidgetControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
        this.widget_view = undefined;
    }
    set_widget(widget_model) {
        if (this.widget_view) {
            this.widget_view.remove();
            this.widget_view = undefined;
        }
        if (widget_model) {
            return this.create_child_view(widget_model).then((view) => {
                this.widget_view = view;
                // Trigger the displayed event of the child view.
                this.displayed.then(() => {
                    this.widget_view.trigger('displayed', this);
                    this.widget_view.displayed.then(() => {
                        this.updateLayout();
                        messaging_2_0_singleton_.MessageLoop.sendMessage(view.pWidget, widgets_2_3_1_alpha_singleton_.Widget.Msg.BeforeAttach);
                        this.obj.setContent(view.el);
                        messaging_2_0_singleton_.MessageLoop.sendMessage(view.pWidget, widgets_2_3_1_alpha_singleton_.Widget.Msg.AfterAttach);
                    });
                });
            });
        }
    }
    create_obj() {
        //@ts-ignore
        this.obj = leaflet.control.widgetcontrol(this.get_options());
        this.set_widget(this.model.get('widget'));
    }
    model_events() {
        super.model_events();
        this.listenTo(this.model, 'change:min_width change:min_height change:max_width change:max_height', () => {
            this.updateLayout();
        });
        this.listenTo(this.model, 'change:widget', () => {
            this.set_widget(this.model.get('widget'));
        });
    }
    updateLayout() {
        this.obj.updateLayout({
            maxWidth: this.model.get('max_width'),
            minWidth: this.model.get('min_width'),
            maxHeight: this.model.get('max_height'),
            minHeight: this.model.get('min_height'),
        });
    }
}
//# sourceMappingURL=WidgetControl.js.map
;// ./lib/controls/ZoomControl.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.


class LeafletZoomControlModel extends LeafletControlModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletZoomControlView',
            _model_name: 'LeafletZoomControlModel',
            zoom_in_text: '+',
            zoom_in_title: 'Zoom in',
            zoom_out_text: '-',
            zoom_out_title: 'Zoom out',
        };
    }
}
class LeafletZoomControlView extends LeafletControlView {
    initialize(parameters) {
        super.initialize(parameters);
        this.map_view = this.options.map_view;
    }
    create_obj() {
        this.obj = leaflet.control.zoom(this.get_options());
    }
}
//# sourceMappingURL=ZoomControl.js.map
;// ./lib/Map.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




const Map_DEFAULT_LOCATION = [0.0, 0.0];
class LeafletMapStyleModel extends base_2_3_4_5_6_singleton_.StyleModel {
    defaults() {
        return {
            ...super.defaults(),
            _model_name: 'LeafletMapStyleModel',
            _model_module: 'jupyter-leaflet',
        };
    }
}
LeafletMapStyleModel.styleProperties = {
    cursor: {
        selector: '.leaflet-grab',
        attribute: 'cursor',
        default: 'grab',
    },
};
class LeafletMapModel extends base_2_3_4_5_6_singleton_.DOMWidgetModel {
    defaults() {
        return {
            ...super.defaults(),
            _view_name: 'LeafletMapView',
            _model_name: 'LeafletMapModel',
            _model_module: 'jupyter-leaflet',
            _view_module: 'jupyter-leaflet',
            center: Map_DEFAULT_LOCATION,
            zoom: 12,
            max_zoom: null,
            min_zoom: null,
            dragging: true,
            touch_zoom: true,
            zoom_delta: 1,
            zoom_snap: 1,
            scroll_wheel_zoom: false,
            double_click_zoom: true,
            box_zoom: true,
            tap: true,
            tap_tolerance: 15,
            world_copy_jump: false,
            close_popup_on_click: true,
            bounce_at_zoom_limits: true,
            keyboard: true,
            keyboard_pan_offset: 80,
            keyboard_zoom_offset: 1,
            inertia: true,
            inertia_deceleration: 3000,
            inertia_max_speed: 1500,
            // inertia_threshold : int(?)
            // fade_animation : bool(?),
            // zoom_animation : bool(?),
            zoom_animation_threshold: 4,
            // marker_zoom_animation : bool(?),
            south: Map_DEFAULT_LOCATION[0],
            north: Map_DEFAULT_LOCATION[0],
            east: Map_DEFAULT_LOCATION[1],
            west: Map_DEFAULT_LOCATION[1],
            bottom: 0,
            top: 9007199254740991,
            right: 0,
            left: 9007199254740991,
            options: [],
            panes: {},
            layers: [],
            controls: [],
            crs: {
                name: 'EPSG3857',
                custom: false,
            },
            style: null,
            default_style: null,
            dragging_style: null,
        };
    }
    initialize(attributes, options) {
        super.initialize(attributes, options);
        this.set('window_url', window.location.href);
        this._dragging = false;
    }
    update_style() {
        let new_style;
        if (!this._dragging) {
            new_style = this.get('default_style');
        }
        else {
            new_style = this.get('dragging_style');
        }
        this.set('style', new_style);
    }
    async update_bounds() {
        const views = await (0,base_2_3_4_5_6_singleton_.resolvePromisesDict)(this.views);
        // default bounds if the projection is latlng
        let bounds = {
            north: -90,
            south: 90,
            east: -Infinity,
            west: Infinity,
        };
        let pixel_bounds = {
            top: 9007199254740991,
            bottom: 0,
            right: 0,
            left: 9007199254740991,
        };
        [bounds, pixel_bounds] = Object.keys(views).reduce(function (bnds_pixbnds, key) {
            const bnds = bnds_pixbnds[0];
            const pixbnds = bnds_pixbnds[1];
            const currentView = views[key];
            if (currentView?.obj) {
                const view_bounds = currentView.obj.getBounds();
                bnds.north = Math.max(bnds.north, view_bounds.getNorth());
                bnds.south = Math.min(bnds.south, view_bounds.getSouth());
                bnds.east = Math.max(bnds.east, view_bounds.getEast());
                bnds.west = Math.min(bnds.west, view_bounds.getWest());
                const view_pixel_bounds = currentView.obj.getPixelBounds();
                const top_left = view_pixel_bounds.getTopLeft();
                const bottom_right = view_pixel_bounds.getBottomRight();
                pixbnds.top = Math.min(pixbnds.top, top_left.y);
                pixbnds.bottom = Math.max(pixbnds.bottom, bottom_right.y);
                pixbnds.right = Math.max(pixbnds.right, bottom_right.x);
                pixbnds.left = Math.min(pixbnds.left, top_left.x);
            }
            return [bnds, pixbnds];
        }, [bounds, pixel_bounds]);
        this.set('north', bounds.north);
        this.set('south', bounds.south);
        this.set('east', bounds.east);
        this.set('west', bounds.west);
        this.set('top', pixel_bounds.top);
        this.set('bottom', pixel_bounds.bottom);
        this.set('right', pixel_bounds.right);
        this.set('left', pixel_bounds.left);
    }
}
LeafletMapModel.serializers = {
    ...base_2_3_4_5_6_singleton_.DOMWidgetModel.serializers,
    layers: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
    controls: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
    style: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
    default_style: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
    dragging_style: { deserialize: base_2_3_4_5_6_singleton_.unpack_models },
};
class LeafletMapView extends LeafletDOMWidgetView {
    initialize(options) {
        super.initialize(options);
        // The dirty flag is used to prevent sub-pixel center changes
        // computed by leaflet to be applied to the model.
        this.dirty = false;
    }
    create_panes() {
        const panes = this.model.get('panes');
        for (const name in panes) {
            const pane = this.obj.createPane(name);
            const styles = panes[name];
            for (const key in styles) {
                pane.style[key] = styles[key];
            }
        }
    }
    remove_layer_view(child_view) {
        this.obj.removeLayer(child_view.obj);
        child_view.remove();
    }
    async add_layer_model(child_model) {
        const view = await this.create_child_view(child_model, {
            map_view: this,
        });
        this.obj.addLayer(view.obj);
        this.displayed.then(() => {
            view.trigger('displayed', this);
        });
        return view;
    }
    remove_control_view(child_view) {
        child_view.remove();
        this.obj.removeControl(child_view.obj);
    }
    async add_control_model(child_model) {
        const view = await this.create_child_view(child_model, {
            map_view: this,
        });
        this.obj.addControl(view.obj);
        // Trigger the displayed event of the child view.
        this.displayed.then(() => {
            view.trigger('displayed', this);
        });
        return view;
    }
    render() {
        super.render();
        this.el.classList.add('jupyter-widgets');
        this.el.classList.add('leaflet-widgets');
        this.map_container = document.createElement('div');
        this.map_child = this.el.appendChild(this.map_container);
        if (this.get_options().interpolation == 'nearest') {
            this.map_container.classList.add('crisp-image');
        }
        this.layer_views = new base_2_3_4_5_6_singleton_.ViewList(this.add_layer_model, this.remove_layer_view, this);
        this.control_views = new base_2_3_4_5_6_singleton_.ViewList(this.add_control_model, this.remove_control_view, this);
        this.displayed.then(this.render_leaflet.bind(this));
    }
    render_leaflet() {
        this.create_obj().then(() => {
            this.create_panes();
            this.layer_views.update(this.model.get('layers'));
            this.control_views.update(this.model.get('controls'));
            this.leaflet_events();
            this.model_events();
            this.model.update_bounds().then(() => {
                this.touch();
            });
            return this;
        });
    }
    async create_obj() {
        return this.layoutPromise.then(() => {
            const options = {
                ...this.get_options(),
                crs: getProjection(this.model.get('crs')),
                zoomControl: false,
                attributionControl: false,
            };
            this.obj = leaflet.map(this.map_container, options);
        });
    }
    rerender() {
        this.obj.remove();
        //@ts-ignore
        delete this.obj;
        this.el.removeChild(this.map_child);
        this.render();
    }
    leaflet_events() {
        this.obj.on('moveend', (e) => {
            if (!this.dirty) {
                this.dirty = true;
                const c = e.target.getCenter();
                this.model.set('center', [c.lat, c.lng]);
                this.dirty = false;
            }
            this.model.update_bounds().then(() => {
                this.touch();
            });
            this.model._dragging = false;
            this.model.update_style();
        });
        this.obj.on('movestart', () => {
            this.model._dragging = true;
            this.model.update_style();
        });
        this.obj.on('zoomend', (e) => {
            if (!this.dirty) {
                this.dirty = true;
                const z = e.target.getZoom();
                this.model.set('zoom', z);
                this.dirty = false;
            }
            this.model.update_bounds().then(() => {
                this.touch();
            });
        });
        this.obj.on('click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu preclick', (event) => {
            this.send({
                event: 'interaction',
                type: event.type,
                coordinates: [event.latlng.lat, event.latlng.lng],
                location: this.model.get('location'),
            });
        });
        this.obj.on('fullscreenchange', () => {
            this.model.set('fullscreen', this.obj.isFullscreen());
        });
    }
    model_events() {
        let key;
        let o = this.model.get('options');
        for (let i = 0; i < o.length; i++) {
            key = o[i];
            this.listenTo(this.model, 'change:' + key, () => {
                leaflet.setOptions(this.obj, this.get_options());
            });
        }
        this.listenTo(this.model, 'change:panes', this.rerender);
        this.listenTo(this.model, 'change:dragging', () => {
            if (this.model.get('dragging')) {
                this.obj.dragging.enable();
            }
            else {
                this.obj.dragging.disable();
            }
        });
        this.listenTo(this.model, 'change:layers', () => {
            this.layer_views.update(this.model.get('layers'));
        });
        this.listenTo(this.model, 'change:controls', () => {
            this.control_views.update(this.model.get('controls'));
        });
        this.listenTo(this.model, 'change:zoom', () => {
            if (!this.dirty) {
                this.dirty = true;
                // Using flyTo instead of setZoom to adjust for potential
                // sub-pixel error in leaflet object's center.
                //
                // Disabling animation on updates from the model because
                // animation triggers a `moveend` event in an animationFrame,
                // which causes the center to bounce despite of the dirty flag
                // which is set back to false synchronously.
                this.obj.flyTo(this.model.get('center'), this.model.get('zoom'), {
                    animate: false,
                });
                this.dirty = false;
            }
            this.model.update_bounds().then(() => {
                this.touch();
            });
        });
        this.listenTo(this.model, 'change:center', () => {
            if (!this.dirty) {
                this.dirty = true;
                this.obj.panTo(this.model.get('center'));
                this.dirty = false;
            }
            this.model.update_bounds().then(() => {
                this.touch();
            });
        });
        this.listenTo(this.model, 'change:dragging_style', () => {
            this.model.update_style();
        });
        this.listenTo(this.model, 'change:default_style', () => {
            this.model.update_style();
        });
        this.listenTo(this.model, 'change:fullscreen', () => {
            const fullscreen = this.model.get('fullscreen');
            if (this.obj.isFullscreen() !== fullscreen) {
                this.obj.toggleFullscreen();
            }
        });
        this.listenTo(this.model, 'change:scroll_wheel_zoom', () => {
            const scrollWheelZoom = this.model.get('scroll_wheel_zoom');
            if (scrollWheelZoom) {
                this.obj.scrollWheelZoom.enable();
            }
            else {
                this.obj.scrollWheelZoom.disable();
            }
        });
        this.listenTo(this.model, 'change:double_click_zoom', () => {
            const doubleClickZoom = this.model.get('double_click_zoom');
            if (doubleClickZoom) {
                this.obj.doubleClickZoom.enable();
            }
            else {
                this.obj.doubleClickZoom.disable();
            }
        });
        this.listenTo(this.model, 'change:touch_zoom', () => {
            const touchZoom = this.model.get('touch_zoom');
            if (touchZoom) {
                this.obj.touchZoom.enable();
            }
            else {
                this.obj.touchZoom.disable();
            }
        });
        this.listenTo(this.model, 'change:box_zoom', () => {
            const boxZoom = this.model.get('box_zoom');
            if (boxZoom) {
                this.obj.boxZoom.enable();
            }
            else {
                this.obj.boxZoom.disable();
            }
        });
    }
    processPhosphorMessage(msg) {
        //@ts-ignore This is for backward compatibility with Jupyterlab 3
        this._processLuminoMessage(msg, super.processPhosphorMessage);
    }
    processLuminoMessage(msg) {
        this._processLuminoMessage(msg, super.processLuminoMessage);
    }
    _processLuminoMessage(msg, _super) {
        _super.call(this, msg);
        if (!this.obj)
            return;
        switch (msg.type) {
            case 'resize':
                // We set the dirty flag to true to prevent the sub-pixel error
                // on the new center to be reflected on the model.
                this.dirty = true;
                // On the pan option:
                // `pan=true`  causes the center to be unchanged upon resize (up
                // to sub-pixel differences)
                // `pan=false` corresponds to having to top-left corner
                // unchanged.
                this.obj.invalidateSize({
                    animate: false,
                    pan: true,
                });
                this.dirty = false;
                break;
            case 'after-show':
                this.dirty = true;
                // If we are in a jupyter-widget tab, we get an after-show before
                // this.displayed is resolved. In this case, obj is not created yet.
                this.obj.invalidateSize({
                    animate: false,
                    pan: true,
                });
                this.dirty = false;
                break;
        }
    }
}
//# sourceMappingURL=Map.js.map
// EXTERNAL MODULE: ./node_modules/leaflet-defaulticon-compatibility/dist/leaflet-defaulticon-compatibility.webpack.css
var leaflet_defaulticon_compatibility_webpack = __webpack_require__(9375);
// EXTERNAL MODULE: ./node_modules/leaflet-draw/dist/leaflet.draw.css
var leaflet_draw = __webpack_require__(1149);
// EXTERNAL MODULE: ./node_modules/leaflet-fullscreen/dist/leaflet.fullscreen.css
var leaflet_fullscreen = __webpack_require__(4589);
// EXTERNAL MODULE: ./node_modules/leaflet-measure/dist/leaflet-measure.css
var leaflet_measure = __webpack_require__(6470);
// EXTERNAL MODULE: ./node_modules/leaflet-search/dist/leaflet-search.src.css
var leaflet_search_src = __webpack_require__(766);
// EXTERNAL MODULE: ./node_modules/leaflet.awesome-markers/dist/leaflet.awesome-markers.css
var leaflet_awesome_markers = __webpack_require__(2662);
// EXTERNAL MODULE: ./node_modules/leaflet.markercluster/dist/MarkerCluster.Default.css
var MarkerCluster_Default = __webpack_require__(8100);
// EXTERNAL MODULE: ./node_modules/leaflet.markercluster/dist/MarkerCluster.css
var MarkerCluster = __webpack_require__(277);
// EXTERNAL MODULE: ./node_modules/spin.js/spin.css
var spin = __webpack_require__(9938);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(8318);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(5879);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(237);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(4862);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(1050);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/builder/node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(8495);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/@jupyterlab/builder/node_modules/css-loader/dist/cjs.js!./css/jupyter-leaflet.css
var jupyter_leaflet = __webpack_require__(7061);
;// ./css/jupyter-leaflet.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());

      options.insert = insertBySelector_default().bind(null, "head");
    
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(jupyter_leaflet/* default */.A, options);




       /* harmony default export */ const css_jupyter_leaflet = (jupyter_leaflet/* default */.A && jupyter_leaflet/* default */.A.locals ? jupyter_leaflet/* default */.A.locals : undefined);

;// ./lib/jupyter-leaflet.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// Layers






























//Controls













//Map

// Load css


// Re-uses images from ~leaflet package









//# sourceMappingURL=jupyter-leaflet.js.map
;// ./lib/index.js
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// @ts-nocheck

// Export everything from jupyter-leaflet and the npm package version number.
var _oldL = window.L;
// if previous L existed and it got changed while loading this module
if (_oldL !== undefined && _oldL !== window.L) {
    console.log("Existing `L` detected, running ipyleaflet's Leaflet in no-conflict mode as `ipyL`");
    ipyL = L.noConflict(); // eslint-disable-line no-undef
}
const { /* version */ "rE": version } = package_0;


//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3815:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">%0A  <defs>%0A    <path id=\"polygon-a\" d=\"M19.4206892,9.16509725 C19.1523681,8.66992914 19,8.10275831 19,7.5 C19,5.56700338 20.5670034,4 22.5,4 C24.4329966,4 26,5.56700338 26,7.5 C26,9.26323595 24.6961471,10.7219407 23,10.9645556 L23,19.0354444 C24.6961471,19.2780593 26,20.736764 26,22.5 C26,24.4329966 24.4329966,26 22.5,26 C20.736764,26 19.2780593,24.6961471 19.0354444,23 L10.9645556,23 C10.7219407,24.6961471 9.26323595,26 7.5,26 C5.56700338,26 4,24.4329966 4,22.5 C4,20.5670034 5.56700338,19 7.5,19 C8.10275831,19 8.66992914,19.1523681 9.16509725,19.4206892 L19.4206892,9.16509725 Z M20.8349073,10.5793063 L10.5793108,20.8349027 C10.6086731,20.8890888 10.6366469,20.9441372 10.6631844,21 L19.3368156,21 C19.6825775,20.272154 20.272154,19.6825775 21,19.3368156 L21,10.6631844 C20.9441372,10.6366469 20.8890888,10.6086731 20.8349027,10.5793108 Z M22.5,9 C23.3284271,9 24,8.32842712 24,7.5 C24,6.67157288 23.3284271,6 22.5,6 C21.6715729,6 21,6.67157288 21,7.5 C21,8.32842712 21.6715729,9 22.5,9 Z M22.5,24 C23.3284271,24 24,23.3284271 24,22.5 C24,21.6715729 23.3284271,21 22.5,21 C21.6715729,21 21,21.6715729 21,22.5 C21,23.3284271 21.6715729,24 22.5,24 Z M7.5,24 C8.32842712,24 9,23.3284271 9,22.5 C9,21.6715729 8.32842712,21 7.5,21 C6.67157288,21 6,21.6715729 6,22.5 C6,23.3284271 6.67157288,24 7.5,24 Z\"/>%0A  </defs>%0A  <g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate%28-3 -3%29\">%0A    <mask id=\"polygon-b\" fill=\"%23fff\">%0A      <use xlink:href=\"%23polygon-a\"/>%0A    </mask>%0A    <use fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23polygon-a\"/>%0A    <g fill=\"%235B5B5B\" mask=\"url%28%23polygon-b%29\">%0A      <rect width=\"30\" height=\"30\"/>%0A    </g>%0A  </g>%0A</svg>%0A";

/***/ }),

/***/ 7061:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2888);
/* harmony import */ var _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1992);
/* harmony import */ var _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5379);
/* harmony import */ var _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(1999), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_jupyterlab_builder_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */

.leaflet-container {
  height: 100%;
  width: 100%;
}

.jupyter-widgets.leaflet-widgets {
  height: 400px;
  overflow: hidden;
  flex: 1 1 auto;
}

.jp-LinkedOutputView .jupyter-widgets.leaflet-widgets {
  min-height: 360px; /* Min-height required for mirred output in jlab < 0.31.6 */
  height: 100%;
}

/* Leaflet crispness override */
.crisp-image {
  /* Preserve crisp pixels with scaled up images */
  image-rendering: optimizeSpeed; /* Legal fallback */
  image-rendering: -moz-crisp-edges; /* Firefox        */
  image-rendering: -o-crisp-edges; /* Opera          */
  image-rendering: -webkit-optimize-contrast; /* Safari         */
  image-rendering: optimize-contrast; /* CSS3 Proposed  */
  image-rendering: crisp-edges; /* CSS4 Proposed  */
  image-rendering: pixelated; /* CSS4 Proposed  */
  -ms-interpolation-mode: nearest-neighbor; /* IE8+           */
}

/* JupyterLab themes support */
/* Popup */
.leaflet-popup-content-wrapper,
.leaflet-popup-tip {
  background-color: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
}

/* Basic controls */
.leaflet-bar a,
.leaflet-bar a:hover {
  background-color: var(--jp-layout-color1);
  color: var(--jp-ui-font-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
}

.leaflet-bar a:hover {
  background-color: var(--jp-layout-color2);
  color: var(--jp-ui-font-color2);
}

.leaflet-bar a.leaflet-disabled {
  background-color: var(--jp-layout-color3);
  color: var(--jp-ui-font-color3);
}

/* Widget control */
.leaflet-widgetcontrol {
  background: var(--jp-layout-color1);
  border-radius: 4.5px;
  box-shadow: 4px 5px 8px 0px #9e9e9e;
}

/* SplitMap control */
.leaflet-sbs-divider {
  background-color: var(--jp-layout-color1);
}

.leaflet-sbs-range::-webkit-slider-thumb {
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
}

.leaflet-sbs-range::-ms-thumb {
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
}

.leaflet-sbs-range::-moz-range-thumb {
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
}

/* Measure control */
.leaflet-control-measure {
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
  color: var(--jp-ui-font-color1);
}

/* Layers control */
.leaflet-control-layers {
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
  color: var(--jp-ui-font-color1);
}

.leaflet-control-layers-expanded {
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
  color: var(--jp-ui-font-color1);
}

/* Attribution control */
.leaflet-container .leaflet-control-attribution {
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
  color: var(--jp-ui-font-color1);
}

.leaflet-control-velocity.leaflet-control {
  background: var(--jp-layout-color1);
  margin: 0;
  padding: 0 5px;
  color: var(--jp-ui-font-color1);
  font-size: 11px;
}

/* Legend Control */
div.leaflet-control-legend {
  color: var(--jp-ui-font-color1);
  line-height: 18px;
  width: auto;
  background-color: var(--jp-layout-color1);
  border-width: var(--jp-border-width);
  border-color: var(--jp-border-color1);
  border-radius: 4.5px;
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);
  padding: 6px 10px 6px 6px;
}

div.leaflet-control-legend > h4 {
  padding: 0;
  margin: 0;
  margin-bottom: 5px;
}

div.leaflet-control-legend > i {
  width: 18px;
  height: 18px;
  float: left;
  margin-right: 8px;
}

div.leaflet-control-legend > p {
  display: inline-block;
}

/* Magnifying Glass */
.leaflet-magnifying-glass {
  border-radius: 50%;
  border: 1px solid gray;
  box-shadow: 0 0 5px gray;
  position: absolute;
  overflow: hidden;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.leaflet-magnifying-glass > .leaflet-container {
  height: 100%;
  width: 100%;
}

/* Webkit-only workaround for the border-radius clipping bug,
applied to the map container */
.leaflet-magnifying-glass-webkit {
  border-radius: 50%;
  -webkit-mask-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
}
`, "",{"version":3,"sources":["webpack://./css/jupyter-leaflet.css"],"names":[],"mappings":"AAAA;;EAEE;;AAEF;EACE,YAAY;EACZ,WAAW;AACb;;AAEA;EACE,aAAa;EACb,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,iBAAiB,EAAE,2DAA2D;EAC9E,YAAY;AACd;;AAEA,+BAA+B;AAC/B;EACE,gDAAgD;EAChD,8BAA8B,EAAE,mBAAmB;EACnD,iCAAiC,EAAE,mBAAmB;EACtD,+BAA+B,EAAE,mBAAmB;EACpD,0CAA0C,EAAE,mBAAmB;EAC/D,kCAAkC,EAAE,mBAAmB;EACvD,4BAA4B,EAAE,mBAAmB;EACjD,0BAA0B,EAAE,mBAAmB;EAC/C,wCAAwC,EAAE,mBAAmB;AAC/D;;AAEA,8BAA8B;AAC9B,UAAU;AACV;;EAEE,yCAAyC;EACzC,+BAA+B;EAC/B,oCAAoC;EACpC,qCAAqC;AACvC;;AAEA,mBAAmB;AACnB;;EAEE,yCAAyC;EACzC,+BAA+B;EAC/B,oCAAoC;EACpC,qCAAqC;AACvC;;AAEA;EACE,yCAAyC;EACzC,+BAA+B;AACjC;;AAEA;EACE,yCAAyC;EACzC,+BAA+B;AACjC;;AAEA,mBAAmB;AACnB;EACE,mCAAmC;EACnC,oBAAoB;EACpB,mCAAmC;AACrC;;AAEA,qBAAqB;AACrB;EACE,yCAAyC;AAC3C;;AAEA;EACE,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;AACvC;;AAEA;EACE,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;AACvC;;AAEA;EACE,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;AACvC;;AAEA,oBAAoB;AACpB;EACE,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;EACrC,+BAA+B;AACjC;;AAEA,mBAAmB;AACnB;EACE,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;EACrC,+BAA+B;AACjC;;AAEA;EACE,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;EACrC,+BAA+B;AACjC;;AAEA,wBAAwB;AACxB;EACE,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;EACrC,+BAA+B;AACjC;;AAEA;EACE,mCAAmC;EACnC,SAAS;EACT,cAAc;EACd,+BAA+B;EAC/B,eAAe;AACjB;;AAEA,mBAAmB;AACnB;EACE,+BAA+B;EAC/B,iBAAiB;EACjB,WAAW;EACX,yCAAyC;EACzC,oCAAoC;EACpC,qCAAqC;EACrC,oBAAoB;EACpB,wCAAwC;EACxC,yBAAyB;AAC3B;;AAEA;EACE,UAAU;EACV,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,WAAW;EACX,iBAAiB;AACnB;;AAEA;EACE,qBAAqB;AACvB;;AAEA,qBAAqB;AACrB;EACE,kBAAkB;EAClB,sBAAsB;EACtB,wBAAwB;EACxB,kBAAkB;EAClB,gBAAgB;EAChB,2BAA2B;EAC3B,sBAAsB;AACxB;;AAEA;EACE,YAAY;EACZ,WAAW;AACb;;AAEA;8BAC8B;AAC9B;EACE,kBAAkB;EAClB,2DAA+L;AACjM","sourcesContent":["/* Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n.leaflet-container {\n  height: 100%;\n  width: 100%;\n}\n\n.jupyter-widgets.leaflet-widgets {\n  height: 400px;\n  overflow: hidden;\n  flex: 1 1 auto;\n}\n\n.jp-LinkedOutputView .jupyter-widgets.leaflet-widgets {\n  min-height: 360px; /* Min-height required for mirred output in jlab < 0.31.6 */\n  height: 100%;\n}\n\n/* Leaflet crispness override */\n.crisp-image {\n  /* Preserve crisp pixels with scaled up images */\n  image-rendering: optimizeSpeed; /* Legal fallback */\n  image-rendering: -moz-crisp-edges; /* Firefox        */\n  image-rendering: -o-crisp-edges; /* Opera          */\n  image-rendering: -webkit-optimize-contrast; /* Safari         */\n  image-rendering: optimize-contrast; /* CSS3 Proposed  */\n  image-rendering: crisp-edges; /* CSS4 Proposed  */\n  image-rendering: pixelated; /* CSS4 Proposed  */\n  -ms-interpolation-mode: nearest-neighbor; /* IE8+           */\n}\n\n/* JupyterLab themes support */\n/* Popup */\n.leaflet-popup-content-wrapper,\n.leaflet-popup-tip {\n  background-color: var(--jp-layout-color1);\n  color: var(--jp-ui-font-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n}\n\n/* Basic controls */\n.leaflet-bar a,\n.leaflet-bar a:hover {\n  background-color: var(--jp-layout-color1);\n  color: var(--jp-ui-font-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n}\n\n.leaflet-bar a:hover {\n  background-color: var(--jp-layout-color2);\n  color: var(--jp-ui-font-color2);\n}\n\n.leaflet-bar a.leaflet-disabled {\n  background-color: var(--jp-layout-color3);\n  color: var(--jp-ui-font-color3);\n}\n\n/* Widget control */\n.leaflet-widgetcontrol {\n  background: var(--jp-layout-color1);\n  border-radius: 4.5px;\n  box-shadow: 4px 5px 8px 0px #9e9e9e;\n}\n\n/* SplitMap control */\n.leaflet-sbs-divider {\n  background-color: var(--jp-layout-color1);\n}\n\n.leaflet-sbs-range::-webkit-slider-thumb {\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n}\n\n.leaflet-sbs-range::-ms-thumb {\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n}\n\n.leaflet-sbs-range::-moz-range-thumb {\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n}\n\n/* Measure control */\n.leaflet-control-measure {\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n  color: var(--jp-ui-font-color1);\n}\n\n/* Layers control */\n.leaflet-control-layers {\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n  color: var(--jp-ui-font-color1);\n}\n\n.leaflet-control-layers-expanded {\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n  color: var(--jp-ui-font-color1);\n}\n\n/* Attribution control */\n.leaflet-container .leaflet-control-attribution {\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n  color: var(--jp-ui-font-color1);\n}\n\n.leaflet-control-velocity.leaflet-control {\n  background: var(--jp-layout-color1);\n  margin: 0;\n  padding: 0 5px;\n  color: var(--jp-ui-font-color1);\n  font-size: 11px;\n}\n\n/* Legend Control */\ndiv.leaflet-control-legend {\n  color: var(--jp-ui-font-color1);\n  line-height: 18px;\n  width: auto;\n  background-color: var(--jp-layout-color1);\n  border-width: var(--jp-border-width);\n  border-color: var(--jp-border-color1);\n  border-radius: 4.5px;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.4);\n  padding: 6px 10px 6px 6px;\n}\n\ndiv.leaflet-control-legend > h4 {\n  padding: 0;\n  margin: 0;\n  margin-bottom: 5px;\n}\n\ndiv.leaflet-control-legend > i {\n  width: 18px;\n  height: 18px;\n  float: left;\n  margin-right: 8px;\n}\n\ndiv.leaflet-control-legend > p {\n  display: inline-block;\n}\n\n/* Magnifying Glass */\n.leaflet-magnifying-glass {\n  border-radius: 50%;\n  border: 1px solid gray;\n  box-shadow: 0 0 5px gray;\n  position: absolute;\n  overflow: hidden;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.leaflet-magnifying-glass > .leaflet-container {\n  height: 100%;\n  width: 100%;\n}\n\n/* Webkit-only workaround for the border-radius clipping bug,\napplied to the map container */\n.leaflet-magnifying-glass-webkit {\n  border-radius: 50%;\n  -webkit-mask-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYGBgAAgwAAAEAAGbA+oJAAAAAElFTkSuQmCC);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 7872:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<?xml version=\"1.0\" encoding=\"UTF-8\"?>%0A<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">%0A    <%21-- Generator: Sketch 52.5 %2867469%29 - http://www.bohemiancoding.com/sketch -->%0A    <title>Atoms/Icons/Tools/Marker</title>%0A    <desc>Created with Sketch.</desc>%0A    <defs>%0A        <path d=\"M15.5,24.8782959 C15.2909201,24.8772219 15.1744857,24.8467817 14.6590866,24.2354163 C10.2196955,19.4118054 8,15.5014392 8,12.5043177 C8,8.35979746 11.3578644,5 15.5,5 C19.6421356,5 23,8.35979746 23,12.5043177 C23,17 18.2878217,21.9268378 16.3336601,24.2440186 C15.8224622,24.8501802 15.7090799,24.8793699 15.5,24.8782959 Z M15.5,15.5326948 C17.275201,15.5326948 18.7142857,14.1180004 18.7142857,12.3728864 C18.7142857,10.6277723 17.275201,9.21307792 15.5,9.21307792 C13.724799,9.21307792 12.2857143,10.6277723 12.2857143,12.3728864 C12.2857143,14.1180004 13.724799,15.5326948 15.5,15.5326948 Z\" id=\"path-1\"></path>%0A    </defs>%0A    <g id=\"Symbols\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">%0A        <g id=\"Atoms/Icons/Tools/Marker\" transform=\"translate%28-3.000000, -3.000000%29\">%0A            <mask id=\"mask-2\" fill=\"white\">%0A                <use xlink:href=\"%23path-1\"></use>%0A            </mask>%0A            <use id=\"Mask\" fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23path-1\"></use>%0A        </g>%0A    </g>%0A</svg>";

/***/ }),

/***/ 8852:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">%0A    <defs>%0A        <path id=\"rotate\" d=\"M21.2,5.8c-0.1-0.2-0.2-0.3-0.3-0.5l-0.1-0.2c-0.1-0.2-0.2-0.3-0.3-0.5l-0.1-0.2c-0.1-0.2-0.2-0.3-0.4-0.5l-0.2-0.3l2.8-3.1L18,0.6l-4.6,0.1l0.5,4.5l0.5,4.5l3.2-3.6v0.1l0.1,0.2c0.1,0.1,0.1,0.2,0.2,0.2l0.1,0.2C18,7,18,7.1,18.1,7.2c0.3,0.7,0.6,1.4,0.7,2.1c0.2,1.4,0,2.9-0.6,4.2L18,13.9L17.9,14l-0.3,0.5l-0.1,0.2c-0.2,0.2-0.4,0.5-0.6,0.7c-0.5,0.5-1.1,1-1.7,1.3c-0.6,0.4-1.3,0.6-2.1,0.8c-0.7,0.1-1.5,0.2-2.2,0.1c-0.8-0.1-1.5-0.3-2.2-0.5c-0.7-0.3-1.3-0.7-1.9-1.2l-0.4-0.4l-0.2-0.3L6,15c-0.1-0.1-0.2-0.2-0.2-0.3l-0.3-0.4l-0.1-0.1l-0.2-0.4c0-0.1-0.1-0.1-0.1-0.2l-0.3-0.5l-0.1-0.2c-0.1-0.3-0.2-0.6-0.3-0.9c-0.2-0.8-0.3-1.6-0.3-2.4c0-0.2,0-0.3,0-0.5V8.9c0-0.2,0-0.3,0.1-0.4l0.1-0.6l0.2-0.6c0.3-0.8,0.7-1.5,1.2-2.2c0.5-0.7,1.1-1.3,1.8-1.8c0.2-0.1,0.3-0.4,0.1-0.6C7.5,2.6,7.4,2.5,7.3,2.5H7.1L7,2.6C6.1,3,5.4,3.6,4.7,4.2C4,4.9,3.5,5.7,3,6.6c-0.9,1.8-1.2,3.8-0.8,5.8c0.1,0.5,0.2,0.9,0.3,1.4l0.3,0.8C2.9,14.7,3,14.8,3,15l0.2,0.4c0,0.1,0.1,0.2,0.1,0.2l0.3,0.5c0.1,0.2,0.2,0.3,0.3,0.5l0.1,0.2c0.1,0.1,0.2,0.3,0.3,0.4L5,17.8c0.7,0.7,1.6,1.3,2.5,1.8c0.9,0.5,1.9,0.8,3,0.9c0.5,0.1,1,0.1,1.5,0.1c0.6,0,1.1,0,1.6-0.1c1-0.2,2.1-0.5,3-1l0.2-0.1c0.2-0.1,0.3-0.2,0.5-0.3l0.7-0.4c0.2-0.1,0.3-0.2,0.4-0.3l0.2-0.2c0.2-0.1,0.4-0.3,0.5-0.5l0.1-0.1c0.3-0.3,0.7-0.7,0.9-1l0.6-0.9l0.4-0.6c1-1.9,1.4-4.1,1.1-6.2C22,7.8,21.7,6.7,21.2,5.8z\"/>%0A    </defs>%0A    <g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate%280 2%29\">%0A        <mask id=\"rotate-b\" fill=\"%23fff\">%0A            <use xlink:href=\"%23rotate\"/>%0A        </mask>%0A        <use fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23rotate\"/>%0A        <g fill=\"%235B5B5B\" mask=\"url%28%23rotate-b%29\">%0A            <rect width=\"30\" height=\"30\"/>%0A        </g>%0A    </g>%0A</svg>%0A";

/***/ }),

/***/ 9051:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">%0A  <defs>%0A    <path id=\"rectangle-a\" d=\"M23,10.9645556 L23,19.0354444 C24.6961471,19.2780593 26,20.736764 26,22.5 C26,24.4329966 24.4329966,26 22.5,26 C20.736764,26 19.2780593,24.6961471 19.0354444,23 L10.9645556,23 C10.7219407,24.6961471 9.26323595,26 7.5,26 C5.56700338,26 4,24.4329966 4,22.5 C4,20.736764 5.30385293,19.2780593 7,19.0354444 L7,10.9645556 C5.30385293,10.7219407 4,9.26323595 4,7.5 C4,5.56700338 5.56700338,4 7.5,4 C9.26323595,4 10.7219407,5.30385293 10.9645556,7 L19.0354444,7 C19.2780593,5.30385293 20.736764,4 22.5,4 C24.4329966,4 26,5.56700338 26,7.5 C26,9.26323595 24.6961471,10.7219407 23,10.9645556 Z M21,10.6631844 C20.272154,10.3174225 19.6825775,9.72784598 19.3368156,9 L10.6631844,9 C10.3174225,9.72784598 9.72784598,10.3174225 9,10.6631844 L9,19.3368156 C9.72784598,19.6825775 10.3174225,20.272154 10.6631844,21 L19.3368156,21 C19.6825775,20.272154 20.272154,19.6825775 21,19.3368156 L21,10.6631844 Z M7.5,9 C8.32842712,9 9,8.32842712 9,7.5 C9,6.67157288 8.32842712,6 7.5,6 C6.67157288,6 6,6.67157288 6,7.5 C6,8.32842712 6.67157288,9 7.5,9 Z M22.5,9 C23.3284271,9 24,8.32842712 24,7.5 C24,6.67157288 23.3284271,6 22.5,6 C21.6715729,6 21,6.67157288 21,7.5 C21,8.32842712 21.6715729,9 22.5,9 Z M22.5,24 C23.3284271,24 24,23.3284271 24,22.5 C24,21.6715729 23.3284271,21 22.5,21 C21.6715729,21 21,21.6715729 21,22.5 C21,23.3284271 21.6715729,24 22.5,24 Z M7.5,24 C8.32842712,24 9,23.3284271 9,22.5 C9,21.6715729 8.32842712,21 7.5,21 C6.67157288,21 6,21.6715729 6,22.5 C6,23.3284271 6.67157288,24 7.5,24 Z\"/>%0A  </defs>%0A  <g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate%28-3 -3%29\">%0A    <mask id=\"rectangle-b\" fill=\"%23fff\">%0A      <use xlink:href=\"%23rectangle-a\"/>%0A    </mask>%0A    <use fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23rectangle-a\"/>%0A    <g fill=\"%235B5B5B\" mask=\"url%28%23rectangle-b%29\">%0A      <rect width=\"30\" height=\"30\"/>%0A    </g>%0A  </g>%0A</svg>%0A";

/***/ }),

/***/ 9052:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">%0A  <defs>%0A    <path id=\"edit_anchor-a\" d=\"M13.5,11 C11.5670034,11 10,9.43299662 10,7.5 C10,5.56700338 11.5670034,4 13.5,4 C15.4329966,4 17,5.56700338 17,7.5 C17,9.43299662 15.4329966,11 13.5,11 Z M13.5,9 C14.3284271,9 15,8.32842712 15,7.5 C15,6.67157288 14.3284271,6 13.5,6 C12.6715729,6 12,6.67157288 12,7.5 C12,8.32842712 12.6715729,9 13.5,9 Z M12.0002889,7.52973893 C12.0125983,8.16273672 12.4170197,8.6996643 12.9807111,8.90767966 L3,15 L3,13 L12.0002889,7.52973893 Z M14.2172722,6.18228472 L19.453125,3 L22.6589355,3 L14.989102,7.68173885 C14.9962971,7.62216459 15,7.56151472 15,7.5 C15,6.93138381 14.6836098,6.4366645 14.2172722,6.18228472 Z M23.4434042,19.2851736 L20.1282799,19.2851736 L21.8729983,23.5349525 C21.9945296,23.8295773 21.8556546,24.1599209 21.5778734,24.2849208 L20.0414675,24.9545142 C19.7550613,25.0795141 19.4338738,24.9366704 19.3123426,24.6509518 L17.6544367,20.6154541 L14.9461873,23.4010151 C14.5852811,23.7721711 14,23.4860463 14,22.9992653 L14,9.57183533 C14,9.05933561 14.6225311,8.809492 14.946156,9.17008555 L23.8340292,18.3120179 C24.1925291,18.6613615 23.9279979,19.2851736 23.4434042,19.2851736 Z\"/>%0A  </defs>%0A  <g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate%28-3 -3%29\">%0A    <mask id=\"edit_anchor-b\" fill=\"%23fff\">%0A      <use xlink:href=\"%23edit_anchor-a\"/>%0A    </mask>%0A    <use fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23edit_anchor-a\"/>%0A    <g fill=\"%235B5B5B\" mask=\"url%28%23edit_anchor-b%29\">%0A      <rect width=\"30\" height=\"30\"/>%0A    </g>%0A  </g>%0A</svg>%0A";

/***/ }),

/***/ 9204:
/***/ ((module) => {

module.exports = "data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">%0A  <defs>%0A    <path id=\"line-a\" d=\"M9.16509725,19.4206892 L18.4206892,10.1650973 C18.1523681,9.66992914 18,9.10275831 18,8.5 C18,6.56700338 19.5670034,5 21.5,5 C23.4329966,5 25,6.56700338 25,8.5 C25,10.4329966 23.4329966,12 21.5,12 C20.8972417,12 20.3300709,11.8476319 19.8349027,11.5793108 L10.5793108,20.8349027 C10.8476319,21.3300709 11,21.8972417 11,22.5 C11,24.4329966 9.43299662,26 7.5,26 C5.56700338,26 4,24.4329966 4,22.5 C4,20.5670034 5.56700338,19 7.5,19 C8.10275831,19 8.66992914,19.1523681 9.16509725,19.4206892 Z M21.5,10 C22.3284271,10 23,9.32842712 23,8.5 C23,7.67157288 22.3284271,7 21.5,7 C20.6715729,7 20,7.67157288 20,8.5 C20,9.32842712 20.6715729,10 21.5,10 Z M7.5,24 C8.32842712,24 9,23.3284271 9,22.5 C9,21.6715729 8.32842712,21 7.5,21 C6.67157288,21 6,21.6715729 6,22.5 C6,23.3284271 6.67157288,24 7.5,24 Z\"/>%0A  </defs>%0A  <g fill=\"none\" fill-rule=\"evenodd\" transform=\"translate%28-3 -3%29\">%0A    <mask id=\"line-b\" fill=\"%23fff\">%0A      <use xlink:href=\"%23line-a\"/>%0A    </mask>%0A    <use fill=\"%235B5B5B\" fill-rule=\"nonzero\" xlink:href=\"%23line-a\"/>%0A    <g fill=\"%235B5B5B\" mask=\"url%28%23line-b%29\">%0A      <rect width=\"30\" height=\"30\"/>%0A    </g>%0A  </g>%0A</svg>%0A";

/***/ })

}]);
//# sourceMappingURL=672.9e5e5fdb8cba14119564.js.map?v=9e5e5fdb8cba14119564