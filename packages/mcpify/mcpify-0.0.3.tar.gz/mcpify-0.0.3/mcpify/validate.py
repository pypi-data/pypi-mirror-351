"""
Validation module for MCPify generated configurations.

This module provides validation functionality for MCP server configurations
generated by the detection system. It ensures configurations are properly
structured and contain all required fields with correct types.
"""

import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass
class ValidationError:
    """Represents a validation error with context."""

    field: str
    message: str
    severity: str = "error"  # "error", "warning", "info"
    path: str = ""


@dataclass
class ValidationResult:
    """Result of validation with errors and warnings."""

    is_valid: bool
    errors: list[ValidationError]
    warnings: list[ValidationError]

    def add_error(self, field: str, message: str, path: str = ""):
        """Add an error to the validation result."""
        self.errors.append(ValidationError(field, message, "error", path))
        self.is_valid = False

    def add_warning(self, field: str, message: str, path: str = ""):
        """Add a warning to the validation result."""
        self.warnings.append(ValidationError(field, message, "warning", path))

    def get_summary(self) -> str:
        """Get a summary of validation results."""
        if self.is_valid and not self.warnings:
            return "✅ Configuration is valid"

        summary = []
        if self.errors:
            summary.append(f"❌ {len(self.errors)} error(s)")
        if self.warnings:
            summary.append(f"⚠️  {len(self.warnings)} warning(s)")

        return " | ".join(summary)


class MCPConfigValidator:
    """Validator for MCP configuration files."""

    # Required top-level fields
    REQUIRED_FIELDS = ["name", "description", "backend", "tools"]

    # Valid backend types
    VALID_BACKEND_TYPES = ["commandline", "http", "websocket"]

    # Valid parameter types for tools
    VALID_PARAM_TYPES = ["string", "integer", "number", "boolean", "array", "object"]

    def __init__(self):
        """Initialize the validator."""
        pass

    def validate_file(self, file_path: str | Path) -> ValidationResult:
        """
        Validate an MCP configuration file.

        Args:
            file_path: Path to the JSON configuration file

        Returns:
            ValidationResult with errors and warnings
        """
        result = ValidationResult(is_valid=True, errors=[], warnings=[])
        file_path = Path(file_path)

        # Check if file exists
        if not file_path.exists():
            result.add_error("file", f"Configuration file not found: {file_path}")
            return result

        # Try to load JSON
        try:
            with open(file_path, encoding="utf-8") as f:
                config = json.load(f)
        except json.JSONDecodeError as e:
            result.add_error("json", f"Invalid JSON format: {e}")
            return result
        except Exception as e:
            result.add_error("file", f"Could not read file: {e}")
            return result

        # Validate the configuration
        return self.validate_config(config)

    def validate_config(self, config: dict[str, Any]) -> ValidationResult:
        """
        Validate an MCP configuration dictionary.

        Args:
            config: Configuration dictionary to validate

        Returns:
            ValidationResult with errors and warnings
        """
        result = ValidationResult(is_valid=True, errors=[], warnings=[])

        # Validate top-level structure
        self._validate_top_level(config, result)

        # Validate individual sections
        if "name" in config:
            self._validate_name(config["name"], result)

        if "description" in config:
            self._validate_description(config["description"], result)

        if "backend" in config:
            self._validate_backend(config["backend"], result)

        if "tools" in config:
            self._validate_tools(config["tools"], result)

        # Additional validations
        self._validate_consistency(config, result)

        return result

    def _validate_top_level(
        self, config: dict[str, Any], result: ValidationResult
    ) -> None:
        """Validate top-level structure and required fields."""
        if not isinstance(config, dict):
            result.add_error("root", "Configuration must be a JSON object")
            return

        # Check required fields
        for field in self.REQUIRED_FIELDS:
            if field not in config:
                result.add_error(field, f"Required field '{field}' is missing")

        # Check for unknown fields
        known_fields = set(self.REQUIRED_FIELDS + ["version", "metadata"])
        for field in config.keys():
            if field not in known_fields:
                result.add_warning(field, f"Unknown field '{field}'")

    def _validate_name(self, name: Any, result: ValidationResult) -> None:
        """Validate the name field."""
        if not isinstance(name, str):
            result.add_error("name", "Name must be a string")
            return

        if not name.strip():
            result.add_error("name", "Name cannot be empty")
            return

        # Check for valid naming conventions
        if not re.match(r"^[a-zA-Z0-9_-]+$", name):
            result.add_warning(
                "name",
                "Name should only contain letters, numbers, hyphens, and underscores",
            )

        if len(name) > 100:
            result.add_warning("name", "Name is quite long (>100 characters)")

    def _validate_description(self, description: Any, result: ValidationResult) -> None:
        """Validate the description field."""
        if not isinstance(description, str):
            result.add_error("description", "Description must be a string")
            return

        if not description.strip():
            result.add_warning("description", "Description is empty")
            return

        if len(description) < 10:
            result.add_warning(
                "description", "Description is quite short (<10 characters)"
            )

        if len(description) > 1000:
            result.add_warning(
                "description", "Description is quite long (>1000 characters)"
            )

    def _validate_backend(self, backend: Any, result: ValidationResult) -> None:
        """Validate the backend configuration."""
        if not isinstance(backend, dict):
            result.add_error("backend", "Backend must be an object")
            return

        # Check required backend fields
        if "type" not in backend:
            result.add_error("backend.type", "Backend type is required")
            return

        backend_type = backend["type"]
        if not isinstance(backend_type, str):
            result.add_error("backend.type", "Backend type must be a string")
            return

        if backend_type not in self.VALID_BACKEND_TYPES:
            result.add_error(
                "backend.type",
                f"Invalid backend type '{backend_type}'. "
                f"Valid types: {', '.join(self.VALID_BACKEND_TYPES)}",
            )
            return

        # Validate backend-specific configuration
        if "config" not in backend:
            result.add_error("backend.config", "Backend config is required")
            return

        config = backend["config"]
        if not isinstance(config, dict):
            result.add_error("backend.config", "Backend config must be an object")
            return

        # Validate specific backend types
        if backend_type == "commandline":
            self._validate_commandline_backend(config, result)
        elif backend_type == "http":
            self._validate_http_backend(config, result)
        elif backend_type == "websocket":
            self._validate_websocket_backend(config, result)

    def _validate_commandline_backend(
        self, config: dict[str, Any], result: ValidationResult
    ) -> None:
        """Validate commandline backend configuration."""
        required_fields = ["command"]

        for field in required_fields:
            if field not in config:
                result.add_error(
                    f"backend.config.{field}", f"Commandline backend requires '{field}'"
                )

        if "command" in config:
            if not isinstance(config["command"], str):
                result.add_error("backend.config.command", "Command must be a string")
            elif not config["command"].strip():
                result.add_error("backend.config.command", "Command cannot be empty")

        if "args" in config:
            if not isinstance(config["args"], list):
                result.add_error("backend.config.args", "Args must be an array")
            else:
                for i, arg in enumerate(config["args"]):
                    if not isinstance(arg, str):
                        result.add_error(
                            f"backend.config.args[{i}]", "All args must be strings"
                        )

        if "cwd" in config:
            if not isinstance(config["cwd"], str):
                result.add_error(
                    "backend.config.cwd", "Working directory must be a string"
                )

    def _validate_http_backend(
        self, config: dict[str, Any], result: ValidationResult
    ) -> None:
        """Validate HTTP backend configuration."""
        required_fields = ["base_url"]

        for field in required_fields:
            if field not in config:
                result.add_error(
                    f"backend.config.{field}", f"HTTP backend requires '{field}'"
                )

        if "base_url" in config:
            if not isinstance(config["base_url"], str):
                result.add_error("backend.config.base_url", "Base URL must be a string")
            elif not self._is_valid_url(config["base_url"]):
                result.add_error("backend.config.base_url", "Base URL is not valid")

        if "timeout" in config:
            if not isinstance(config["timeout"], int | float):
                result.add_error("backend.config.timeout", "Timeout must be a number")
            elif config["timeout"] <= 0:
                result.add_error("backend.config.timeout", "Timeout must be positive")

    def _validate_websocket_backend(
        self, config: dict[str, Any], result: ValidationResult
    ) -> None:
        """Validate WebSocket backend configuration."""
        required_fields = ["url"]

        for field in required_fields:
            if field not in config:
                result.add_error(
                    f"backend.config.{field}", f"WebSocket backend requires '{field}'"
                )

        if "url" in config:
            if not isinstance(config["url"], str):
                result.add_error("backend.config.url", "WebSocket URL must be a string")
            elif not config["url"].startswith(("ws://", "wss://")):
                result.add_error(
                    "backend.config.url",
                    "WebSocket URL must start with ws:// or wss://",
                )

    def _validate_tools(self, tools: Any, result: ValidationResult) -> None:
        """Validate the tools array."""
        if not isinstance(tools, list):
            result.add_error("tools", "Tools must be an array")
            return

        if len(tools) == 0:
            result.add_warning("tools", "No tools defined")
            return

        tool_names = set()
        for i, tool in enumerate(tools):
            self._validate_tool(tool, i, result)

            # Check for duplicate tool names
            if isinstance(tool, dict) and "name" in tool:
                name = tool["name"]
                if name in tool_names:
                    result.add_error(
                        f"tools[{i}].name", f"Duplicate tool name '{name}'"
                    )
                else:
                    tool_names.add(name)

    def _validate_tool(self, tool: Any, index: int, result: ValidationResult) -> None:
        """Validate a single tool definition."""
        path_prefix = f"tools[{index}]"

        if not isinstance(tool, dict):
            result.add_error(f"{path_prefix}", "Tool must be an object")
            return

        # Required tool fields
        required_fields = ["name", "description", "args"]
        for field in required_fields:
            if field not in tool:
                result.add_error(
                    f"{path_prefix}.{field}", f"Tool requires '{field}' field"
                )

        # Validate tool name
        if "name" in tool:
            name = tool["name"]
            if not isinstance(name, str):
                result.add_error(f"{path_prefix}.name", "Tool name must be a string")
            elif not name.strip():
                result.add_error(f"{path_prefix}.name", "Tool name cannot be empty")
            elif not re.match(r"^[a-zA-Z_][a-zA-Z0-9_]*$", name):
                result.add_warning(
                    f"{path_prefix}.name", "Tool name should be a valid identifier"
                )

        # Validate tool description
        if "description" in tool:
            desc = tool["description"]
            if not isinstance(desc, str):
                result.add_error(
                    f"{path_prefix}.description", "Tool description must be a string"
                )
            elif not desc.strip():
                result.add_warning(
                    f"{path_prefix}.description", "Tool description is empty"
                )

        # Validate tool args
        if "args" in tool:
            args = tool["args"]
            if not isinstance(args, list):
                result.add_error(f"{path_prefix}.args", "Tool args must be an array")
            else:
                for j, arg in enumerate(args):
                    if not isinstance(arg, str):
                        result.add_error(
                            f"{path_prefix}.args[{j}]", "All args must be strings"
                        )

        # Validate tool parameters (optional)
        if "parameters" in tool:
            self._validate_tool_parameters(
                tool["parameters"], f"{path_prefix}.parameters", result
            )

    def _validate_tool_parameters(
        self, parameters: Any, path: str, result: ValidationResult
    ) -> None:
        """Validate tool parameters array."""
        if not isinstance(parameters, list):
            result.add_error(path, "Parameters must be an array")
            return

        param_names = set()
        for i, param in enumerate(parameters):
            param_path = f"{path}[{i}]"

            if not isinstance(param, dict):
                result.add_error(param_path, "Parameter must be an object")
                continue

            # Required parameter fields
            required_fields = ["name", "type", "description"]
            for field in required_fields:
                if field not in param:
                    result.add_error(
                        f"{param_path}.{field}", f"Parameter requires '{field}' field"
                    )

            # Validate parameter name
            if "name" in param:
                name = param["name"]
                if not isinstance(name, str):
                    result.add_error(
                        f"{param_path}.name", "Parameter name must be a string"
                    )
                elif not name.strip():
                    result.add_error(
                        f"{param_path}.name", "Parameter name cannot be empty"
                    )
                elif name in param_names:
                    result.add_error(
                        f"{param_path}.name", f"Duplicate parameter name '{name}'"
                    )
                else:
                    param_names.add(name)

            # Validate parameter type
            if "type" in param:
                param_type = param["type"]
                if not isinstance(param_type, str):
                    result.add_error(
                        f"{param_path}.type", "Parameter type must be a string"
                    )
                elif param_type not in self.VALID_PARAM_TYPES:
                    result.add_error(
                        f"{param_path}.type",
                        f"Invalid parameter type '{param_type}'. "
                        f"Valid types: {', '.join(self.VALID_PARAM_TYPES)}",
                    )

            # Validate parameter description
            if "description" in param:
                desc = param["description"]
                if not isinstance(desc, str):
                    result.add_error(
                        f"{param_path}.description",
                        "Parameter description must be a string",
                    )
                elif not desc.strip():
                    result.add_warning(
                        f"{param_path}.description", "Parameter description is empty"
                    )

    def _validate_consistency(
        self, config: dict[str, Any], result: ValidationResult
    ) -> None:
        """Validate consistency between different parts of the config."""
        if "tools" not in config or "backend" not in config:
            return

        tools = config["tools"]

        # Check if tools reference parameters that exist
        for i, tool in enumerate(tools):
            if not isinstance(tool, dict):
                continue

            args = tool.get("args", [])
            parameters = tool.get("parameters", [])

            if not isinstance(args, list) or not isinstance(parameters, list):
                continue

            # Extract parameter names from args (look for {param} patterns)
            arg_params = set()
            for arg in args:
                if isinstance(arg, str):
                    matches = re.findall(r"\{(\w+)\}", arg)
                    arg_params.update(matches)

            # Get defined parameter names
            defined_params = set()
            for param in parameters:
                if isinstance(param, dict) and "name" in param:
                    defined_params.add(param["name"])

            # Check for missing parameter definitions
            missing_params = arg_params - defined_params
            for param in missing_params:
                result.add_error(
                    f"tools[{i}].parameters",
                    f"Parameter '{param}' used in args but not defined",
                )

            # Check for unused parameter definitions
            unused_params = defined_params - arg_params
            for param in unused_params:
                result.add_warning(
                    f"tools[{i}].parameters",
                    f"Parameter '{param}' defined but not used in args",
                )

    def _is_valid_url(self, url: str) -> bool:
        """Check if a URL is valid."""
        url_pattern = re.compile(
            r"^https?://"  # http:// or https://
            r"(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|"  # domain...
            r"localhost|"  # localhost...
            r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"  # ...or ip
            r"(?::\d+)?"  # optional port
            r"(?:/?|[/?]\S+)$",
            re.IGNORECASE,
        )
        return url_pattern.match(url) is not None


def validate_config_file(file_path: str | Path) -> ValidationResult:
    """
    Validate an MCP configuration file.

    Args:
        file_path: Path to the JSON configuration file

    Returns:
        ValidationResult with errors and warnings
    """
    validator = MCPConfigValidator()
    return validator.validate_file(file_path)


def validate_config_dict(config: dict[str, Any]) -> ValidationResult:
    """
    Validate an MCP configuration dictionary.

    Args:
        config: Configuration dictionary to validate

    Returns:
        ValidationResult with errors and warnings
    """
    validator = MCPConfigValidator()
    return validator.validate_config(config)


def print_validation_results(result: ValidationResult, verbose: bool = False) -> None:
    """
    Print validation results in a formatted way.

    Args:
        result: ValidationResult to print
        verbose: Whether to show detailed error messages
    """
    print(result.get_summary())

    if verbose or not result.is_valid:
        if result.errors:
            print("\n❌ Errors:")
            for error in result.errors:
                path_str = f" ({error.path})" if error.path else ""
                print(f"  • {error.field}: {error.message}{path_str}")

        if result.warnings:
            print("\n⚠️  Warnings:")
            for warning in result.warnings:
                path_str = f" ({warning.path})" if warning.path else ""
                print(f"  • {warning.field}: {warning.message}{path_str}")
