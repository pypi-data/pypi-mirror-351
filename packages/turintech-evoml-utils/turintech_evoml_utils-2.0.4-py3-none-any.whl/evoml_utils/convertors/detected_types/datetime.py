from typing import Optional
from datetime import datetime, date
import logging


import re
import numpy as np
import pandas as pd


DATETIME_FIELD_PATTERN = re.compile(
    "\\d+|january|jan|february|feb|march|mar|april|apr|may|june|jun|july|jul|"
    "august|aug|september|sep|october|oct|november|nov|december|dec",
    re.IGNORECASE,
)


logger = logging.getLogger("evoml-utils")


def to_datetime_column(
    dates: pd.Series,
    datetime_order: Optional[str] = None,
    dayfirst: bool = False,
    yearfirst: bool = False,
    format: Optional[str] = None,
) -> pd.Series:
    """Converts a pandas Series of date strings into a Series of datetime64 objects.

    Args:
        dates: A pandas Series containing date/time data as strings.
        dayfirst: If True, prefer to parse ambiguous dates with the day coming first.
        yearfirst: If True, prefer to parse ambiguous dates with the year coming first.
        format: An optional format string to specify the exact date format (e.g., '%Y-%m-%d').

    Returns:
        A pandas Series of datetime64[ns] dtype containing the converted dates.
        Invalid or unparseable dates are replaced with np.nan.
    """

    if datetime_order is not None:
        logger.warning(
            "The `datetime_order` keyword argument is deprecated and will be removed in evoml_utils v3.0.0. We "
            "recommended that you re-upload this dataset."
        )
        return _to_datetime_column_deprecated(dates, datetime_order)

    if pd.api.types.is_datetime64_any_dtype(dates):
        return dates

    # datetime.time actually resolves to string dtype, so inspecting an element is easier
    if not isinstance(dates.iloc[0], str):
        dates = dates.astype(str)

    return pd.to_datetime(dates, dayfirst=dayfirst, yearfirst=yearfirst, format=format, errors="coerce")


MONTH_MAPPINGS = {
    "january": 1,
    "jan": 1,
    "february": 2,
    "feb": 2,
    "march": 3,
    "mar": 3,
    "april": 4,
    "apr": 4,
    "may": 5,
    "june": 6,
    "jun": 6,
    "july": 7,
    "jul": 7,
    "august": 8,
    "aug": 8,
    "september": 9,
    "sep": 9,
    "october": 10,
    "oct": 10,
    "november": 11,
    "nov": 11,
    "december": 12,
    "dec": 12,
}


def _to_datetime_column_deprecated(dates: pd.Series, datetime_order: Optional[str] = None) -> pd.Series:
    """This function is deprecated. It is retained for backwards compatibility when preprocessing datasets which were
    analysed using evoml-type-detector<2.0.0. These datasets will not have the new `format`, `dayfirst`, and `yearfirst`
    arguments stored in their ColumnInfo.metadata["to_datetime_kwargs"] dictionary.

    Converts data into pd.Series of datetime objects / np.nan.

    The function works with series of strings of the same datetime format and unix
    timestamps in string and integer formats.

    Parses a pandas series of string dates, all formatted using the same format.
    Parses multiple strings formatted using the same format. Parses unix timestamps
    if the ratio of missing and invalid values does not exceed 0.1.
    If the string parsed is np.nan, that value (np.nan) is returned as is.

    Args:
        dates (pd.Series): Series of dates to convert.

        datetime_order (Optional[str]):
            A string to represent the datetime order, the datetime_order
            generated by type detection should be used.
            Is not required for unix timestamps conversion.
            Defaults to None.

    Returns:
        (pd.Series): Of datetime / np.nan
    """

    if pd.api.types.is_datetime64_any_dtype(dates):
        return dates

    # This is for unix timestamp conversion
    if dates.dtype in ["int64", "int32", "float64", "float32"] and dates.isnull().sum() / dates.shape[0] <= 0.1:
        return pd.to_datetime(dates, errors="coerce", unit="s")

    def parse_date(_date):
        parsed = np.nan
        if isinstance(_date, date):
            parsed = datetime.combine(_date, datetime.min.time())
        elif isinstance(_date, datetime):
            parsed = _date
        elif isinstance(_date, str):
            values = DATETIME_FIELD_PATTERN.findall(_date)
            is_pm = _date.lower().find("pm") > 0
            year = 2021
            month = 1
            day = 1
            hour = 0
            minute = 0
            second = 0
            if len(values) >= len(datetime_order):
                try:
                    for i in range(len(datetime_order)):
                        if datetime_order[i] == "y":
                            year = int(values[i])
                            # if year is only 2 digits, set it to within [1951 - 2050]
                            if year < 50:
                                year += 2000
                            elif year < 100:
                                year += 1900
                        elif datetime_order[i] == "m":
                            try:
                                month = int(values[i])
                            except ValueError:
                                month = MONTH_MAPPINGS[values[i].lower()]
                        elif datetime_order[i] == "d":
                            day = int(values[i])
                        elif datetime_order[i] == "H":
                            hour = int(values[i])
                            if is_pm and hour < 12:
                                hour += 12
                        elif datetime_order[i] == "M":
                            minute = int(values[i])
                        elif datetime_order[i] == "S":
                            second = int(values[i])
                    parsed = datetime(year, month, day, hour, minute, second)
                except:
                    pass
        return parsed

    return dates.apply(parse_date)
