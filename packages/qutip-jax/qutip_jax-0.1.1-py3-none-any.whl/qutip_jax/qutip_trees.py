from qutip import Qobj, QobjEvo
from jax import tree_util
from qutip.core.cy._element import *
from .qobjevo import JaxJitCoeff

__all__ = []


def qobj_tree_flatten(qobj):
    children = (qobj.to("jax").data,)
    aux_data = {
        "_dims": qobj._dims,
        # Attribute that depend on the data are not safe to be set.
        "_isherm": None,
        "_isunitary": None,
    }
    return (children, aux_data)


def qobj_tree_unflatten(aux_data, children):
    out = Qobj.__new__(Qobj)
    out._data = children[0]
    for attr, val in aux_data.items():
        setattr(out, attr, val)
    return out


tree_util.register_pytree_node(Qobj, qobj_tree_flatten, qobj_tree_unflatten)


def _QobjEvo_flatten(qevo):
    # We could extract the data from reduce
    # But it is automatically generated by cython.
    # I am not sure if the order is constant across version/OS.
    state = qevo._getstate()
    children = (state.pop("elements"),)
    return children, state


def _QobjEvo_unflatten(aux_data, children):
    return QobjEvo._restore(children[0], **aux_data)


tree_util.register_pytree_node(QobjEvo, _QobjEvo_flatten, _QobjEvo_unflatten)


#############################################
#   QobjEvo Elements pytree registrations   #
#############################################
def _ConstantElement_flatten(element):
    return (element.qobj(0),), {}


def _ConstantElement_unflatten(aux_data, children):
    return _ConstantElement(children[0])


tree_util.register_pytree_node(
    _ConstantElement, _ConstantElement_flatten, _ConstantElement_unflatten
)


def _EvoElement_flatten(element):
    qobj = element._qobj
    coeff = element._coefficient
    if isinstance(coeff, JaxJitCoeff):
        return (qobj, coeff), ()
    return (qobj,), (coeff,)


def _EvoElement_unflatten(aux_data, children):
    return _EvoElement(*children, *aux_data)


tree_util.register_pytree_node(
    _EvoElement, _EvoElement_flatten, _EvoElement_unflatten
)


def _FuncElement_flatten(element):
    aux_data = {
        "func": element._func,
        "_f_pythonic": element._f_pythonic,
        "_f_parameters": element._f_parameters,
    }
    return (element._args,), aux_data


def _FuncElement_unflatten(aux_data, children):
    func = aux_data.pop("func")
    return _FuncElement(func, *children, **aux_data)


tree_util.register_pytree_node(
    _FuncElement, _FuncElement_flatten, _FuncElement_unflatten
)


def _MapElement_flatten(element):
    return (element._base, element._coeff), (element._transform,)


def _MapElement_unflatten(aux_data, children):
    base, coeff = children
    (transform,) = aux_data
    return _MapElement(base, transform, coeff)


tree_util.register_pytree_node(
    _MapElement, _MapElement_flatten, _MapElement_unflatten
)


def _ProdElement_flatten(element):
    return (element._left, self._right), (element._transform, element._conj)


def _ProdElement_unflatten(aux_data, children):
    return _ProdElement(*children, *aux_data)


tree_util.register_pytree_node(
    _ProdElement, _ProdElement_flatten, _ProdElement_unflatten
)
