# Import Modulebms_resetdef 
from tkinter import *
from tkinter import ttk
import time
from threading import Thread
from timeit import default_timer as timer
from enum import Enum
import datetime
from time import sleep, time,perf_counter_ns
import can
import os
import math
import cantools
import RPi.GPIO as GPIO
import asyncio
import serial
import pyvisa as visa
from itertools import product
import struct
import bisect
from pymodbus.datastore import ModbusSequentialDataBlock, ModbusSlaveContext, ModbusServerContext
from pymodbus.client import ModbusSerialClient as msc
from pymodbus.payload import BinaryPayloadDecoder as pp

from pymodbus.transaction import ModbusRtuFramer
import pandas as pd
import tkinter as tk

CMS_version=4.0 ### 4.2
#####make sure that pymodbus version in sudo pip3 is 3.1.3

#region TK variables  

def create_canvas(main_frame):
    # Canvas & Scrollbar setup
    canvas = tk.Canvas(main_frame)
    v_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    h_scrollbar = ttk.Scrollbar(main_frame, orient="horizontal", command=canvas.xview)
    
    inner_frame = ttk.Frame(canvas)

    # Configure canvas scroll region update
    def on_configure(event):
        canvas.configure(scrollregion=canvas.bbox("all"))

    inner_frame.bind("<Configure>", on_configure)

    # Add frame inside canvas
    window_id = canvas.create_window((0, 0), window=inner_frame, anchor="nw")

    # Set scrolling commands
    canvas.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)

    # Grid Layout
    canvas.grid(row=0, column=0, sticky="nsew")
    v_scrollbar.grid(row=0, column=1, sticky="ns")
    h_scrollbar.grid(row=1, column=0, sticky="ew")

    main_frame.grid_rowconfigure(0, weight=1)
    main_frame.grid_columnconfigure(0, weight=1)
    return inner_frame


   
# Create Object
root = Tk()
curr_str=""
total_time=10
last_time=0
lb=None
# Set geometry
root.geometry("800x800")
root.title('P4_FW_tester_8.4')

notebook = ttk.Notebook(root)
notebook.grid(row=0, column=0, sticky="nsew")

root.grid_rowconfigure(0, weight=1)
root.grid_columnconfigure(0, weight=1)

frame1_base = ttk.Frame(notebook)
notebook.add(frame1_base, text=f"input_mapping")

frame2_base = ttk.Frame(notebook)
notebook.add(frame2_base, text=f"protections")

frame3_base = ttk.Frame(notebook)
notebook.add(frame3_base, text=f"charge_cycle")

frame4_base = ttk.Frame(notebook)
notebook.add(frame4_base, text=f"algo")

frame5_base = ttk.Frame(notebook)
notebook.add(frame5_base, text=f"consecutive_charge")

frame1=create_canvas(frame1_base)
frame2=create_canvas(frame2_base)
frame3=create_canvas(frame3_base)
frame4=create_canvas(frame4_base)
frame5=create_canvas(frame5_base)





test_timings={
    'input_mapping_thermistor_mapping':0,
'input_mapping_temperature_range':0,
'input_mapping_current_sensor':0,
'input_mapping_pressure_sensor':0,
'input_mapping_gpio_mapping':0,
'input_mapping_cp_activation':0,
'input_mapping_battery_polarity_detection':0,
'input_mapping_rectifier_readback':0,
'input_mapping_chiller_readback':0,
'input_mapping_heater_readback':0,
'input_mapping_EM_readback':0,
'input_mapping_BMS_can_datarate':0,
'protections_input_grid_spd_fault':0,
'protections_input_grid_elr_fault':0,
'protections_input_grid_VR_fault':0,
'protections_input_grid_em_sw':0,
'protections_input_grid_grid_power_cut':0,
'protections_output_power_rectifier_ref_curr_offset_positive':0,
'protections_output_power_rectifier_ref_curr_offset_negative':0,
'protections_output_power_Reference_sensor_Current_offset_Positive':0,
'protections_output_power_Reference_sensor_Current_offset_Negative':0,
'protections_output_power_Rectifier_derated':0,
'protections_output_power_Over_current':0,
'protections_output_power_No_Current_Fault':0,
'protections_output_power_precharge_fail_protection_before_relay':0,
'protections_output_power_precharge_fail_protection_after_relay':0,
'protections_sensor_failure_1_current_sensor_open_protection':0,
'protections_sensor_failure_1_Current_sensor_fail_faulty_offset':0,
'protections_sensor_failure_1_gun_temp_sensor_open_low_protection_1_2':0,
'protections_sensor_failure_1_gun_temp_sensor_open_high_protection_1_2':0,
'protections_sensor_failure_1_gun_temp_sensor_open_low_protection_3_4':0,
'protections_sensor_failure_1_gun_temp_sensor_open_high_protection_3_4':0,
'protections_sensor_failure_1_Positive_GunTempSense_lowside_fault':0,
'protections_sensor_failure_1_Positive_GunTempSense_highside_fault':0,
'protections_sensor_failure_1_Negative_GunTempSense_lowside_fault':0,
'protections_sensor_failure_1_Negative_GunTempSense_highside_fault':0,
'protections_sensor_failure_1_Hot_tank_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Hot_tank_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_1_Cold_tank_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Cold_tank_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_1_Inlet_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Inlet_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_1_Outlet_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Outlet_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_2_charge_DC_contcator_open_protection':0,
'protections_sensor_failure_2_Charger_DC_polarity_reverse':0,
'protections_sensor_failure_2_CMS_48V_detection_circuit_fault':0,
'protections_sensor_failure_2_check_dc_contactor_weld_detection':0,
'protections_sensor_failure_2_check_dc_contactor_rev_weld_detection':0,
'protections_sensor_failure_2_polarity_reverse_protection':0,
'protections_sensor_failure_2_BMS_contactor_weld_forward_protection':0,
'protections_sensor_failure_2_BMS_contactor_weld_rev_protection':0,
'protections_sensor_failure_2_BMS_contactor_open_protection':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_1':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_2':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_3':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_4':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_1':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_2':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_3':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_4':0,
'protections_sensor_failure_2_Heater_Comm_Fail_test':0,
'protections_sensor_failure_2_Chiller_Comm_Fail_test':0,
'protections_sensor_failure_2_EM_Comm_Fail_test':0,
'protections_sensor_failure_2_smoke_sensor_detect_protection_test':0,
'protections_sensor_failure_2_phase_reversal_test':0,
"protections_sensor_failure_2_current_sensor_Low_Temp":0,
"protections_sensor_failure_2_current_sensor_High_Temp":0,
'protections_mechanical_chiller_faul_detection':0,
'protections_mechanical_chiller_aft_fault_detection':0,
'protections_mechanical_AFT_fault_cms_computed_fault':0,
'protections_mechanical_chiller_hp_fault_detection':0,
'protections_mechanical_chiller_low_liquid_level_fault_detection':0,
'protections_mechanical_chiller_recoverable_faul_detection':0,
'protections_mechanical_chiller_LP_fault':0,
'protections_mechanical_chiller_compressor_overload_fault_test':0,
'protections_mechanical_pump_overload_fault_test':0,
'protections_mechanical_chiller_non_recoverable_faul_detection':0,
'protections_mechanical_Chiller_LiquidTemp_Inlet_outlet_water_temp_offset':0,
'protections_mechanical_battery_conditioning_fail_high_chiller_temp_test':0,
'protections_mechanical_battery_conditioning_cooling_fail_test':0,
'protections_mechanical_Chiller_Settings_Check':0,
'protections_mechanical_cold_tank_low_liquid_level_fault_detection':0,
'protections_mechanical_Fluid_Inlet_High_Temp_Fault_high_temp':0,
'protections_mechanical_Fluid_Inlet_High_Temp_Fault_offset':0,
'protections_mechanical_battery_conditioning_heating_fail_test':0,
'protections_mechanical_hot_tank_low_water_fault':0,
'protections_mechanical_CMS_HotTank_Overtemp_protect_cms_sensor_test':0,
'protections_mechanical_CMS_HotTank_Overtemp_protect_heater_sensor_test':0,
'protections_mechanical_CMS_HotTank_Overtemp_cutoff_test':0,
'protections_mechanical_heater_low_temp_fault':0,
'protections_mechanical_heater_high_temp_fault':0,
'protections_mechanical_CMS_HotTank_offset_test':0,
'protections_mechanical_heater_low_water_fault':0,
'protections_mechanical_heater_probe_low_fault':0,
'protections_mechanical_heater_probe_high_fault':0,
'protections_mechanical_mbv_open_fault_test':0,
'protections_mechanical_mbv_close_fault_test':0,
'protections_mechanical_Air_Comp_Overheat_Protection_test':0,
'protections_charge_algo_station_cell_over_voltage':0,
'protections_charge_algo_station_over_temp':0,
'protections_charge_algo_station_under_temp':0,
'protections_charge_algo_imcomplete_charge':0,
'protections_charge_algo_station_pack_temp_ib':0,
'protections_charge_algo_station_pack_voltage_ib':0,
'protections_charge_algo_tec_failure':0,
'protections_cloud_interaction_BMS_OTA_Dont_Do_Cmd':0,
'protections_cloud_interaction_BMS_OTA_Bootloader_Start_Fail':0,
'protections_cloud_interaction_Vehicle_blacklisted':0,
'protections_cloud_interaction_fut_protection_test':0,
'protections_cloud_interaction_BMS_OTA_target_fw_unavailable':0,
'protections_cloud_interaction_BMS_flasher_error_check':0,
"protections_cloud_interaction_BMS_only_BL_ota_check_available":0,
"protections_cloud_interaction_BMS_only_BL_ota_check_no_FW":0,

'protections_BMS_interaction_BMS_charge_protection_test':0,
'protections_BMS_interaction_BMS_can_freeze_test':0,
'protections_BMS_interaction_BMS_state_error_test':0,
'protections_BMS_interaction_BMS_wakeup_fail':0,
'protections_gun_lock_unlock_unintentional_gun_unlock_test':0,
'protections_gun_lock_unlock_GunLockFailed_1st_attempt':0,
'protections_gun_lock_unlock_unautharized_gun_removal':0,
'protections_gun_lock_unlock_unlock_failure':0,
'protections_gun_lock_unlock_gun_lock_fail_with_early_fb':0,
'protections_gun_lock_unlock_gun_theft_fault_test':0,
'protections_gun_lock_unlock_Gun_Locked_In_Air_partial_unlock':0,
'protections_gun_lock_unlock_Gun_Locked_In_Air_full_unlock':0,
'protections_gun_temp_gun_temp_ib_fault_1_2_B3':0,
'protections_gun_temp_gun_temp_ib_fault_1_3_B3':0,
'protections_gun_temp_gun_temp_ib_fault_3_4_B3':0,
'protections_gun_temp_gun_temp_ib_fault_1_2_TG':0,
'protections_gun_temp_gun_temp_ib_fault_1_3_TG':0,
'protections_gun_temp_gun_temp_ib_fault_3_4_TG':0,
'protections_gun_temp_gun_temp_ib_detect_1_2':0,
'protections_gun_temp_gun_temp_ib_detect_1_3':0,
'protections_gun_temp_gun_temp_ib_detect_3_4':0,
'protections_gun_temp_gun_over_temp_cutoff_all':0,
'protections_gun_temp_gun_over_temp_warning_all':0,
'protection_actions_input_power_protection_action_standby_test':0,
'protection_actions_input_power_protection_action_charge_test':0,
'protection_actions_bms_protection_action_charge_test':0,
'protection_actions_e_plug_protection_action_charge_test':0,
'protection_actions_output_power_protection_action_standby_test':0,
'protection_actions_output_power_protection_action_charge_test':0,
'protection_actions_fcs_battery_heating_action_charge_test':0,
'protection_actions_fcs_internal_cooling_action_standby_test':0,
'protection_actions_fcs_internal_cooling_action_charge_test':0,
'protection_actions_fcs_battery_cooling_action_charge_test':0,
'charge_cycle_TG1_normal_charge_no_precondition':0,
'charge_cycle_TG1_CHTZ_charge_no_precondition':0,
'charge_cycle_TG1_normal_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':0,
'charge_cycle_TG1_normal_charge_precooling':0,
'charge_cycle_TG1_CHTZ_charge_precooling':0,
'charge_cycle_TG1_normal_charge_preheating':0,
'charge_cycle_TG1_CHTZ_charge_preheating':0,
'charge_cycle_TG1_normal_charge_precooling_chiller_failure':0,
'charge_cycle_TG1_normal_charge_preheating_heater_failure':0,
'charge_cycle_TGM_normal_charge_no_precondition':0,
'charge_cycle_TGM_CHTZ_charge_no_precondition':0,
'charge_cycle_TGM_normal_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':0,
'charge_cycle_TGM_normal_charge_precooling':0,
'charge_cycle_TGM_CHTZ_charge_precooling':0,
'charge_cycle_TGM_normal_charge_preheating':0,
'charge_cycle_TGM_CHTZ_charge_preheating':0,
'charge_cycle_B3_normal_charge_no_precondition':0,
'charge_cycle_B3_normal_charge_precooling':0,
'charge_cycle_B3_normal_charge_preheating':0,
'charge_cycle_TG1_normal_charge_no_precondition_10_rectifiers':0,
'charge_cycle_TG1_normal_charge_no_precondition_6_rectifiers':0,
'charge_cycle_TG1_normal_charge_no_precondition_10.1_profile_cloud':0,
'charge_cycle_TG1_430_normal_charge_no_precondition':0,
'charge_cycle_TG1_430_CHTZ_charge_no_precondition':0,
'charge_cycle_TG1_430_normal_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':0,
'charge_cycle_TG1_430_normal_charge_precooling':0,
'charge_cycle_TG1_430_CHTZ_charge_precooling':0,
'charge_cycle_TG1_430_normal_charge_preheating':0,
'charge_cycle_TG1_430_CHTZ_charge_preheating':0,
'common_algo_check_max_rect_voltage':0,
'common_algo_master_error_code_test':0,
'common_algo_CP4V_debounce_test':0,
'common_algo_charge_algo_latching_check':0,
'common_algo_chiller_remote_off_before_aft':0,
'common_algo_chiller_remote_off_before_aft_during_precooling':0,
'common_algo_persisting_epump_id':0,
'common_algo_session_conter_increment':0,
'common_algo_calage_sending_check':0,
'common_algo_bms_wakeup':0,
'common_algo_current_calibration_test':0,
"common_algo_dc_contactor_weld_check_skip":0,
"common_algo_gun_temp_current_deration_during_charge_false_TEC":0,
"common_algo_false_tec_with_fast_gun_connection":0,
"common_algo_reverse_cx_gun_lock":0,
"common_algo_gun_temp_sensor_open_rejection_test":0,
"common_algo_gun_temp_deartion_table_TG_352":0,
"common_algo_gun_temp_deartion_table_TG_430":0,
"common_algo_gun_temp_deartion_table_TGmax":0,
"common_algo_gun_temp_deartion_table_B3":0,
"common_algo_pump_interlock":0,
"common_algo_min_temp_deration":0,
"common_algo_max_temp_deration":0,
"common_algo_can_fast_toggle_test":0,
'common_algo_can_slow_toggle_test':0,
'common_algo_fast_gun_toggle_test':0,
'common_algo_slow_gun_toggle_test':0,
"common_algo_fast_gun_toggle_before_charge":0,
"common_algo_slow_gun_toggle_before_charge":0,
'algo_TG1_fake_bms_current':0,
'algo_TG1_check_voltage_ib_non_chtz_high_vol':0,
'algo_TG1_check_voltage_ib_non_chtz_low_vol':0,
'algo_TG1_check_voltage_ib_chtz_higher_voltage':0,
'algo_TG1_check_voltage_ib_chtz_lower_voltage':0,
'algo_TG1_check_chtz_0_0':0,
'algo_TG1_check_chtz_4_0':0,
'algo_TG1_check_chtz_7_0':0,
'algo_TG1_check_chtz_50_4':0,
'algo_TG1_check_chtz_52_4':0,
'algo_TG1_check_chtz_60_51':0,
'algo_TG1_check_chtz_61_60':0,
'algo_TG1_check_chtz_104_100':0,
'algo_TG1_check_chtz_305_100':0,
'algo_TG1_check_chtz_301_300':0,
'algo_TG1_check_chtz_304_300':0,
'algo_TG1_min_cell_temp_computed_verification':0,
'algo_TG1_bms_reset_ah':0,
'algo_TG1_bms_state_change_ah_non':0,
'algo_TG1_TEC_failure_wrong_ah':0,
'algo_TG1_TEC_failure_wrong_soc':0,
'algo_TG1_TEC_failure_wrong_soc_tollerance':0,
'algo_TG1_user_soc_lock':0,
'algo_TG1_gun_temp_current_deration_no_previos_cutoff':0,
'algo_TG1_gun_temp_current_deration_after_cutoff':0,
'algo_TGM_fake_bms_current':0,
'algo_TGM_check_voltage_ib_non_chtz_high_vol':0,
'algo_TGM_check_voltage_ib_non_chtz_low_vol':0,
'algo_TGM_check_voltage_ib_chtz_higher_voltage':0,
'algo_TGM_check_voltage_ib_chtz_lower_voltage':0,
'algo_TGM_check_chtz_0_0':0,
'algo_TGM_check_chtz_4_0':0,
'algo_TGM_check_chtz_7_0':0,
'algo_TGM_check_chtz_50_4':0,
'algo_TGM_check_chtz_52_4':0,
'algo_TGM_check_chtz_60_51':0,
'algo_TGM_check_chtz_61_60':0,
'algo_TGM_check_chtz_104_100':0,
'algo_TGM_check_chtz_305_100':0,
'algo_TGM_check_chtz_301_300':0,
'algo_TGM_check_chtz_304_300':0,
'algo_TGM_min_cell_temp_computed_verification':0,
'algo_TGM_bms_reset_ah':0,
'algo_TGM_bms_state_change_ah_non':0,
'algo_TGM_TEC_failure_wrong_ah':0,
'algo_TGM_TEC_failure_wrong_soc':0,
'algo_TGM_TEC_failure_wrong_soc_tollerance':0,
'algo_TGM_user_soc_lock':0,
'algo_TGM_gun_temp_current_deration_no_previos_cutoff':0,
'algo_TGM_gun_temp_current_deration_after_cutoff':0,
'algo_B3_fake_bms_current':0,
'algo_B3_check_voltage_ib_non_chtz_high_vol':0,
'consecutive_charge_cycle_B3_matlab_B3_C_code':0,
'consecutive_charge_cycle_B3_matlab_TG_matlab':0,
'consecutive_charge_cycle_B3_matlab_TG_C':0,
'consecutive_charge_cycle_B3_matlab_TGmax_C':0,
'consecutive_charge_cycle_B3_matlab_TG_430_C':0,
'consecutive_charge_cycle_B3_C_B3_matlab_code':0,
'consecutive_charge_cycle_B3_C_TG_matlab':0,
'consecutive_charge_cycle_B3_C_TG_C':0,
'consecutive_charge_cycle_B3_C_TGmax_C':0,
'consecutive_charge_cycle_B3_C_TG_430_C':0,
'consecutive_charge_cycle_TG_matlab_B3_matlab_code':0,
'consecutive_charge_cycle_TG_matlab_B3_C':0,
'consecutive_charge_cycle_TG_matlab_TG_C':0,
'consecutive_charge_cycle_TG_matlab_TGmax_C':0,
'consecutive_charge_cycle_TG_matlab_TG_430_C':0,
'consecutive_charge_cycle_TG_C_B3_matlab_code':0,
'consecutive_charge_cycle_TG_C_B3_C':0,
'consecutive_charge_cycle_TG_C_TG_matlab':0,
'consecutive_charge_cycle_TG_C_TGmax_C':0,
'consecutive_charge_cycle_TG_C_TG_430_C':0,
'consecutive_charge_cycle_TGM_C_B3_matlab_code':0,
'consecutive_charge_cycle_TGM_C_B3_C':0,
'consecutive_charge_cycle_TGM_C_TG_matlab':0,
'consecutive_charge_cycle_TGM_C_TG1_C':0,
'consecutive_charge_cycle_TGM_C_TG_430_C':0,
'consecutive_charge_cycle_TG_430_C_B3_matlab_code':0,
'consecutive_charge_cycle_TG_430_C_B3_C':0,
'consecutive_charge_cycle_TG_430_C_TG_matlab':0,
'consecutive_charge_cycle_TG_430_C_TG1_C':0,
'consecutive_charge_cycle_TG_430_C_TGmax_C':0,

}

test_dict={
     'input_mapping_thermistor_mapping':0,
'input_mapping_temperature_range':0,
'input_mapping_current_sensor':0,
'input_mapping_pressure_sensor':0,
'input_mapping_gpio_mapping':0,
'input_mapping_cp_activation':0,
'input_mapping_battery_polarity_detection':0,
'input_mapping_rectifier_readback':0,
'input_mapping_chiller_readback':0,
'input_mapping_heater_readback':0,
'input_mapping_EM_readback':0,
'input_mapping_BMS_can_datarate':0,
'protections_input_grid_spd_fault':0,
'protections_input_grid_elr_fault':0,
'protections_input_grid_VR_fault':0,
'protections_input_grid_em_sw':0,
'protections_input_grid_grid_power_cut':0,
'protections_output_power_rectifier_ref_curr_offset_positive':0,
'protections_output_power_rectifier_ref_curr_offset_negative':0,
'protections_output_power_Reference_sensor_Current_offset_Positive':0,
'protections_output_power_Reference_sensor_Current_offset_Negative':0,
'protections_output_power_Rectifier_derated':0,
'protections_output_power_Over_current':0,
'protections_output_power_No_Current_Fault':0,
'protections_output_power_precharge_fail_protection_before_relay':0,
'protections_output_power_precharge_fail_protection_after_relay':0,
'protections_sensor_failure_1_current_sensor_open_protection':0,
'protections_sensor_failure_1_Current_sensor_fail_faulty_offset':0,
'protections_sensor_failure_1_gun_temp_sensor_open_low_protection_1_2':0,
'protections_sensor_failure_1_gun_temp_sensor_open_high_protection_1_2':0,
'protections_sensor_failure_1_gun_temp_sensor_open_low_protection_3_4':0,
'protections_sensor_failure_1_gun_temp_sensor_open_high_protection_3_4':0,
'protections_sensor_failure_1_Positive_GunTempSense_lowside_fault':0,
'protections_sensor_failure_1_Positive_GunTempSense_highside_fault':0,
'protections_sensor_failure_1_Negative_GunTempSense_lowside_fault':0,
'protections_sensor_failure_1_Negative_GunTempSense_highside_fault':0,
'protections_sensor_failure_1_Hot_tank_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Hot_tank_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_1_Cold_tank_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Cold_tank_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_1_Inlet_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Inlet_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_1_Outlet_Watertemp_sense_lowside_fault':0,
'protections_sensor_failure_1_Outlet_Watertemp_sense_highside_fault':0,
'protections_sensor_failure_2_charge_DC_contcator_open_protection':0,
'protections_sensor_failure_2_Charger_DC_polarity_reverse':0,
'protections_sensor_failure_2_CMS_48V_detection_circuit_fault':0,
'protections_sensor_failure_2_check_dc_contactor_weld_detection':0,
'protections_sensor_failure_2_check_dc_contactor_rev_weld_detection':0,
'protections_sensor_failure_2_polarity_reverse_protection':0,
'protections_sensor_failure_2_BMS_contactor_weld_forward_protection':0,
'protections_sensor_failure_2_BMS_contactor_weld_rev_protection':0,
'protections_sensor_failure_2_BMS_contactor_open_protection':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_1':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_2':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_3':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_4':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_1':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_2':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_3':0,
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_4':0,
'protections_sensor_failure_2_Heater_Comm_Fail_test':0,
'protections_sensor_failure_2_Chiller_Comm_Fail_test':0,
'protections_sensor_failure_2_EM_Comm_Fail_test':0,
'protections_sensor_failure_2_smoke_sensor_detect_protection_test':0,
'protections_sensor_failure_2_phase_reversal_test':0,
"protections_sensor_failure_2_current_sensor_Low_Temp":0,
"protections_sensor_failure_2_current_sensor_High_Temp":0,
'protections_mechanical_chiller_faul_detection':0,
'protections_mechanical_chiller_aft_fault_detection':0,
'protections_mechanical_AFT_fault_cms_computed_fault':0,
'protections_mechanical_chiller_hp_fault_detection':0,
'protections_mechanical_chiller_low_liquid_level_fault_detection':0,
'protections_mechanical_chiller_recoverable_faul_detection':0,
'protections_mechanical_chiller_LP_fault':0,
'protections_mechanical_chiller_compressor_overload_fault_test':0,
'protections_mechanical_pump_overload_fault_test':0,
'protections_mechanical_chiller_non_recoverable_faul_detection':0,
'protections_mechanical_Chiller_LiquidTemp_Inlet_outlet_water_temp_offset':0,
'protections_mechanical_battery_conditioning_fail_high_chiller_temp_test':0,
'protections_mechanical_battery_conditioning_cooling_fail_test':0,
'protections_mechanical_Chiller_Settings_Check':0,
'protections_mechanical_cold_tank_low_liquid_level_fault_detection':0,
'protections_mechanical_Fluid_Inlet_High_Temp_Fault_high_temp':0,
'protections_mechanical_Fluid_Inlet_High_Temp_Fault_offset':0,
'protections_mechanical_battery_conditioning_heating_fail_test':0,
'protections_mechanical_hot_tank_low_water_fault':0,
'protections_mechanical_CMS_HotTank_Overtemp_protect_cms_sensor_test':0,
'protections_mechanical_CMS_HotTank_Overtemp_protect_heater_sensor_test':0,
'protections_mechanical_CMS_HotTank_Overtemp_cutoff_test':0,
'protections_mechanical_heater_low_temp_fault':0,
'protections_mechanical_heater_high_temp_fault':0,
'protections_mechanical_CMS_HotTank_offset_test':0,
'protections_mechanical_heater_low_water_fault':0,
'protections_mechanical_heater_probe_low_fault':0,
'protections_mechanical_heater_probe_high_fault':0,
'protections_mechanical_mbv_open_fault_test':0,
'protections_mechanical_mbv_close_fault_test':0,
'protections_mechanical_Air_Comp_Overheat_Protection_test':0,
'protections_charge_algo_station_cell_over_voltage':0,
'protections_charge_algo_station_over_temp':0,
'protections_charge_algo_station_under_temp':0,
'protections_charge_algo_imcomplete_charge':0,
'protections_charge_algo_station_pack_temp_ib':0,
'protections_charge_algo_station_pack_voltage_ib':0,
'protections_charge_algo_tec_failure':0,
'protections_cloud_interaction_BMS_OTA_Dont_Do_Cmd':0,
'protections_cloud_interaction_BMS_OTA_Bootloader_Start_Fail':0,
'protections_cloud_interaction_Vehicle_blacklisted':0,
'protections_cloud_interaction_fut_protection_test':0,
'protections_cloud_interaction_BMS_OTA_target_fw_unavailable':0,
'protections_cloud_interaction_BMS_flasher_error_check':0,
"protections_cloud_interaction_BMS_only_BL_ota_check_available":0,
"protections_cloud_interaction_BMS_only_BL_ota_check_no_FW":0,
'protections_BMS_interaction_BMS_charge_protection_test':0,
'protections_BMS_interaction_BMS_can_freeze_test':0,
'protections_BMS_interaction_BMS_state_error_test':0,
"protections_BMS_interaction_BMS_wakeup_fail":0,
'protections_gun_lock_unlock_unintentional_gun_unlock_test':0,
'protections_gun_lock_unlock_GunLockFailed_1st_attempt':0,
'protections_gun_lock_unlock_unautharized_gun_removal':0,
'protections_gun_lock_unlock_unlock_failure':0,
'protections_gun_lock_unlock_gun_lock_fail_with_early_fb':0,
'protections_gun_lock_unlock_gun_theft_fault_test':0,
"protections_gun_lock_unlock_Gun_Locked_In_Air_partial_unlock":0,
"protections_gun_lock_unlock_Gun_Locked_In_Air_full_unlock":0,
'protections_gun_temp_gun_temp_ib_fault_1_2_B3':0,
'protections_gun_temp_gun_temp_ib_fault_1_3_B3':0,
'protections_gun_temp_gun_temp_ib_fault_3_4_B3':0,
'protections_gun_temp_gun_temp_ib_fault_1_2_TG':0,
'protections_gun_temp_gun_temp_ib_fault_1_3_TG':0,
'protections_gun_temp_gun_temp_ib_fault_3_4_TG':0,
'protections_gun_temp_gun_temp_ib_detect_1_2':0,
'protections_gun_temp_gun_temp_ib_detect_1_3':0,
'protections_gun_temp_gun_temp_ib_detect_3_4':0,
'protections_gun_temp_gun_over_temp_cutoff_all':0,
'protections_gun_temp_gun_over_temp_warning_all':0,
'protection_actions_input_power_protection_action_standby_test':0,
'protection_actions_input_power_protection_action_charge_test':0,
'protection_actions_bms_protection_action_charge_test':0,
'protection_actions_e_plug_protection_action_charge_test':0,
'protection_actions_output_power_protection_action_standby_test':0,
'protection_actions_output_power_protection_action_charge_test':0,
'protection_actions_fcs_battery_heating_action_charge_test':0,
'protection_actions_fcs_internal_cooling_action_standby_test':0,
'protection_actions_fcs_internal_cooling_action_charge_test':0,
'protection_actions_fcs_battery_cooling_action_charge_test':0,
'charge_cycle_TG1_normal_charge_no_precondition':0,
'charge_cycle_TG1_CHTZ_charge_no_precondition':0,
'charge_cycle_TG1_normal_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':0,
'charge_cycle_TG1_normal_charge_precooling':0,
'charge_cycle_TG1_CHTZ_charge_precooling':0,
'charge_cycle_TG1_normal_charge_preheating':0,
'charge_cycle_TG1_CHTZ_charge_preheating':0,
'charge_cycle_TG1_normal_charge_precooling_chiller_failure':0,
'charge_cycle_TG1_normal_charge_preheating_heater_failure':0,
'charge_cycle_TGM_normal_charge_no_precondition':0,
'charge_cycle_TGM_CHTZ_charge_no_precondition':0,
'charge_cycle_TGM_normal_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':0,
'charge_cycle_TGM_normal_charge_precooling':0,
'charge_cycle_TGM_CHTZ_charge_precooling':0,
'charge_cycle_TGM_normal_charge_preheating':0,
'charge_cycle_TGM_CHTZ_charge_preheating':0,
'charge_cycle_B3_normal_charge_no_precondition':0,
'charge_cycle_B3_normal_charge_precooling':0,
'charge_cycle_B3_normal_charge_preheating':0,
'charge_cycle_TG1_normal_charge_no_precondition_10_rectifiers':0,
'charge_cycle_TG1_normal_charge_no_precondition_6_rectifiers':0,
'charge_cycle_TG1_normal_charge_no_precondition_10.1_profile_cloud':0,
'charge_cycle_TG1_430_normal_charge_no_precondition':0,
'charge_cycle_TG1_430_CHTZ_charge_no_precondition':0,
'charge_cycle_TG1_430_normal_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff':0,
'charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':0,
'charge_cycle_TG1_430_normal_charge_precooling':0,
'charge_cycle_TG1_430_CHTZ_charge_precooling':0,
'charge_cycle_TG1_430_normal_charge_preheating':0,
'charge_cycle_TG1_430_CHTZ_charge_preheating':0,
'common_algo_check_max_rect_voltage':0,
'common_algo_master_error_code_test':0,
'common_algo_CP4V_debounce_test':0,
'common_algo_charge_algo_latching_check':0,
'common_algo_chiller_remote_off_before_aft':0,
'common_algo_chiller_remote_off_before_aft_during_precooling':0,
'common_algo_persisting_epump_id':0,
'common_algo_session_conter_increment':0,
'common_algo_calage_sending_check':0,
"common_algo_bms_wakeup":0,
'common_algo_current_calibration_test':0,
"common_algo_dc_contactor_weld_check_skip":0,
"common_algo_gun_temp_current_deration_during_charge_false_TEC":0,
"common_algo_false_tec_with_fast_gun_connection":0,
"common_algo_reverse_cx_gun_lock":0,
"common_algo_gun_temp_sensor_open_rejection_test":0,
"common_algo_gun_temp_deartion_table_TG_352":0,
"common_algo_gun_temp_deartion_table_TG_430":0,
"common_algo_gun_temp_deartion_table_TGmax":0,
"common_algo_gun_temp_deartion_table_B3":0,
"common_algo_pump_interlock":0,
"common_algo_min_temp_deration":0,
"common_algo_max_temp_deration":0,
"common_algo_can_fast_toggle_test":0,
'common_algo_can_slow_toggle_test':0,
'common_algo_fast_gun_toggle_test':0,
'common_algo_slow_gun_toggle_test':0,
"common_algo_fast_gun_toggle_before_charge":0,
"common_algo_slow_gun_toggle_before_charge":0,

'algo_TG1_fake_bms_current':0,
'algo_TG1_check_voltage_ib_non_chtz_high_vol':0,
'algo_TG1_check_voltage_ib_non_chtz_low_vol':0,
'algo_TG1_check_voltage_ib_chtz_higher_voltage':0,
'algo_TG1_check_voltage_ib_chtz_lower_voltage':0,
'algo_TG1_check_chtz_0_0':0,
'algo_TG1_check_chtz_4_0':0,
'algo_TG1_check_chtz_7_0':0,
'algo_TG1_check_chtz_50_4':0,
'algo_TG1_check_chtz_52_4':0,
'algo_TG1_check_chtz_60_51':0,
'algo_TG1_check_chtz_61_60':0,
'algo_TG1_check_chtz_104_100':0,
'algo_TG1_check_chtz_305_100':0,
'algo_TG1_check_chtz_301_300':0,
'algo_TG1_check_chtz_304_300':0,
'algo_TG1_min_cell_temp_computed_verification':0,
'algo_TG1_bms_reset_ah':0,
'algo_TG1_bms_state_change_ah_non':0,
'algo_TG1_TEC_failure_wrong_ah':0,
'algo_TG1_TEC_failure_wrong_soc':0,
'algo_TG1_TEC_failure_wrong_soc_tollerance':0,
'algo_TG1_user_soc_lock':0,
'algo_TG1_gun_temp_current_deration_no_previos_cutoff':0,
'algo_TG1_gun_temp_current_deration_after_cutoff':0,
'algo_TGM_fake_bms_current':0,
'algo_TGM_check_voltage_ib_non_chtz_high_vol':0,
'algo_TGM_check_voltage_ib_non_chtz_low_vol':0,
'algo_TGM_check_voltage_ib_chtz_higher_voltage':0,
'algo_TGM_check_voltage_ib_chtz_lower_voltage':0,
'algo_TGM_check_chtz_0_0':0,
'algo_TGM_check_chtz_4_0':0,
'algo_TGM_check_chtz_7_0':0,
'algo_TGM_check_chtz_50_4':0,
'algo_TGM_check_chtz_52_4':0,
'algo_TGM_check_chtz_60_51':0,
'algo_TGM_check_chtz_61_60':0,
'algo_TGM_check_chtz_104_100':0,
'algo_TGM_check_chtz_305_100':0,
'algo_TGM_check_chtz_301_300':0,
'algo_TGM_check_chtz_304_300':0,
'algo_TGM_min_cell_temp_computed_verification':0,
'algo_TGM_bms_reset_ah':0,
'algo_TGM_bms_state_change_ah_non':0,
'algo_TGM_TEC_failure_wrong_ah':0,
'algo_TGM_TEC_failure_wrong_soc':0,
'algo_TGM_TEC_failure_wrong_soc_tollerance':0,
'algo_TGM_user_soc_lock':0,
'algo_TGM_gun_temp_current_deration_no_previos_cutoff':0,
'algo_TGM_gun_temp_current_deration_after_cutoff':0,
'algo_B3_fake_bms_current':0,
'algo_B3_check_voltage_ib_non_chtz_high_vol':0,
'consecutive_charge_cycle_B3_matlab_B3_C_code':0,
'consecutive_charge_cycle_B3_matlab_TG_matlab':0,
'consecutive_charge_cycle_B3_matlab_TG_C':0,
'consecutive_charge_cycle_B3_matlab_TGmax_C':0,
'consecutive_charge_cycle_B3_matlab_TG_430_C':0,
'consecutive_charge_cycle_B3_C_B3_matlab_code':0,
'consecutive_charge_cycle_B3_C_TG_matlab':0,
'consecutive_charge_cycle_B3_C_TG_C':0,
'consecutive_charge_cycle_B3_C_TGmax_C':0,
'consecutive_charge_cycle_B3_C_TG_430_C':0,
'consecutive_charge_cycle_TG_matlab_B3_matlab_code':0,
'consecutive_charge_cycle_TG_matlab_B3_C':0,
'consecutive_charge_cycle_TG_matlab_TG_C':0,
'consecutive_charge_cycle_TG_matlab_TGmax_C':0,
'consecutive_charge_cycle_TG_matlab_TG_430_C':0,
'consecutive_charge_cycle_TG_C_B3_matlab_code':0,
'consecutive_charge_cycle_TG_C_B3_C':0,
'consecutive_charge_cycle_TG_C_TG_matlab':0,
'consecutive_charge_cycle_TG_C_TGmax_C':0,
'consecutive_charge_cycle_TG_C_TG_430_C':0,
'consecutive_charge_cycle_TGM_C_B3_matlab_code':0,
'consecutive_charge_cycle_TGM_C_B3_C':0,
'consecutive_charge_cycle_TGM_C_TG_matlab':0,
'consecutive_charge_cycle_TGM_C_TG1_C':0,
'consecutive_charge_cycle_TGM_C_TG_430_C':0,
'consecutive_charge_cycle_TG_430_C_B3_matlab_code':0,
'consecutive_charge_cycle_TG_430_C_B3_C':0,
'consecutive_charge_cycle_TG_430_C_TG_matlab':0,
'consecutive_charge_cycle_TG_430_C_TG1_C':0,
'consecutive_charge_cycle_TG_430_C_TGmax_C':0,


}  

cb_vars={
     'input_mapping_thermistor_mapping':IntVar(),
'input_mapping_temperature_range':IntVar(),
'input_mapping_current_sensor':IntVar(),
'input_mapping_pressure_sensor':IntVar(),
'input_mapping_gpio_mapping':IntVar(),
'input_mapping_cp_activation':IntVar(),
'input_mapping_battery_polarity_detection':IntVar(),
'input_mapping_rectifier_readback':IntVar(),
'input_mapping_chiller_readback':IntVar(),
'input_mapping_heater_readback':IntVar(),
'input_mapping_EM_readback':IntVar(),
'input_mapping_BMS_can_datarate':IntVar(),
'protections_input_grid_spd_fault':IntVar(),
'protections_input_grid_elr_fault':IntVar(),
'protections_input_grid_VR_fault':IntVar(),
'protections_input_grid_em_sw':IntVar(),
'protections_input_grid_grid_power_cut':IntVar(),
'protections_output_power_rectifier_ref_curr_offset_positive':IntVar(),
'protections_output_power_rectifier_ref_curr_offset_negative':IntVar(),
'protections_output_power_Reference_sensor_Current_offset_Positive':IntVar(),
'protections_output_power_Reference_sensor_Current_offset_Negative':IntVar(),
'protections_output_power_Rectifier_derated':IntVar(),
'protections_output_power_Over_current':IntVar(),
'protections_output_power_No_Current_Fault':IntVar(),
'protections_output_power_precharge_fail_protection_before_relay':IntVar(),
'protections_output_power_precharge_fail_protection_after_relay':IntVar(),
'protections_sensor_failure_1_current_sensor_open_protection':IntVar(),
'protections_sensor_failure_1_Current_sensor_fail_faulty_offset':IntVar(),
'protections_sensor_failure_1_gun_temp_sensor_open_low_protection_1_2':IntVar(),
'protections_sensor_failure_1_gun_temp_sensor_open_high_protection_1_2':IntVar(),
'protections_sensor_failure_1_gun_temp_sensor_open_low_protection_3_4':IntVar(),
'protections_sensor_failure_1_gun_temp_sensor_open_high_protection_3_4':IntVar(),
'protections_sensor_failure_1_Positive_GunTempSense_lowside_fault':IntVar(),
'protections_sensor_failure_1_Positive_GunTempSense_highside_fault':IntVar(),
'protections_sensor_failure_1_Negative_GunTempSense_lowside_fault':IntVar(),
'protections_sensor_failure_1_Negative_GunTempSense_highside_fault':IntVar(),
'protections_sensor_failure_1_Hot_tank_Watertemp_sense_lowside_fault':IntVar(),
'protections_sensor_failure_1_Hot_tank_Watertemp_sense_highside_fault':IntVar(),
'protections_sensor_failure_1_Cold_tank_Watertemp_sense_lowside_fault':IntVar(),
'protections_sensor_failure_1_Cold_tank_Watertemp_sense_highside_fault':IntVar(),
'protections_sensor_failure_1_Inlet_Watertemp_sense_lowside_fault':IntVar(),
'protections_sensor_failure_1_Inlet_Watertemp_sense_highside_fault':IntVar(),
'protections_sensor_failure_1_Outlet_Watertemp_sense_lowside_fault':IntVar(),
'protections_sensor_failure_1_Outlet_Watertemp_sense_highside_fault':IntVar(),
'protections_sensor_failure_2_charge_DC_contcator_open_protection':IntVar(),
'protections_sensor_failure_2_Charger_DC_polarity_reverse':IntVar(),
'protections_sensor_failure_2_CMS_48V_detection_circuit_fault':IntVar(),
'protections_sensor_failure_2_check_dc_contactor_weld_detection':IntVar(),
'protections_sensor_failure_2_check_dc_contactor_rev_weld_detection':IntVar(),
'protections_sensor_failure_2_polarity_reverse_protection':IntVar(),
'protections_sensor_failure_2_BMS_contactor_weld_forward_protection':IntVar(),
'protections_sensor_failure_2_BMS_contactor_weld_rev_protection':IntVar(),
'protections_sensor_failure_2_BMS_contactor_open_protection':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_1':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_2':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_3':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_4':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_1':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_2':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_3':IntVar(),
'protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_4':IntVar(),
'protections_sensor_failure_2_Heater_Comm_Fail_test':IntVar(),
'protections_sensor_failure_2_Chiller_Comm_Fail_test':IntVar(),
'protections_sensor_failure_2_EM_Comm_Fail_test':IntVar(),
'protections_sensor_failure_2_smoke_sensor_detect_protection_test':IntVar(),
'protections_sensor_failure_2_phase_reversal_test':IntVar(),
"protections_sensor_failure_2_current_sensor_Low_Temp":IntVar(),
"protections_sensor_failure_2_current_sensor_High_Temp":IntVar(),
'protections_mechanical_chiller_faul_detection':IntVar(),
'protections_mechanical_chiller_aft_fault_detection':IntVar(),
'protections_mechanical_AFT_fault_cms_computed_fault':IntVar(),
'protections_mechanical_chiller_hp_fault_detection':IntVar(),
'protections_mechanical_chiller_low_liquid_level_fault_detection':IntVar(),
'protections_mechanical_chiller_recoverable_faul_detection':IntVar(),
'protections_mechanical_chiller_LP_fault':IntVar(),
'protections_mechanical_chiller_compressor_overload_fault_test':IntVar(),
'protections_mechanical_pump_overload_fault_test':IntVar(),
'protections_mechanical_chiller_non_recoverable_faul_detection':IntVar(),
'protections_mechanical_Chiller_LiquidTemp_Inlet_outlet_water_temp_offset':IntVar(),
'protections_mechanical_battery_conditioning_fail_high_chiller_temp_test':IntVar(),
'protections_mechanical_battery_conditioning_cooling_fail_test':IntVar(),
'protections_mechanical_Chiller_Settings_Check':IntVar(),
'protections_mechanical_cold_tank_low_liquid_level_fault_detection':IntVar(),
'protections_mechanical_Fluid_Inlet_High_Temp_Fault_high_temp':IntVar(),
'protections_mechanical_Fluid_Inlet_High_Temp_Fault_offset':IntVar(),
'protections_mechanical_battery_conditioning_heating_fail_test':IntVar(),

'protections_mechanical_hot_tank_low_water_fault':IntVar(),
'protections_mechanical_CMS_HotTank_Overtemp_protect_cms_sensor_test':IntVar(),
'protections_mechanical_CMS_HotTank_Overtemp_protect_heater_sensor_test':IntVar(),
'protections_mechanical_CMS_HotTank_Overtemp_cutoff_test':IntVar(),
'protections_mechanical_heater_low_temp_fault':IntVar(),
'protections_mechanical_heater_high_temp_fault':IntVar(),
'protections_mechanical_CMS_HotTank_offset_test':IntVar(),
'protections_mechanical_heater_low_water_fault':IntVar(),
'protections_mechanical_heater_probe_low_fault':IntVar(),
'protections_mechanical_heater_probe_high_fault':IntVar(),
'protections_mechanical_mbv_open_fault_test':IntVar(),
'protections_mechanical_mbv_close_fault_test':IntVar(),
'protections_mechanical_Air_Comp_Overheat_Protection_test':IntVar(),
'protections_charge_algo_station_cell_over_voltage':IntVar(),
'protections_charge_algo_station_over_temp':IntVar(),
'protections_charge_algo_station_under_temp':IntVar(),
'protections_charge_algo_imcomplete_charge':IntVar(),
'protections_charge_algo_station_pack_temp_ib':IntVar(),
'protections_charge_algo_station_pack_voltage_ib':IntVar(),
'protections_charge_algo_tec_failure':IntVar(),
'protections_cloud_interaction_BMS_OTA_Dont_Do_Cmd':IntVar(),
'protections_cloud_interaction_BMS_OTA_Bootloader_Start_Fail':IntVar(),
'protections_cloud_interaction_Vehicle_blacklisted':IntVar(),
'protections_cloud_interaction_fut_protection_test':IntVar(),
'protections_cloud_interaction_BMS_OTA_target_fw_unavailable':IntVar(),
'protections_cloud_interaction_BMS_flasher_error_check':IntVar(),
"protections_cloud_interaction_BMS_only_BL_ota_check_available":IntVar(),
"protections_cloud_interaction_BMS_only_BL_ota_check_no_FW":IntVar(),
'protections_BMS_interaction_BMS_charge_protection_test':IntVar(),
'protections_BMS_interaction_BMS_can_freeze_test':IntVar(),
'protections_BMS_interaction_BMS_state_error_test':IntVar(),
"protections_BMS_interaction_BMS_wakeup_fail":IntVar(),
'protections_gun_lock_unlock_unintentional_gun_unlock_test':IntVar(),
'protections_gun_lock_unlock_GunLockFailed_1st_attempt':IntVar(),
'protections_gun_lock_unlock_unautharized_gun_removal':IntVar(),
'protections_gun_lock_unlock_unlock_failure':IntVar(),
'protections_gun_lock_unlock_gun_lock_fail_with_early_fb':IntVar(),
'protections_gun_lock_unlock_gun_theft_fault_test':IntVar(),
"protections_gun_lock_unlock_Gun_Locked_In_Air_partial_unlock":IntVar(),
"protections_gun_lock_unlock_Gun_Locked_In_Air_full_unlock":IntVar(),
'protections_gun_temp_gun_temp_ib_fault_1_2_B3':IntVar(),
'protections_gun_temp_gun_temp_ib_fault_1_3_B3':IntVar(),
'protections_gun_temp_gun_temp_ib_fault_3_4_B3':IntVar(),
'protections_gun_temp_gun_temp_ib_fault_1_2_TG':IntVar(),
'protections_gun_temp_gun_temp_ib_fault_1_3_TG':IntVar(),
'protections_gun_temp_gun_temp_ib_fault_3_4_TG':IntVar(),
'protections_gun_temp_gun_temp_ib_detect_1_2':IntVar(),
'protections_gun_temp_gun_temp_ib_detect_1_3':IntVar(),
'protections_gun_temp_gun_temp_ib_detect_3_4':IntVar(),
'protections_gun_temp_gun_over_temp_cutoff_all':IntVar(),
'protections_gun_temp_gun_over_temp_warning_all':IntVar(),
'protection_actions_input_power_protection_action_standby_test':IntVar(),
'protection_actions_input_power_protection_action_charge_test':IntVar(),
'protection_actions_bms_protection_action_charge_test':IntVar(),
'protection_actions_e_plug_protection_action_charge_test':IntVar(),
'protection_actions_output_power_protection_action_standby_test':IntVar(),
'protection_actions_output_power_protection_action_charge_test':IntVar(),
'protection_actions_fcs_battery_heating_action_charge_test':IntVar(),
'protection_actions_fcs_internal_cooling_action_standby_test':IntVar(),
'protection_actions_fcs_internal_cooling_action_charge_test':IntVar(),
'protection_actions_fcs_battery_cooling_action_charge_test':IntVar(),
'charge_cycle_TG1_normal_charge_no_precondition':IntVar(),
'charge_cycle_TG1_CHTZ_charge_no_precondition':IntVar(),
'charge_cycle_TG1_normal_charge_no_precondition_voltage_ib_cutoff':IntVar(),
'charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff':IntVar(),
'charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':IntVar(),
'charge_cycle_TG1_normal_charge_precooling':IntVar(),
'charge_cycle_TG1_CHTZ_charge_precooling':IntVar(),
'charge_cycle_TG1_normal_charge_preheating':IntVar(),
'charge_cycle_TG1_CHTZ_charge_preheating':IntVar(),
'charge_cycle_TG1_normal_charge_precooling_chiller_failure':IntVar(),
'charge_cycle_TG1_normal_charge_preheating_heater_failure':IntVar(),
'charge_cycle_TGM_normal_charge_no_precondition':IntVar(),
'charge_cycle_TGM_CHTZ_charge_no_precondition':IntVar(),
'charge_cycle_TGM_normal_charge_no_precondition_voltage_ib_cutoff':IntVar(),
'charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff':IntVar(),
'charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':IntVar(),
'charge_cycle_TGM_normal_charge_precooling':IntVar(),
'charge_cycle_TGM_CHTZ_charge_precooling':IntVar(),
'charge_cycle_TGM_normal_charge_preheating':IntVar(),
'charge_cycle_TGM_CHTZ_charge_preheating':IntVar(),
'charge_cycle_B3_normal_charge_no_precondition':IntVar(),
'charge_cycle_B3_normal_charge_precooling':IntVar(),
'charge_cycle_B3_normal_charge_preheating':IntVar(),
'charge_cycle_TG1_normal_charge_no_precondition_10_rectifiers':IntVar(),
'charge_cycle_TG1_normal_charge_no_precondition_6_rectifiers':IntVar(),
'charge_cycle_TG1_normal_charge_no_precondition_10.1_profile_cloud':IntVar(),
'charge_cycle_TG1_430_normal_charge_no_precondition':IntVar(),
'charge_cycle_TG1_430_CHTZ_charge_no_precondition':IntVar(),
'charge_cycle_TG1_430_normal_charge_no_precondition_voltage_ib_cutoff':IntVar(),
'charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff':IntVar(),
'charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step':IntVar(),
'charge_cycle_TG1_430_normal_charge_precooling':IntVar(),
'charge_cycle_TG1_430_CHTZ_charge_precooling':IntVar(),
'charge_cycle_TG1_430_normal_charge_preheating':IntVar(),
'charge_cycle_TG1_430_CHTZ_charge_preheating':IntVar(),
'common_algo_check_max_rect_voltage':IntVar(),
'common_algo_master_error_code_test':IntVar(),
'common_algo_CP4V_debounce_test':IntVar(),
'common_algo_charge_algo_latching_check':IntVar(),
'common_algo_chiller_remote_off_before_aft':IntVar(),
'common_algo_chiller_remote_off_before_aft_during_precooling':IntVar(),
'common_algo_persisting_epump_id':IntVar(),
'common_algo_session_conter_increment':IntVar(),
'common_algo_calage_sending_check':IntVar(),
'common_algo_bms_wakeup':IntVar(),
'common_algo_current_calibration_test':IntVar(),
"common_algo_dc_contactor_weld_check_skip":IntVar(),
"common_algo_gun_temp_current_deration_during_charge_false_TEC":IntVar(),
"common_algo_false_tec_with_fast_gun_connection":IntVar(),
"common_algo_reverse_cx_gun_lock":IntVar(),
"common_algo_gun_temp_sensor_open_rejection_test":IntVar(),
"common_algo_gun_temp_deartion_table_TG_352":IntVar(),
"common_algo_gun_temp_deartion_table_TG_430":IntVar(),
"common_algo_gun_temp_deartion_table_TGmax":IntVar(),
"common_algo_gun_temp_deartion_table_B3":IntVar(),
"common_algo_pump_interlock":IntVar(),
"common_algo_min_temp_deration":IntVar(),
"common_algo_max_temp_deration":IntVar(),
"common_algo_can_fast_toggle_test":IntVar(),
'common_algo_can_slow_toggle_test':IntVar(),
'common_algo_fast_gun_toggle_test':IntVar(),
'common_algo_slow_gun_toggle_test':IntVar(),
"common_algo_fast_gun_toggle_before_charge":IntVar(),
"common_algo_slow_gun_toggle_before_charge":IntVar(),


'algo_TG1_fake_bms_current':IntVar(),
'algo_TG1_check_voltage_ib_non_chtz_high_vol':IntVar(),
'algo_TG1_check_voltage_ib_non_chtz_low_vol':IntVar(),
'algo_TG1_check_voltage_ib_chtz_higher_voltage':IntVar(),
'algo_TG1_check_voltage_ib_chtz_lower_voltage':IntVar(),
'algo_TG1_check_chtz_0_0':IntVar(),
'algo_TG1_check_chtz_4_0':IntVar(),
'algo_TG1_check_chtz_7_0':IntVar(),
'algo_TG1_check_chtz_50_4':IntVar(),
'algo_TG1_check_chtz_52_4':IntVar(),
'algo_TG1_check_chtz_60_51':IntVar(),
'algo_TG1_check_chtz_61_60':IntVar(),
'algo_TG1_check_chtz_104_100':IntVar(),
'algo_TG1_check_chtz_305_100':IntVar(),
'algo_TG1_check_chtz_301_300':IntVar(),
'algo_TG1_check_chtz_304_300':IntVar(),
'algo_TG1_min_cell_temp_computed_verification':IntVar(),
'algo_TG1_bms_reset_ah':IntVar(),
'algo_TG1_bms_state_change_ah_non':IntVar(),
'algo_TG1_TEC_failure_wrong_ah':IntVar(),
'algo_TG1_TEC_failure_wrong_soc':IntVar(),
'algo_TG1_TEC_failure_wrong_soc_tollerance':IntVar(),
'algo_TG1_user_soc_lock':IntVar(),
'algo_TG1_gun_temp_current_deration_no_previos_cutoff':IntVar(),
'algo_TG1_gun_temp_current_deration_after_cutoff':IntVar(),
'algo_TGM_fake_bms_current':IntVar(),
'algo_TGM_check_voltage_ib_non_chtz_high_vol':IntVar(),
'algo_TGM_check_voltage_ib_non_chtz_low_vol':IntVar(),
'algo_TGM_check_voltage_ib_chtz_higher_voltage':IntVar(),
'algo_TGM_check_voltage_ib_chtz_lower_voltage':IntVar(),
'algo_TGM_check_chtz_0_0':IntVar(),
'algo_TGM_check_chtz_4_0':IntVar(),
'algo_TGM_check_chtz_7_0':IntVar(),
'algo_TGM_check_chtz_50_4':IntVar(),
'algo_TGM_check_chtz_52_4':IntVar(),
'algo_TGM_check_chtz_60_51':IntVar(),
'algo_TGM_check_chtz_61_60':IntVar(),
'algo_TGM_check_chtz_104_100':IntVar(),
'algo_TGM_check_chtz_305_100':IntVar(),
'algo_TGM_check_chtz_301_300':IntVar(),
'algo_TGM_check_chtz_304_300':IntVar(),
'algo_TGM_min_cell_temp_computed_verification':IntVar(),
'algo_TGM_bms_reset_ah':IntVar(),
'algo_TGM_bms_state_change_ah_non':IntVar(),
'algo_TGM_TEC_failure_wrong_ah':IntVar(),
'algo_TGM_TEC_failure_wrong_soc':IntVar(),
'algo_TGM_TEC_failure_wrong_soc_tollerance':IntVar(),
'algo_TGM_user_soc_lock':IntVar(),
'algo_TGM_gun_temp_current_deration_no_previos_cutoff':IntVar(),
'algo_TGM_gun_temp_current_deration_after_cutoff':IntVar(),
'algo_B3_fake_bms_current':IntVar(),
'algo_B3_check_voltage_ib_non_chtz_high_vol':IntVar(),
'consecutive_charge_cycle_B3_matlab_B3_C_code':IntVar(),
'consecutive_charge_cycle_B3_matlab_TG_matlab':IntVar(),
'consecutive_charge_cycle_B3_matlab_TG_C':IntVar(),
'consecutive_charge_cycle_B3_matlab_TGmax_C':IntVar(),
'consecutive_charge_cycle_B3_matlab_TG_430_C':IntVar(),
'consecutive_charge_cycle_B3_C_B3_matlab_code':IntVar(),
'consecutive_charge_cycle_B3_C_TG_matlab':IntVar(),
'consecutive_charge_cycle_B3_C_TG_C':IntVar(),
'consecutive_charge_cycle_B3_C_TGmax_C':IntVar(),
'consecutive_charge_cycle_B3_C_TG_430_C':IntVar(),
'consecutive_charge_cycle_TG_matlab_B3_matlab_code':IntVar(),
'consecutive_charge_cycle_TG_matlab_B3_C':IntVar(),
'consecutive_charge_cycle_TG_matlab_TG_C':IntVar(),
'consecutive_charge_cycle_TG_matlab_TGmax_C':IntVar(),
'consecutive_charge_cycle_TG_matlab_TG_430_C':IntVar(),
'consecutive_charge_cycle_TG_C_B3_matlab_code':IntVar(),
'consecutive_charge_cycle_TG_C_B3_C':IntVar(),
'consecutive_charge_cycle_TG_C_TG_matlab':IntVar(),
'consecutive_charge_cycle_TG_C_TGmax_C':IntVar(),
'consecutive_charge_cycle_TG_C_TG_430_C':IntVar(),
'consecutive_charge_cycle_TGM_C_B3_matlab_code':IntVar(),
'consecutive_charge_cycle_TGM_C_B3_C':IntVar(),
'consecutive_charge_cycle_TGM_C_TG_matlab':IntVar(),
'consecutive_charge_cycle_TGM_C_TG1_C':IntVar(),
'consecutive_charge_cycle_TGM_C_TG_430_C':IntVar(),
'consecutive_charge_cycle_TG_430_C_B3_matlab_code':IntVar(),
'consecutive_charge_cycle_TG_430_C_B3_C':IntVar(),
'consecutive_charge_cycle_TG_430_C_TG_matlab':IntVar(),
'consecutive_charge_cycle_TG_430_C_TG1_C':IntVar(),
'consecutive_charge_cycle_TG_430_C_TGmax_C':IntVar(),

}  

#endregion

#region TK-functions
  
def test_threading():
    # Call work function
    t1=Thread(target=run_fun)
    t1.start()

def change_lb(lb,msg):
    global curr_str
    try:
        curr_str=curr_str+msg+"\n"
        # lb.config(text=curr_str)
        lb.insert(END,msg+"\n")
        lb.see("end")
    except:
        pass

 
# work function
def run_fun(): 
    global lb,log_state,cb_vars,label
    global total_time,can_A_filepath,can_B_filepath,log_state,file_headers    
    lb=label      


    all_ard_state_reset()
    sleep(5) 
    setup_can()
    master_swt_on()
    log_state=1
    correct_relay_state_flag=1
    try:
        heater_chiller_thread.start()
    except Exception as e:
        print(e)

    try:
        EM_server_thread.start()
    except Exception as e:
        print(e)

    

    if(CMS_internal_can_dict["code_1"]!=0 or CMS_internal_can_dict["code_2"]!=0 and CMS_internal_can_dict["code_3"]!=0):
        print_with_log("CMS in fault state")
    else:
        print_with_log("Starting tests")
        print_version_info()
                
        try:
            check_all_inputs_mapping(HW_v=21,FW_v=839,c_count=102)
        except:
            pass    
        try:
            check_protections_input_grid(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_input_grid test error: "+str(e))
        try:
            check_protections_output_power(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_output_power test error: "+str(e))
        try:
            check_protections_sensor_failure_1(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_sensor_failure_1 test error: "+str(e))
        try:
            check_protections_sensor_failure_2(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_sensor_failure_2 test error: "+str(e))
        try:
            check_protections_mechanical(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_mechanical test error: "+str(e))
        try:
            check_protections_charge_algo(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_charge_algo test error: "+str(e))
        try:
            check_protections_cloud_interaction(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_cloud_interaction test error: "+str(e))
        try:
            check_protections_BMS_interaction(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_BMS_interaction test error: "+str(e))

        try:
            check_protections_gun_lock_unlock(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_gun_lock_unlock test error: "+str(e))
        try:
            check_protections_gun_temp(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_gun_temp test error: "+str(e))

        try:
            check_protection_actions(HW_v=21,FW_v=839,c_count=102)
        except Exception as e:
            print_with_log("check_protections_gun_temp test error: "+str(e))
        
        
        # try:
        #     start_C_rate_with_heater_failure(HW_v=21,FW_v=839,c_count=67)
        # except Exception as e:
        #     print_with_log("start_C_rate_with_heater_failure test error: "+str(e))
        # try:
        #     start_C_rate_with_chiller_failure(HW_v=21,FW_v=839,c_count=67)
        # except Exception as e:
        #     print_with_log("start_C_rate_with_chiller_failure test error: "+str(e))
        # try:
        #     parallel_drain_tests(HW_v=21,FW_v=839,c_count=67)
        # except Exception as e:
        #     print_with_log("parallel_drain_tests test error: "+str(e))
        # try:
        #     otc_tests()
        # except Exception as e:
        #     print_with_log("otc_tests test error: "+str(e))
        
        try:
            common_algo_tests()
        except Exception as e:
            print_with_log("common algo test err: "+str(e))
        try:
            algo_tests2(HW_v=21,FW_v=839,pack_varient=1)
        except Exception as e:
            print_with_log("Tg1 algo test err: "+str(e))
        
        try:
            algo_tests2(HW_v=22,FW_v=839,pack_varient=2)
        except Exception as e:
            print_with_log("Tg max algo test err: "+str(e))
        try:
            algo_tests2(HW_v=2,FW_v=839,pack_varient=0)
        except Exception as e:
            print_with_log("B3 algo test err: "+str(e))
        try:
            basic_charge_tests(HW_v=21,FW_v=839,c_count=67)    
        except Exception as e:
            print_with_log("basic charge tests err: "+str(e))
        try:
            consecutive_charge_cycles_tests()
        except Exception as e:
            print_with_log("consecutive session test err: "+str(e))
        
        
            
        print_with_log("FW tests completed")
        log_state=0    
   

#endregion   
    
#region TK layout  
l_tital=Label(frame1,text="P4 Firmware tests ")
l_tital.grid(row=0,column=0,columnspan=18)


i=0    
i1=0
i2=0
i3=0
i4=0
i5=0
i6=0
i7=0
i8=0
i9=0
i10=0
i11=0
i12=0
i13=0

select_all_i = tk.BooleanVar()
select_all_i1 = tk.BooleanVar()
select_all_i2 = tk.BooleanVar()
select_all_i3 = tk.BooleanVar()
select_all_i4 = tk.BooleanVar()
select_all_i5 = tk.BooleanVar()
select_all_i6 = tk.BooleanVar()
select_all_i7 = tk.BooleanVar()
select_all_i8 = tk.BooleanVar()
select_all_i9 = tk.BooleanVar()
select_all_i10 = tk.BooleanVar()
select_all_i11 = tk.BooleanVar()
select_all_i12 = tk.BooleanVar()
select_all_i13 = tk.BooleanVar()

def on_checkbox_toggle(i):
    global cb_vars,select_all_i,select_all_i1,select_all_i2,select_all_i3
    global select_all_i4,select_all_i5,select_all_i6,select_all_i7,select_all_i8
    global select_all_i9,select_all_i10,select_all_i11,select_all_i12
    global select_all_i13
    if(i==0):
        state=select_all_i.get()
        for k in cb_vars.keys():
            if("input_mapping" in k):
                cb_vars[k].set(state)
    
    elif(i==1):
        state=select_all_i1.get()
        for k in cb_vars.keys():
            if("protections_input_grid" in k or "protections_output_power" in k or "protections_charge" in k):
                cb_vars[k].set(state)
    elif(i==2):
        state=select_all_i2.get()
        for k in cb_vars.keys():
            if("protections_sensor_failure_1" in k):
                cb_vars[k].set(state)
    elif(i==3):
        state=select_all_i3.get()
        for k in cb_vars.keys():
            if("protections_sensor_failure_2" in k):
                cb_vars[k].set(state)
    elif(i==4):
        state=select_all_i4.get()
        for k in cb_vars.keys():
            if("protections_mechanical" in k ):
                cb_vars[k].set(state)
    elif(i==5):
        state=select_all_i5.get()
        for k in cb_vars.keys():
            if("protections_cloud" in k or "protections_BMS" in k or "protections_gun_lock_unlock" in k):
                cb_vars[k].set(state)
    elif(i==6):
        state=select_all_i6.get()
        for k in cb_vars.keys():
            if("protection_actions" in k ):
                cb_vars[k].set(state)
    elif(i==7):
        state=select_all_i7.get()
        for k in cb_vars.keys():
            if("charge_cycle_TG1" in k):
                cb_vars[k].set(state)
    elif(i==8):
        state=select_all_i8.get()
        for k in cb_vars.keys():
            if("charge_cycle_TGM" in k):
                cb_vars[k].set(state)
    elif(i==9):
        state=select_all_i9.get()
        for k in cb_vars.keys():
            if("charge_cycle_B3" in k):
                cb_vars[k].set(state)
    elif(i==10):
        state=select_all_i10.get()
        for k in cb_vars.keys():
            if("common_algo" in k or "algo_B3" in k):
                cb_vars[k].set(state)
    elif(i==11):
        state=select_all_i11.get()
        for k in cb_vars.keys():
            if("algo_TG1" in k ):
                cb_vars[k].set(state)
    elif(i==12):
        state=select_all_i12.get()
        for k in cb_vars.keys():
            if("algo_TGM" in k ):
                cb_vars[k].set(state)
    elif(i==13):
        state=select_all_i13.get()
        for k in cb_vars.keys():
            if("consecutive_charge_cycle" in k ):
                cb_vars[k].set(state)
    


for k in test_dict.keys():
    
    select_all_checkbox_i = tk.Checkbutton(frame1, text="Select All", variable=select_all_i, 
                                           command=lambda i=0: on_checkbox_toggle(i))
    select_all_checkbox_i.grid(row=4, column=0, sticky="w")
    
    if("input_mapping" in k):
        cb_n=Checkbutton(frame1,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i,column=0,columnspan=3,sticky="w")
        i=i+1

    select_all_checkbox_i1 = tk.Checkbutton(frame2, text="Select All", variable=select_all_i1, 
                                           command=lambda i=1: on_checkbox_toggle(i))
    select_all_checkbox_i1.grid(row=2, column=0, sticky="w")

    if("protections_input_grid" in k or "protections_output_power" in k or "protections_charge" in k):
        cb_n=Checkbutton(frame2,text=k,variable=cb_vars[k])
        cb_n.grid(row=3+i1,column=0,columnspan=3,sticky="w")
        i1=i1+1
    
    select_all_checkbox_i2 = tk.Checkbutton(frame2, text="Select All", variable=select_all_i2, 
                                           command=lambda i=2: on_checkbox_toggle(i))
    select_all_checkbox_i2.grid(row=2, column=3, sticky="w")

    if("protections_sensor_failure_1" in k ):
        cb_n=Checkbutton(frame2,text=k,variable=cb_vars[k])
        cb_n.grid(row=3+i2,column=3,columnspan=3,sticky="w")
        i2=i2+1
    
    select_all_checkbox_i3 = tk.Checkbutton(frame2, text="Select All", variable=select_all_i3, 
                                           command=lambda i=3: on_checkbox_toggle(i))
    select_all_checkbox_i3.grid(row=2, column=6, sticky="w")

    if("protections_sensor_failure_2" in k ):
        cb_n=Checkbutton(frame2,text=k,variable=cb_vars[k])
        cb_n.grid(row=3+i3,column=6,columnspan=3,sticky="w")
        i3=i3+1

    select_all_checkbox_i4 = tk.Checkbutton(frame2, text="Select All", variable=select_all_i4, 
                                           command=lambda i=4: on_checkbox_toggle(i))
    select_all_checkbox_i4.grid(row=2, column=9, sticky="w")

    if("protections_mechanical" in k ):
        cb_n=Checkbutton(frame2,text=k,variable=cb_vars[k])
        cb_n.grid(row=3+i4,column=9,columnspan=3,sticky="w")
        i4=i4+1

    select_all_checkbox_i5 = tk.Checkbutton(frame2, text="Select All", variable=select_all_i5, 
                                           command=lambda i=5: on_checkbox_toggle(i))
    select_all_checkbox_i5.grid(row=2, column=12, sticky="w")

    if("protections_cloud" in k or "protections_BMS" in k or "protections_gun_lock_unlock" in k or "protections_gun_temp" in k):
        cb_n=Checkbutton(frame2,text=k,variable=cb_vars[k])
        cb_n.grid(row=3+i5,column=12,columnspan=3,sticky="w")
        i5=i5+1
    
    select_all_checkbox_i6 = tk.Checkbutton(frame2, text="Select All", variable=select_all_i6, 
                                           command=lambda i=6: on_checkbox_toggle(i))
    select_all_checkbox_i6.grid(row=2, column=15, sticky="w")

    if("protection_actions" in k ):
        cb_n=Checkbutton(frame2,text=k,variable=cb_vars[k])
        cb_n.grid(row=3+i6,column=15,columnspan=3,sticky="w")
        i6=i6+1

    select_all_checkbox_i7 = tk.Checkbutton(frame3, text="Select All", variable=select_all_i7, 
                                           command=lambda i=7: on_checkbox_toggle(i))
    select_all_checkbox_i7.grid(row=4, column=0, sticky="w")

    if("charge_cycle_TG1" in k):
        cb_n=Checkbutton(frame3,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i7,column=0,columnspan=3,sticky="w")
        i7=i7+1
    
    select_all_checkbox_i8 = tk.Checkbutton(frame3, text="Select All", variable=select_all_i8, 
                                           command=lambda i=8: on_checkbox_toggle(i))
    select_all_checkbox_i8.grid(row=4, column=3, sticky="w")

    if("charge_cycle_TGM" in k):
        cb_n=Checkbutton(frame3,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i8,column=3,columnspan=3,sticky="w")
        i8=i8+1

    select_all_checkbox_i9 = tk.Checkbutton(frame3, text="Select All", variable=select_all_i9, 
                                           command=lambda i=9: on_checkbox_toggle(i))
    select_all_checkbox_i9.grid(row=4, column=6, sticky="w")

    if("charge_cycle_B3" in k):
        cb_n=Checkbutton(frame3,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i9,column=6,columnspan=3,sticky="w")
        i9=i9+1

    select_all_checkbox_i10 = tk.Checkbutton(frame4, text="Select All", variable=select_all_i10, 
                                           command=lambda i=10: on_checkbox_toggle(i))
    select_all_checkbox_i10.grid(row=4, column=0, sticky="w")

    if("common_algo" in k or "algo_B3" in k):
        cb_n=Checkbutton(frame4,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i10,column=0,columnspan=3,sticky="w")
        i10=i10+1
    
    select_all_checkbox_i11 = tk.Checkbutton(frame4, text="Select All", variable=select_all_i11, 
                                           command=lambda i=11: on_checkbox_toggle(i))
    select_all_checkbox_i11.grid(row=4, column=3, sticky="w")

    if("algo_TG1" in k ):
        cb_n=Checkbutton(frame4,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i11,column=3,columnspan=3,sticky="w")
        i11=i11+1
    
    select_all_checkbox_i12 = tk.Checkbutton(frame4, text="Select All", variable=select_all_i12, 
                                           command=lambda i=12: on_checkbox_toggle(i))
    select_all_checkbox_i12.grid(row=4, column=6, sticky="w")
    
    if("algo_TGM" in k ):
        cb_n=Checkbutton(frame4,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i12,column=6,columnspan=3,sticky="w")
        i12=i12+1

    select_all_checkbox_i13 = tk.Checkbutton(frame5, text="Select All", variable=select_all_i13, 
                                           command=lambda i=13: on_checkbox_toggle(i))
    select_all_checkbox_i13.grid(row=4, column=0, sticky="w")

    if("consecutive_charge_cycle" in k ):
        cb_n=Checkbutton(frame5,text=k,variable=cb_vars[k])
        cb_n.grid(row=5+i13,column=0,columnspan=3,sticky="w")
        i13=i13+1
    


scrollbar = tk.Scrollbar(frame1)
label= Text(height=5,yscrollcommand=scrollbar)
label.grid(row=22,column=0,rowspan=4,columnspan=18)

Button(root,text="Run tests",command = test_threading).grid(row=27,column=0,columnspan=18)

#endregion


"""

normal charging when initial 3.43 is requested, within 5 sec increase voltage to 3.63, 
this will trigger BMS COV. in new FW, the voltage check happens after 0.5 seconds, 
so after 0.5 sec the cutoff will happen depending on voltage table for destination current row

During shift from 3.43 to 2, if rectifier response is very slow, 
reaching only 1c in 5sec, after 5sec the voltage table will be checked and as the current is 1C,
 itwill use 1c voltage cutoff. 
"""

#region can DBC definitions

CMS_internal_can_dict={}
ota_can_dict={}
display_can_dict={}

deactivate_rectifiers_num=0
stop_server_flag=0
rectifier_control_request={
    "voltage":0,
    "ind_current":0
}

rectifier_readback_values={
    "voltage":0,
    "current":0
}

last_rectifier_readback_values={
    "voltage":-1,
    "current":-1
}

ota_db = cantools.database.load_file('/home/raspi/Desktop/P4_FW_tests/cms_bms_dbc_v9_5.dbc') #path of .dbc file station can
dbc_cms_inter= cantools.database.load_file('/home/raspi/Desktop/P4_FW_tests/can_v37_6.dbc') #path of .dbc file vehicle can


all_signals=[]
signal_list_ci = [[str(signal.name) for signal in message.signals] for message in ota_db.messages]
for sl in signal_list_ci:
    for s in sl:
        all_signals.append(s)
bms_list_ci = sorted(all_signals)
for i in range(len(bms_list_ci)):
        ota_can_dict[bms_list_ci[i]] = 0

all_signals=[]
signal_list_ci = [[str(signal.name) for signal in message.signals] for message in dbc_cms_inter.messages]
for sl in signal_list_ci:
    for s in sl:
        all_signals.append(s)
bms_list_ci = sorted(all_signals)
for i in range(len(bms_list_ci)):
    CMS_internal_can_dict[bms_list_ci[i]] = -1
    display_can_dict[bms_list_ci[i]] = -1



#endregion

#region OTC variables

flasher_substate_list=["flasher_init_substate","flasher_bl_jump_ack",
                       "flasher_bl_can_heartbeat_check","flasher_bl_gunlock_metadata_check",
                       "flasher_bl_jump_start_msg_decision","flasher_image_transfer_init",
                       "flasher_image_transfer_read_sector","flasher_image_transfer_sector_details",
                       "flasher_image_transfer_sector_isotp_start","flasher_image_transfer_sector_crc_msg",
                       "flasher_image_transfer_bl_command_check","flasher_image_transfer_complete_decision",
                       "flasher_image_transfer_image_crc","flasher_image_transfer_restart_file",
                       "flasher_image_transfer_completion"]
flasher_current_substate=""
flasher_mainstate_list=["flasher_init","flasher_bl_check",
                        "flasher_image_transfer","flasher_error",
                        "flasher_timeout","flasher_end"]
flasher_current_mainstate=""
flasher_timeout_error_list=["no_timeout","flasher_bl_jump_ack_timeout","flasher_bl_heartbeat_timeout",
                            "flasher_bl_data_check_timeout","flasher_bl_jump_start_timeout",
                            "flasher_isotp_timeout","flasher_bl_sector_cmd_timeout","flasher_bl_image_cmd_timeout"]
flasher_current_timeout_error=""
flasher_error_code_list=["no_error","bl_ota_fail_error","bl_ota_image_fail_error"]
flasher_current_error_code=""

flasher_timeout_values={"flasher_bl_jump_ack_timeout":5,
                        "flasher_bl_heartbeat_timeout":1,
                        "flasher_bl_data_check_timeout":2,
                        "flasher_bl_jump_start_timeout":2,
                        "flasher_isotp_timeout":6,
                        "flasher_bl_sector_cmd_timeout":2,
                        "flasher_bl_image_cmd_timeout":3}


bl_mainstate_enum = Enum('mainstate', ["default_state","init","standby","gun_lock","fw_update","gun_unlock",
                                  "application_jump","error_state","timeout","bootloader_restart_state"])
bl_substate_enum = Enum('substate', ["default_sub_state","init_init","init_metadata_fetch","standby_init","standby_exit","gun_lock_init","fw_update_init",
                  "fw_update_handshake","fw_update_read_buffer","fw_update_verify_buffer","fw_update_erase","fw_update_write",
                  "fw_update_read_flash","fw_update_verify_flash","fw_update_verify_image","fw_update_exit","timeout_init","application_jump_init"])

bl_error_code_enum=Enum('err_code', ["No_error","bl_gloabl_retry","bl_sector_retry","bl_image_retry"])

bl_timeout_error_enum=Enum('tmout',["No_timeout","cms_heartbeat_timeout","cms_cmd_timeout","cms_sector_details_timeout","cms_crc_timeout","flash_sector_verify_timeout","image_verify_timeout"])

current_bank=-1
current_sector=-1
current_section_num=-1
current_sector_start_address=-1
current_sector_length=-1

max_sector_retry=0
max_image_retry=0
max_global_retry=0

bl_mainstate=bl_mainstate_enum.default_state
bl_substate=bl_substate_enum.default_sub_state
bl_timeout_err=bl_timeout_error_enum.No_timeout
bl_err_code=bl_error_code_enum.No_error

ota_can_dict={}
ota_message_timings={}
ota_message_counter={}
send_bl_heartbeat_flag=0

all_signals_ota=[]
message_list_ota=sorted([message.frame_id for message in ota_db.messages])
signal_list_ota = [[str(signal.name) for signal in message.signals] for message in ota_db.messages]

for sl in signal_list_ota :
   for s in sl:
      all_signals_ota.append(s)
signal_list_ota = sorted(all_signals_ota)

for i in range(len(signal_list_ota)):
   ota_can_dict[signal_list_ota[i]] = 0

for j in range(len(message_list_ota)):
   ota_message_timings[message_list_ota[j]]=-1
   ota_message_counter[message_list_ota[j]]=0
#endregion

#region general functions

fut_hb_flag=0
stop_server_flag=0

dc_contactor_open_flag=0
dc_contactor_forward_weld_flag=0
dc_contactor_rev_weld_flag=0

BMS_contactor_weld_forward=0
BMS_contactor_weld_rev=0
BMS_contactor_open_flag=0
polarity_rev_flag=0

mbv_open_fault_flag=0
mbv_close_fault_flag=0
tec_flag=1
bms_send_flag=0  

correct_current_flag=0
correct_rectifier_flag=1
correct_curr_sensor_flag=1
deactivate_rectifiers_num=0
battery_thermal_emulation=0

start_C_rate=0
calib_state = 0



def print_with_log(s):
    global filepath,lb
    change_lb(lb,s)
    dateString = str(datetime.datetime.now().strftime("%Y-%m-%d_%H_%M_%S"))
    s_in=dateString+" : "+str(s)+"\n"
    print(s_in)
    try:
        file=open(filepath,'a')
        file.write(s_in)
        file.close()
    except:
        pass

def print_rectifier_rb_data(exp_v=0,exp_i=0):
    
        rectifier_dict={
            "v1":CMS_internal_can_dict["rect_1_v"],
            "v2":CMS_internal_can_dict["rect_2_v"],
            "v3":CMS_internal_can_dict["rect_3_v"],
            "v4":CMS_internal_can_dict["rect_4_v"],
            "v5":CMS_internal_can_dict["rect_5_v"],
            "v6":CMS_internal_can_dict["rect_6_v"],
            "v7":CMS_internal_can_dict["rect_7_v"],
            "v8":CMS_internal_can_dict["rect_8_v"],
            "v9":CMS_internal_can_dict["rect_9_v"],
            "v10":CMS_internal_can_dict["rect_10_v"],
            "v11":CMS_internal_can_dict["rect_11_v"],
            "v12":CMS_internal_can_dict["rect_12_v"],

            "c1":CMS_internal_can_dict["rect_1_i"],
            "c2":CMS_internal_can_dict["rect_2_i"],
            "c3":CMS_internal_can_dict["rect_3_i"],
            "c4":CMS_internal_can_dict["rect_4_i"],
            "c5":CMS_internal_can_dict["rect_5_i"],
            "c6":CMS_internal_can_dict["rect_6_i"],
            "c7":CMS_internal_can_dict["rect_7_i"],
            "c8":CMS_internal_can_dict["rect_8_i"],
            "c9":CMS_internal_can_dict["rect_9_i"],
            "c10":CMS_internal_can_dict["rect_10_i"],
            "c11":CMS_internal_can_dict["rect_11_i"],
            "c12":CMS_internal_can_dict["rect_12_i"],

        }
        print_with_log(rectifier_dict)    

        for k in rectifier_dict.keys():
            if("v" in k):
                if(abs(rectifier_dict[k]-exp_v)>1):
                    print_with_log("Rectifier rb fail for voltage: "+str(k))
            if("c" in k):
                if(abs(rectifier_dict[k]-exp_i)>1):
                    print_with_log("Rectifier rb fail for current: "+str(k))

        sleep(0.2)

def print_chiller_data():
    global CMS_internal_can_dict
    
    for k in CMS_internal_can_dict.keys():
        if(k in chiller_data.keys()):
            print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))

def print_temp_data():
    global CMS_internal_can_dict,temp_can_signal_map
    out_dict={}
    for k in temp_can_signal_map.keys():
        out_dict[temp_can_signal_map[k]]=CMS_internal_can_dict[temp_can_signal_map[k]]
    print_with_log(out_dict)

def system_reset(HW_version=21,FW_version=839,cycle_count=102):
    global bms_send_flag,correct_current_flag,correct_relay_state_flag,precharge_fail_flag
    global correct_polarity_response,dc_contactor_open_flag,polarity_rev_flag,BMS_contactor_weld_forward
    global BMS_contactor_weld_rev,BMS_contactor_open_flag,mbv_open_fault_flag,mbv_close_fault_flag
    global correct_rectifier_flag,correct_curr_sensor_flag,ota_can_dict,BMS_sent_CAN_msg_base,BMS_sent_CAN_msg
    global tec_flag,chiller_rs485_server_thread,run_chiller_state,chiller_data,chiller_data_base
    global dc_contactor_forward_weld_flag,dc_contactor_rev_weld_flag,polarity_rev_flag,fut_hb_flag,precharge_fail_flag_2
    global deactivate_rectifiers_num,stop_server_flag,heater_data,all_relay_states,parallel_drain_check,battery_thermal_emulation
    global capacity_deration_check,battery_conditioning_request_check,c_rate_check,heater_base_data

    print_with_log("Doing system reset for HW: "+str(HW_version)+" FW_v: "+str(FW_version)+" cycle: "+str(cycle_count))
    reset_BMS_data()

    for k in chiller_data:
        chiller_data[k]=chiller_data_base[k]
    
    for k in heater_data:
        heater_data[k]=heater_base_data[k]
    
    

    BMS_sent_CAN_msg["Battery_FW_HW"]["BMS_Firmware_Version"] = FW_version
    BMS_sent_CAN_msg["Battery_FW_HW"]["Hardware_Version"] =HW_version
    BMS_sent_CAN_msg["Current_Ah_Count"]["Charge_Cycle_Count"]=cycle_count

    correct_relay_state_flag=1
    correct_polarity_response=1
    precharge_fail_flag=0
    precharge_fail_flag_2=0
    fut_hb_flag=0
    stop_server_flag=0
    dc_contactor_open_flag=0
    dc_contactor_forward_weld_flag=0
    dc_contactor_rev_weld_flag=0

    BMS_contactor_weld_forward=0
    BMS_contactor_weld_rev=0
    BMS_contactor_open_flag=0
    polarity_rev_flag=0

    mbv_open_fault_flag=0
    mbv_close_fault_flag=0
    tec_flag=1
    bms_send_flag=0  
    
    correct_current_flag=0
    correct_rectifier_flag=1
    correct_curr_sensor_flag=1
    deactivate_rectifiers_num=0
    parallel_drain_check=1
    battery_thermal_emulation=0
    capacity_deration_check=0
    battery_conditioning_request_check =0
    c_rate_check=0
    parallel_drain_check=0
    
    ota_can_dict["gun_lock_request"]=0
    sleep(2)    
    all_ard_state_reset()    
    sleep(5)

def initial_condition_check():   
    st_time=timer()
    while(1):
        protection_states=get_protection_states()
        print_with_log(protection_states)
        res=evaluate_protection_state(
            input_power_protection_status=1,
            output_power_protection_status=1,
            fcs_heating_protection_status=1,
            e_plug_protection_status=1,
            bms_protection_status=1,
            charging_algo_protections_status=1,
            fcs_cooling_protection_status=1
        )
        if(res):
            print_with_log("Initial condition pass")
            return True
        sleep(1)
        print_with_log("waiting for initial condition to pass")
        if(timer()-st_time>30):
            print_with_log("Initial condition timeout")
            break

    else:
        print_with_log("Initial condition fail")
        return True

def print_protection_status():
    global CMS_internal_can_dict
    sleep(1)
    protection_state_list=["code_1","code_2","code_3","code_4","code_5","input_power_protection_status","output_power_protection_status","fcs_heating_protection_status",
                           "e_plug_protection_status","bms_protection_status","charging_algo_protections_status","fcs_bat_cool_protection_status","fcs_int_cool_protection_status"]
    out_dict={}
    for i in protection_state_list:
        out_dict[i]=CMS_internal_can_dict[i]
    print_with_log(out_dict)

def evaluate_protection_state(input_power_protection_status=-1,output_power_protection_status=-1,fcs_heating_protection_status=-1,e_plug_protection_status=-1,
                              bms_protection_status=-1,charging_algo_protections_status=-1,fcs_cooling_protection_status=-1,fcs_int_cooling_prot_status=-1,
                              drain_prot_status=-1):
    global CMS_internal_can_dict
    res=True
    if(input_power_protection_status!=-1 and input_power_protection_status!=CMS_internal_can_dict["input_power_protection_status"]):
        res=False
    if(output_power_protection_status!=-1 and output_power_protection_status!=CMS_internal_can_dict["output_power_protection_status"]):
        res=False
    if(fcs_heating_protection_status!=-1 and fcs_heating_protection_status!=CMS_internal_can_dict["fcs_heating_protection_status"]):
        res=False
    if(e_plug_protection_status!=-1 and e_plug_protection_status!=CMS_internal_can_dict["e_plug_protection_status"]):
        res=False
    if(bms_protection_status!=-1 and bms_protection_status!=CMS_internal_can_dict["bms_protection_status"]):
        res=False
    if(charging_algo_protections_status!=-1 and charging_algo_protections_status!=CMS_internal_can_dict["charging_algo_protections_status"]):
        res=False
    if(fcs_cooling_protection_status!=-1 and fcs_cooling_protection_status!=CMS_internal_can_dict["fcs_bat_cool_protection_status"]):
        res=False
    if(fcs_int_cooling_prot_status!=-1 and fcs_int_cooling_prot_status!=CMS_internal_can_dict["fcs_int_cool_protection_status"]):
        res=False
    
    return res

def get_protection_states():
    global CMS_internal_can_dict
    out_dict={"input_power_protection_status":-1,
              "output_power_protection_status":-1,
              "fcs_heating_protection_status":-1,
              "e_plug_protection_status":-1,
              "bms_protection_status":-1,
              "charging_algo_protections_status":-1,
              "fcs_bat_cool_protection_status":-1,
              "fcs_int_cool_protection_status":-1}
    for k in out_dict.keys():
        out_dict[k]=CMS_internal_can_dict[k]
    return out_dict

fault_dict_old={}
fault_dict_new={}

def update_fault_dict_from_bin(fault_list,bin_val,old_format=1):
    global fault_dict_old,fault_dict_new
    # if(len(fault_list)==1 and fault_list[0] == "EM_SW"):
    #     print_with_log("in binary decode function")
    #     print_with_log("list: "+str(fault_list)+" bin: "+str(bin_val)+" format: "+str(old_format))
    

    try:
        if(old_format == 1):
            for i in range(len(fault_list)):
                fault_name=fault_list[i]
                bin_index=-1*(i+1)
                signal_val=int(bin_val[bin_index])
                fault_dict_old[fault_name]=signal_val
        else:            
            for i in range(len(fault_list)):
                fault_name=fault_list[i]
                bin_index=-1*(i+1)
                signal_val=int(bin_val[bin_index])
                fault_dict_new[fault_name]=signal_val         
                # if(fault_name=="EM_SW"):
                #     print_with_log("bin_val: "+str(bin_val)+" signal val: "+str(signal_val))      
            # if("CellOverTemperature" in fault_list and old_format ==0):
            #     print_with_log("cms charge algo bin: "+str(bin_val)+" station over voltage: "+str(fault_dict_new["Station Cell over voltage"])) 
    except:
        pass
        
def get_fault_name_from_bin(fault_list,bin_val):
    try:
        res_dict={}
        if(bin_val == 0):
            return "No_error"
        else:
            for i in range(len(fault_list)):
                fault_name=fault_list[i]
                bin_index=-1*(i+1)
                signal_val=int(bin_val[bin_index])
                res_dict[fault_name]=signal_val
            
            for k in res_dict.keys():
                if(res_dict[k]==1):
                    return k
    except:
        pass

    
        

all_new_fault_list=["SPD Fault",
                    "ELR Fault",
                    "VoltageRelay Fault",
                    "EM_SW",   
                    "Grid_Power_Cut",  
                    "Rectifier - Ref current offset Positive",   
                    "Rectifier - Ref current offset Negative",
                    "Reference - sensor Current offset  Positive",
                    "Reference - sensor Current offset  Negative",
                    "Rectifier derated",
                    "Over current",
                    "No Current Fault",
                    "Precharge failed",
                    "Current Sense open",
                    "Current sensor fail/faulty offset",
                    "Gun_Temp_Sense_Failure",
                    "Positive GunTempSense lowside fault",
                    "Positive GunTempSense highside fault",
                    "Negative GunTempSense lowside fault",
                    "Negative GunTempSense highside fault",
                    "Hot tank Watertemp sense lowside fault",
                    "Hot tank Watertemp sense highside fault",
                    "Cold tank Watertemp sense lowside fault",
                    "Cold tank Watertemp sense highside fault",
                    "Inlet Watertemp sense lowside fault",
                    "Inlet Watertemp sense highside fault",
                    "Outlet Watertemp sense lowside fault",
                    "Outlet Watertemp sense highside fault",
                    "Charger-DC_Contactor_Open",
                    "Charger_DC_polarity_reverse",
                    "CMS 48V detection circuit fault",
                    "Charger_DC_Contactor_PreCharge_Weld",
                    "Charger_DC_Contactor_PreCharge_Weld_reverse",
                    "Polarity_Reversal",
                    "BMS_Contactor_Weld",
                    "BMS_Contactor_Open",
                    "Gun_Temp_Sense_Open",
                    "Heater_Comm_Fail",
                    "Chiller_Comm_Fail",
                    "EnergyMeter_Comm_Fail",
                    "smoke sensor_detect",
                    "Phase reversal",
                    "current_sensor_Low_Temp_fault",
                    "current_sensor_high_Temp_fault",
                    "Chiller_fault_detection",
                    "AFT_fault",
                    "AFT_fault_cms_computed",
                    "HP_fault",
                    "Chiller Low water level fault",
                    "Chiller_recoverable_faults",
                    "Chiller LP fault",
                    "Pump_Overload_fault",
                    "chiller_compressor_overload_fault",
                    "Chiller Non recoverable faults",
                    "Chiller_LiquidTemp_Inlet_outlet_water temp offset",
                    "Fluid_Inlet_High_Temp_Fault",
                    "MBV_Malfuntion",
                    "Battery_Conditioning_heating failed",
                    "Battery_Conditioning_failed_High Liq Temp",
                    "Battery_Conditioning_cooling_failed",
                    "Chiller_Setting_Error",
                    "Chiller_Remote_Logic_fault",                                       
                    "Cold_Tank_Low_Liquid_Warning",
                    "Hot_Tank_Low_Liquid_Warning",
                    "CMS_HotTank_Overtemp_protect",
                    "CMS_HotTank_Overtemp_cutoff",
                    "Heater_Low_Temperature_Fault",
                    "Heater_High_Temperature_Fault",
                    "CMS_HotTank_open_Offset_Warning",
                    "Heater_Low_Water_Level_Fault",
                    "Heater_Probe_Fault",
                    "Air_Comp_Overheat_Protection",
                    "Station Cell over voltage",
                    "CellOverTemperature",
                    "Cell_Under_Temperature_Fault",
                    "Over_current_fault",
                    "Incomplete Charge",  
                    "Pack_Temperature_Imbalance",
                    "Pack_Voltage_Imbalance",
                    "tec_failure",
                    "Fut_Protection",
                    "BMS_ChargeProtection",
                    "BMS CAN Freeze",
                    "BMS Not in charging State",
                    "BMS_Wakeup_Fail",
                    "BMS_OTA_Cloud_Display_No_Response",
                    "BMS_OTA_Target_Image_Unavailable",
                    "BMS_OTA_Don't_Do_Cmd",
                    "BMS_OTA_Flasher_Error",
                    "BMS_OTA_Attempt_Timeout",
                    "BMS_OTA_Attempts_Exhausted",
                    "BMS_OTA_Bootloader_Start_Fail",
                    "Vehicle blacklisted",
                    "GunTempImbalanceFault",    
                    "Gun_over_temperature",
                    "Gun_over_temp_warning", 
                    "GunTempImbalanceDetect",
                    "Gun_theft",                           
                    "UnIntentional_GunUnlock",                           
                    "GunLockFailed_1st_attempt", 
                    "Unauthorized_GUN_Removal",  
                    "Unlock_failure",                                                    
                    "GunLockFailed_2nd_attempt",
                    "SolFB_1_before_gun_lock",
                    "Gun_Locked_In_Air"]


new_fault_stucture_mapping={"SPD Fault":"SPD Fault",
                           "ELR Fault":"ELR Fault",
                           "VoltageRelay Fault":"VoltageRelay Fault",
                           "EM_SW":"EM_SW",
                           "Grid_Power_Cut":"None",
                           "Rectifier - Ref current offset Positive":"Rectifier - Ref current offset",   
                           "Rectifier - Ref current offset Negative":"Rectifier - Ref current offset",
                           "Reference - sensor Current offset  Positive":"Reference - sensor Current offset",
                           "Reference - sensor Current offset  Negative":"Reference - sensor Current offset",
                           "Rectifier derated":"None",
                           "Over current":"Over current",
                           "No Current Fault":"No Current Fault",
                           "Precharge failed":"Precharge failed",
                           "Current Sense open":"Current Sense open",
                           "Current sensor fail/faulty offset":"Zero_current_Offset",
                           "Gun_Temp_Sense_Failure":"Gun_Temp_Sense_Open",
                           "Positive GunTempSense lowside fault":"None",
                           "Positive GunTempSense highside fault":"None",
                           "Negative GunTempSense lowside fault":"None",
                           "Negative GunTempSense highside fault":"None",
                           "Hot tank Watertemp sense lowside fault":"None",
                           "Hot tank Watertemp sense highside fault":"None",
                           "Cold tank Watertemp sense lowside fault":"None",
                           "Cold tank Watertemp sense highside fault":"None",
                           "Inlet Watertemp sense lowside fault":"None",
                           "Inlet Watertemp sense highside fault":"None",
                           "Outlet Watertemp sense lowside fault":"None",
                           "Outlet Watertemp sense highside fault":"None",
                           "Charger-DC_Contactor_Open":"Charger_DC_Contactor_Open",
                           "Charger_DC_polarity_reverse":"None",
                           "CMS 48V detection circuit fault":"None",
                           "Charger_DC_Contactor_PreCharge_Weld":"Charger_DC_Contactor_PreCharge_Weld",
                           "Charger_DC_Contactor_PreCharge_Weld_reverse":"Charger_DC_Contactor_PreCharge_Weld",
                           "Polarity_Reversal":"Polarity_Reversal",
                           "BMS_Contactor_Weld":"BMS_Contactor_Weld",
                           "BMS_Contactor_Open":"BMS_Contactor_Open",
                           "Gun_Temp_Sense_Open":"GunTemp_Sense_Open_Warning",
                           "Heater_High_Temperature_Fault_duplicate":"None",
                           "Heater_Comm_Fail":"Heater_Comm_Fail",
                           "Chiller_Comm_Fail":"Chiller_Comm_Fail",
                           "EnergyMeter_Comm_Fail":"EnergyMeter_Comm_Fail",
                           "smoke sensor_detect":"None",
                           "Phase reversal":"None",
                           "current_sensor_Low_Temp_fault":"None",
                           "current_sensor_high_Temp_fault":"None",
                           "Chiller_fault_detection":"Chiller_fault_detection",
                           "AFT_fault":"AFT_fault",
                           "AFT_fault_cms_computed":"None",
                           "HP_fault":"HP_fault",
                           "Chiller Low water level fault":"Chiller Low water level fault",
                           "Chiller_recoverable_faults":"None",
                           "Chiller LP fault":"Chiller LP fault",
                           "Pump_Overload_fault":"Pump_Overload_fault",
                           "chiller_compressor_overload_fault":"None",
                           "Chiller Non recoverable faults":"None",
                           "BMS_Wakeup_Fail":"None",
                           "Chiller_LiquidTemp_Inlet_outlet_water temp offset":"None",
                           "Fluid_Inlet_High_Temp_Fault":"Fluid_Inlet_High_Temp_Fault",
                           "MBV_Malfuntion":"MBV_Malfuntion",
                           "Battery_Conditioning_heating failed":"Battery Conditioning failed",
                           "Battery_Conditioning_failed_High Liq Temp":"Battery_Conditioning_failed_High_Liq_Temp",
                           "Battery_Conditioning_cooling_failed":"Battery Conditioning failed",
                           "Chiller_Setting_Error":"None",
                           "Chiller_Remote_Logic_fault":"None",    
                           "Cold_Tank_Low_Liquid_Warning":"Cold_Tank_Low_Liquid_Warning",
                           "Hot_Tank_Low_Liquid_Warning":"Hot_Tank_Low_Liquid_Warning",
                           "CMS_HotTank_Overtemp_protect":"CMS_HotTank_Overtemp_protect",
                           "CMS_HotTank_Overtemp_cutoff":"CMS_HotTank_Overtemp_cutoff",
                           "Heater_Low_Temperature_Fault":"Heater_Low_Temperature_Fault",
                           "Heater_High_Temperature_Fault":"Heater_High_Temperature_Fault",   
                           "CMS_HotTank_open_Offset_Warning":"CMS_HotTank_open_Offset_Warning",
                           "Air_Comp_Overheat_Protection":"None",                            
                           "Heater_Low_Water_Level_Fault":"Heater_Low_Water_Level_Fault",
                           "Heater_Probe_Fault":"Heater_Probe_Fault",
                           "Station Cell over voltage":"Station Cell over voltage",
                           "CellOverTemperature":"CellOverTemperature",
                           "Cell_Under_Temperature_Fault":"Cell_Under_Temperature_Fault",
                           "Over_current_fault":"None",
                           "Incomplete Charge":"Incomplete Charge",
                           "Pack_Temperature_Imbalance":"Pack_Temperature_Imbalance",
                           "Pack_Voltage_Imbalance":"Pack_Voltage_Imbalance",
                           "tec_failure":"tec_failure",
                           "Fut_Protection":"Fut_Protection",
                           "BMS_ChargeProtection":"BMS_ChargeProtection",
                           "BMS CAN Freeze":"BMS CAN Freeze",
                           "BMS Not in charging State":"BMS Not in charging State",
                           "BMS_OTA_Cloud_Display_No_Response":"BMS_OTA_Cloud_Display_No_Response",
                           "BMS_OTA_Target_Image_Unavailable":"BMS_OTA_Target_Image_Unavailable",
                           "BMS_OTA_Don't_Do_Cmd":"BMS_OTA_Don't_Do_Cmd",
                           "BMS_OTA_Flasher_Error":"BMS_OTA_Flasher_Error",
                           "BMS_OTA_Attempt_Timeout":"BMS_OTA_Attempt_Timeout",
                           "BMS_OTA_Attempts_Exhausted":"BMS_OTA_Attempts_Exhausted",
                           "BMS_OTA_Bootloader_Start_Fail":"BMS_OTA_Bootloader_Start_Fail",
                           "Vehicle blacklisted":"Vehicle blacklisted",
                           "GunTempImbalanceFault":"GunTempImbalanceFault",
                           "Gun_over_temperature":"Gun_over_temperature",
                           "Gun_over_temp_warning":"Gun_over_temp_warning",
                           "GunTempImbalanceDetect":"GunTempImbalanceDetect",                           
                           "Gun_theft":"Gun_theft",                                
                           "UnIntentional_GunUnlock":"UnIntentional GunUnlock",                           
                           "GunLockFailed_1st_attempt":"GunLockFailed_1st_attempt",  
                           "Unauthorized_GUN_Removal":"Unauthorized_GUN_Removal",                           
                           "Unlock_failure":"Unlock_failure",                                                  
                           "GunLockFailed_2nd_attempt":"GunLockFailed_2nd_attempt",
                           "SolFB_1_before_gun_lock":"SolFB_1_before_gun_lock" ,
                           "Gun_Locked_In_Air":"None"}
     
new_fault_elec_sop_list=["EM_SW"]
new_fault_elec_safety_list=["smoke sensor_detect"]
new_fault_elec_input_grid_list=["SPD Fault",
                        "ELR Fault",
                        "VoltageRelay Fault",                         
                        "Grid_Power_Cut",  
                        "Phase reversal"]
new_fault_elec_output_power_list=[
                        "Rectifier - Ref current offset Positive",   
                        "Rectifier - Ref current offset Negative",
                        "Reference - sensor Current offset  Positive",
                        "Reference - sensor Current offset  Negative",
                        "Rectifier derated",
                        "Over current",
                        "No Current Fault",
                        "Precharge failed",   
                        "Charger-DC_Contactor_Open",
                        "Charger_DC_polarity_reverse",
                        "CMS 48V detection circuit fault",
                        "Charger_DC_Contactor_PreCharge_Weld",
                        "Charger_DC_Contactor_PreCharge_Weld_reverse",
                        "Polarity_Reversal",
                        "BMS_Contactor_Weld",
                        "BMS_Contactor_Open"]
new_fault_elec_comms_list=["Heater_Comm_Fail",
                        "Chiller_Comm_Fail",
                        "EnergyMeter_Comm_Fail"]
new_fault_elec_sensor_list=["Current Sense open",
                        "Current sensor fail/faulty offset",
                        "Gun_Temp_Sense_Failure",
                        "Positive GunTempSense lowside fault",
                        "Positive GunTempSense highside fault",
                        "Negative GunTempSense lowside fault",
                        "Negative GunTempSense highside fault",
                        "Hot tank Watertemp sense lowside fault",
                        "Hot tank Watertemp sense highside fault",
                        "Cold tank Watertemp sense lowside fault",
                        "Cold tank Watertemp sense highside fault",
                        "Inlet Watertemp sense lowside fault",
                        "Inlet Watertemp sense highside fault",
                        "Outlet Watertemp sense lowside fault",
                        "Outlet Watertemp sense highside fault",
                        "Gun_Temp_Sense_Open",
                        "current_sensor_Low_Temp_fault",
                        "current_sensor_high_Temp_fault"]
new_fault_mech_chiller_list=["Chiller_fault_detection",
                        "AFT_fault",
                        "AFT_fault_cms_computed",
                        "HP_fault",
                        "Chiller Low water level fault",
                        "Chiller_recoverable_faults",
                        "Chiller LP fault",
                        "Pump_Overload_fault",
                        "chiller_compressor_overload_fault",
                        "Chiller Non recoverable faults",
                        "Chiller_LiquidTemp_Inlet_outlet_water temp offset",
                        "Battery_Conditioning_failed_High Liq Temp",
                        "Battery_Conditioning_cooling_failed",
                        "Cold_Tank_Low_Liquid_Warning",
                        "Chiller_Setting_Error",
                        "Chiller_Remote_Logic_fault"]
new_fault_mech_heater_list=["Fluid_Inlet_High_Temp_Fault",
                            "Battery_Conditioning_heating failed",
                            "Hot_Tank_Low_Liquid_Warning",
                            "CMS_HotTank_Overtemp_protect",
                            "CMS_HotTank_Overtemp_cutoff",
                            "Heater_High_Temperature_Fault",
                            "Heater_Low_Temperature_Fault",
                            "CMS_HotTank_open_Offset_Warning",
                            "Heater_Low_Water_Level_Fault",
                            "Heater_Probe_Fault"]
new_fault_mech_misc_list=["MBV_Malfuntion",                          
                        "Air_Comp_Overheat_Protection"]
new_fault_charging_algo_list=["Station Cell over voltage",
                        "CellOverTemperature",
                        "Cell_Under_Temperature_Fault",                           
                        "Incomplete Charge",  
                        "Pack_Temperature_Imbalance",
                        "Pack_Voltage_Imbalance",
                        "tec_failure"]
new_fault_int_sys_bms_ota_list=["BMS_OTA_Cloud_Display_No_Response",
                        "BMS_OTA_Target_Image_Unavailable",
                        "BMS_OTA_Don't_Do_Cmd",
                        "BMS_OTA_Flasher_Error",
                        "BMS_OTA_Attempt_Timeout",
                        "BMS_OTA_Attempts_Exhausted",
                        "BMS_OTA_Bootloader_Start_Fail"]
new_fault_int_sys_bms_list=["BMS_ChargeProtection",
                        "BMS CAN Freeze",
                        "BMS Not in charging State",
                        "BMS_Wakeup_Fail"]
new_fault_int_sys_misc_list=["Fut_Protection"]
new_fault_int_sys_user_list=["Vehicle blacklisted"]
new_fault_eplug_locking_list=["GunLockFailed_1st_attempt", 
                                "Unauthorized_GUN_Removal", 
                                "GunLockFailed_2nd_attempt", 
                                "SolFB_1_before_gun_lock"]
new_fault_eplug_unlocking_list=["Unlock_failure",  
                                "UnIntentional_GunUnlock"]
new_fault_eplug_temperature_list=["GunTempImbalanceFault",    
                        "Gun_over_temperature",
                        "Gun_over_temp_warning",  
                        "GunTempImbalanceDetect"]
new_fault_eplug_msic_list=["Gun_theft",
                            "Gun_Locked_In_Air"] 
  
    
def decode_error_codes():
    global compare_old_new_fault_codes,new_fault_stucture_mapping,CMS_internal_can_dict
    global new_fault_elec_sop_list,new_fault_elec_safety_list,new_fault_elec_input_grid_list
    global new_fault_elec_output_power_list,new_fault_elec_comms_list,new_fault_elec_sensor_list
    global new_fault_mech_chiller_list,new_fault_mech_heater_list,new_fault_mech_misc_list
    global new_fault_charging_algo_list,new_fault_int_sys_bms_ota_list,new_fault_int_sys_bms_list
    global new_fault_int_sys_misc_list,new_fault_int_sys_user_list,new_fault_eplug_locking_list
    global new_fault_eplug_unlocking_list,new_fault_eplug_temperature_list,new_fault_eplug_msic_list
    out_dict={}

    #region old codes
    try:
        c1=CMS_internal_can_dict["code_1"]
    except:
        c1=0
    try:
        c2=CMS_internal_can_dict["code_2"]
    except:
        c2=0
    try:
        c3=CMS_internal_can_dict["code_3"]
    except:
        c3=0       
    try:
        c4=CMS_internal_can_dict["code_4"]
    except:
        c4=0
    try:
        c5=CMS_internal_can_dict["code_5"]
    except:
        c5=0

    if(c1==-1):
        c1=0
    if(c2==-1):
        c2=0
    if(c3==-1):
        c3=0
    if(c4==-1):
        c4=0
    if(c5==-1):
        c5=0
    
    
    c1_bin=bin(c1)[2:].zfill(16)
    c2_bin=bin(c2)[2:].zfill(16)
    c3_bin=bin(c3)[2:].zfill(16)
    c4_bin=bin(c4)[2:].zfill(16)
    c5_bin=bin(c5)[2:].zfill(16)
    
    
    c1_list=["SPD Fault","ELR Fault","VoltageRelay Fault",
            "EM_SW","Battery Conditioning failed",
            "BMS_ChargeProtection","BMS CAN Freeze",
            "BMS Not in charging State","UnIntentional GunUnlock",
            "Station Cell over voltage","GunLockFailed_1st_attempt",
            "Rectifier - Ref current offset","Reference - sensor Current offset",
            "No Current Fault","Over current","Precharge failed"]
    c2_list=["Current Sense open","Gun_Temp_Sense_Open","Unauthorized_GUN_Removal",
            "Chiller_fault_detection","AFT_fault","HP_fault","Chiller Low water level fault",
            "Charger_DC_Contactor_Open","Charger_DC_Contactor_PreCharge_Weld",
            "Polarity_Reversal","BMS_Contactor_Weld","BMS_Contactor_Open",
            "Cold_Tank_Low_Liquid_Warning","Cell_Under_Temperature_Fault",
            "Gun_over_temperature","Gun_over_temp_warning"]
    c3_list=["chiller_tank_over_temperature_computed_by_mcu","Unlock_failure",
            "GunTemp_Sense_Open_Warning","Hot_Tank_Low_Liquid_Warning",
            "Incomplete Charge","Zero_current_Offset","Fluid_Inlet_High_Temp_Fault",
            "MBV_Malfuntion","CellOverTemperature","GunTempImbalanceDetect","Fut_Protection",
            "Battery_Conditioning_failed_High_Liq_Temp","Pack_Temperature_Imbalance",
            "Pack_Voltage_Imbalance","tec_failure","GunTempImbalanceFault"]
    c4_list=["CMS_HotTank_Overtemp_cutoff","CMS_HotTank_Overtemp_protect","CMS_HotTank_open_Offset_Warning",
             "Heater_Comm_Fail","Chiller_Comm_Fail","EnergyMeter_Comm_Fail",
             "BMS_OTA_Cloud_Display_No_Response","BMS_OTA_Target_Image_Unavailable",
             "BMS_OTA_Don't_Do_Cmd","BMS_OTA_Flasher_Error",
             "BMS_OTA_Attempt_Timeout","BMS_OTA_Attempts_Exhausted",
             "BMS_OTA_Bootloader_Start_Fail","Vehicle blacklisted","Pump_Overload_fault","Gun_theft"]
    c5_list=["Heater_High_Temperature_Fault","Heater_Low_Temperature_Fault","Heater_Probe_Fault",
             "Heater_Low_Water_Level_Fault","GunLockFailed_2nd_attempt","SolFB_1_before_gun_lock",
             "Chiller LP fault","AFT probe fail"]

    update_fault_dict_from_bin(fault_list=c1_list,bin_val=c1_bin,old_format=1)
    update_fault_dict_from_bin(fault_list=c2_list,bin_val=c2_bin,old_format=1)
    update_fault_dict_from_bin(fault_list=c3_list,bin_val=c3_bin,old_format=1)
    update_fault_dict_from_bin(fault_list=c4_list,bin_val=c4_bin,old_format=1)
    update_fault_dict_from_bin(fault_list=c5_list,bin_val=c5_bin,old_format=1)
    
    
    
    #endregion
    
    #region new codes
    # try:
    #     print_with_log("CMS elec sop: "+str(CMS_internal_can_dict["cms_fault_elec_sop"])+"EM fault: "+str(fault_dict_new["EM_SW"]))
    # except:
    #     pass
    #region get CAN data
    try:
        new_fault_elec_sop= CMS_internal_can_dict["cms_fault_elec_sop"]
    except:
        new_fault_elec_sop=0

    if(new_fault_elec_sop==-1):
        new_fault_elec_sop=0
    try:
        new_fault_elec_safety= CMS_internal_can_dict["cms_fault_elec_safety"]
    except:
        new_fault_elec_safety=0
    if(new_fault_elec_safety==-1):
        new_fault_elec_safety=0
    try:
        new_fault_elec_input_grid= CMS_internal_can_dict["cms_fault_elec_input_grid"]
    except:
        new_fault_elec_input_grid=0
    if(new_fault_elec_input_grid==-1):
        new_fault_elec_input_grid=0
    try:
        new_fault_elec_output_power= CMS_internal_can_dict["cms_fault_elec_output_power"]
    except:
        new_fault_elec_output_power=0

    if(new_fault_elec_output_power==-1):
        new_fault_elec_output_power=0
    try:
        new_fault_elec_comms= CMS_internal_can_dict["cms_fault_elec_comms"]
    except:
        new_fault_elec_comms=0
    if(new_fault_elec_comms==-1):
        new_fault_elec_comms=0
    try:
        new_fault_elec_sensor= CMS_internal_can_dict["cms_fault_elec_sensor"]
    except:
        new_fault_elec_sensor=0
    if(new_fault_elec_sensor==-1):
        new_fault_elec_sensor=0
    try:
        new_fault_mech_chiller= CMS_internal_can_dict["cms_fault_mech_chiller"]
    except:
        new_fault_mech_chiller=0
    if(new_fault_mech_chiller==-1):
        new_fault_mech_chiller=0
    try:
        new_fault_mech_heater= CMS_internal_can_dict["cms_fault_mech_heater"]
    except:
        new_fault_mech_heater=0
    if(new_fault_mech_heater==-1):
        new_fault_mech_heater=0
    try:
        new_fault_mech_misc= CMS_internal_can_dict["cms_fault_mech_misc"]
    except:
        new_fault_mech_misc=0
    if(new_fault_mech_misc==-1):
        new_fault_mech_misc=0
    try:
        new_fault_charging_algo= CMS_internal_can_dict["cms_fault_charging_algo"]        
    except:
        new_fault_charging_algo=0
    if(new_fault_charging_algo==-1):
        new_fault_charging_algo=0
    try:
        new_fault_int_sys_bms_ota= CMS_internal_can_dict["cms_fault_int_sys_bms_ota"]
    except:
        new_fault_int_sys_bms_ota=0
    if(new_fault_int_sys_bms_ota==-1):
        new_fault_int_sys_bms_ota=0
    try:
        new_fault_int_sys_bms= CMS_internal_can_dict["cms_fault_int_sys_bms"]
    except:
        new_fault_int_sys_bms=0
    if(new_fault_int_sys_bms==-1):
        new_fault_int_sys_bms=0
    try:
        new_fault_int_sys_misc= CMS_internal_can_dict["cms_fault_int_sys_misc"]
    except:
        new_fault_int_sys_misc=0
    if(new_fault_int_sys_misc==-1):
        new_fault_int_sys_misc=0
    try:
        new_fault_int_sys_user= CMS_internal_can_dict["cms_fault_int_sys_user"]
    except:
        new_fault_int_sys_user=0
    if(new_fault_int_sys_user==-1):
        new_fault_int_sys_user=0
    try:
        new_fault_eplug_locking= CMS_internal_can_dict["cms_fault_eplug_locking"]
    except:
        new_fault_eplug_locking=0
    if(new_fault_eplug_locking==-1):
        new_fault_eplug_locking=0
    try:
        new_fault_eplug_unlocking= CMS_internal_can_dict["cms_fault_eplug_unlocking"]
    except:
        new_fault_eplug_unlocking=0
    if(new_fault_eplug_unlocking==-1):
        new_fault_eplug_unlocking=0
    try:
        new_fault_eplug_temperature= CMS_internal_can_dict["cms_fault_eplug_temperature"]
    except:
        new_fault_eplug_temperature=0
    if(new_fault_eplug_temperature==-1):
        new_fault_eplug_temperature=0
    try:
        new_fault_eplug_msic= CMS_internal_can_dict["cms_fault_eplug_misc"]
    except:
        new_fault_eplug_msic=0
    if(new_fault_eplug_msic==-1):
        new_fault_eplug_msic=0

    #endregion

    new_fault_elec_sop_bin=bin(new_fault_elec_sop)[2:].zfill(32)
    new_fault_elec_safety_bin=bin(new_fault_elec_safety)[2:].zfill(32)
    new_fault_elec_input_grid_bin=bin(new_fault_elec_input_grid)[2:].zfill(32)
    new_fault_elec_output_power_bin=bin(new_fault_elec_output_power)[2:].zfill(32)
    new_fault_elec_comms_bin=bin(new_fault_elec_comms)[2:].zfill(32)
    new_fault_elec_sensor_bin=bin(new_fault_elec_sensor)[2:].zfill(32)
    new_fault_mech_chiller_bin=bin(new_fault_mech_chiller)[2:].zfill(32)
    new_fault_mech_heater_bin=bin(new_fault_mech_heater)[2:].zfill(32)
    new_fault_mech_misc_bin=bin(new_fault_mech_misc)[2:].zfill(32)
    new_fault_charging_algo_bin=bin(new_fault_charging_algo)[2:].zfill(32)
    # print_with_log("cms_charge_prot_can: "+str(new_fault_charging_algo)+"bin val: "+str(new_fault_charging_algo_bin))
    
    new_fault_int_sys_bms_ota_bin=bin(new_fault_int_sys_bms_ota)[2:].zfill(32)
    new_fault_int_sys_bms_bin=bin(new_fault_int_sys_bms)[2:].zfill(32)
    new_fault_int_sys_misc_bin=bin(new_fault_int_sys_misc)[2:].zfill(32)
    new_fault_int_sys_user_bin=bin(new_fault_int_sys_user)[2:].zfill(32)
    new_fault_eplug_locking_bin=bin(new_fault_eplug_locking)[2:].zfill(32)
    new_fault_eplug_unlocking_bin=bin(new_fault_eplug_unlocking)[2:].zfill(32)
    new_fault_eplug_temperature_bin=bin(new_fault_eplug_temperature)[2:].zfill(32)
    new_fault_eplug_msic_bin=bin(new_fault_eplug_msic)[2:].zfill(32)
    
    update_fault_dict_from_bin(fault_list=new_fault_elec_sop_list,bin_val=new_fault_elec_sop_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_elec_safety_list,bin_val=new_fault_elec_safety_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_elec_input_grid_list,bin_val=new_fault_elec_input_grid_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_elec_output_power_list,bin_val=new_fault_elec_output_power_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_elec_comms_list,bin_val=new_fault_elec_comms_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_elec_sensor_list,bin_val=new_fault_elec_sensor_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_mech_chiller_list,bin_val=new_fault_mech_chiller_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_mech_heater_list,bin_val=new_fault_mech_heater_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_mech_misc_list,bin_val=new_fault_mech_misc_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_charging_algo_list,bin_val=new_fault_charging_algo_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_int_sys_bms_ota_list,bin_val=new_fault_int_sys_bms_ota_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_int_sys_bms_list,bin_val=new_fault_int_sys_bms_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_int_sys_misc_list,bin_val=new_fault_int_sys_misc_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_int_sys_user_list,bin_val=new_fault_int_sys_user_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_eplug_locking_list,bin_val=new_fault_eplug_locking_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_eplug_unlocking_list,bin_val=new_fault_eplug_unlocking_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_eplug_temperature_list,bin_val=new_fault_eplug_temperature_bin,old_format=0)
    update_fault_dict_from_bin(fault_list=new_fault_eplug_msic_list,bin_val=new_fault_eplug_msic_bin,old_format=0)
    

    #endregion

compare_old_new_fault_codes=0
def update_error_codes():
    global CMS_internal_can_dict,fault_dict_new,fault_dict_old
    while(1):
        decode_error_codes()
        sleep(0.1)
          

error_code_thread = Thread(target=update_error_codes)
error_code_thread.start()

def compare_fault_code_structure():
    global compare_old_new_fault_codes,fault_dict_old,fault_dict_new
    global new_fault_stucture_mapping,all_new_fault_list
    timeout_val=2
    try:
        expected_fault_values={}
        result_dict={}
        for k in all_new_fault_list:
            ##### check for new fault structure if some old code is linked to it            
            if(new_fault_stucture_mapping[k]!="None"):
                expected_fault_values[k]=fault_dict_new[k]
                result_dict[k]=0
        
        st_time=timer()
        while( 0 in list(result_dict.values())): 
            for k in expected_fault_values.keys():                
                if(fault_dict_old[new_fault_stucture_mapping[k]] == expected_fault_values[k]):
                    result_dict[k]=1
                
            if(timer()-st_time>timeout_val):
                break
            sleep(0.1)
        
        if(0 in list(result_dict.values())):
            err_list=[]
            for r in result_dict.keys():
                if(result_dict[r]==0):
                    err_list.append(r)
            print_with_log("Fault codes not matching.Test fail")
            print_with_log("Fault codes: "+str(err_list))
        else:
            print_with_log("Fault codes mapping for old vs new structure pass")
    except Exception as e :
        print_with_log("compare_fault_code_structure err: "+str(e))
    
def check_master_session_code(fault_name):
    global CMS_internal_can_dict
    global new_fault_elec_sop_list,new_fault_elec_safety_list,new_fault_elec_input_grid_list
    global new_fault_elec_output_power_list,new_fault_elec_comms_list,new_fault_elec_sensor_list
    global new_fault_mech_chiller_list,new_fault_mech_heater_list,new_fault_mech_misc_list
    global new_fault_charging_algo_list,new_fault_int_sys_bms_ota_list,new_fault_int_sys_bms_list
    global new_fault_int_sys_misc_list,new_fault_int_sys_user_list,new_fault_eplug_locking_list
    global new_fault_eplug_unlocking_list,new_fault_eplug_temperature_list,new_fault_eplug_msic_list
    sleep(1)

    print_with_log("Checking master error code for : "+str(fault_name))
    try:

        charge_prot=CMS_internal_can_dict["charging_algo_protections_status"]
        print_with_log("Charge algo protection: "+str(charge_prot))
        mec_subsystem_num=CMS_internal_can_dict["cms_mec_subsystem_id"]
        mec_category_num=CMS_internal_can_dict["cms_mec_category_id"]
        mec_error_identifier=CMS_internal_can_dict["cms_mec_error_id"]

        print_with_log("Master error code subsystem: "+str(mec_subsystem_num)+" category: "+str(mec_category_num)+" error: "+str(mec_error_identifier))
        ### no charge protection trigger, check for no master error code
        if(charge_prot==1):
            if(mec_subsystem_num ==0 and mec_category_num ==0 and mec_error_identifier ==0):
                print_with_log("No master error code.test pass")
            else:
                print_with_log("master error code without charge protection.test fail")
        else:
            if(mec_subsystem_num ==0 and mec_category_num ==0 and mec_error_identifier ==0):
                print_with_log("No master error code.test fail")
            else:
                error_list=[]
                if(mec_subsystem_num ==1 and mec_category_num ==1):
                    error_list=new_fault_elec_sop_list
                elif(mec_subsystem_num ==1 and mec_category_num ==2):
                    error_list=new_fault_elec_safety_list
                elif(mec_subsystem_num ==1 and mec_category_num ==3):
                    error_list=new_fault_elec_input_grid_list
                elif(mec_subsystem_num ==1 and mec_category_num ==4):
                    error_list=new_fault_elec_output_power_list
                elif(mec_subsystem_num ==1 and mec_category_num ==5):
                    error_list=new_fault_elec_comms_list
                elif(mec_subsystem_num ==1 and mec_category_num ==6):
                    error_list=new_fault_elec_sensor_list
                if(mec_subsystem_num ==2 and mec_category_num ==1):
                    error_list=new_fault_mech_chiller_list
                elif(mec_subsystem_num ==2 and mec_category_num ==2):
                    error_list=new_fault_mech_heater_list
                elif(mec_subsystem_num ==2 and mec_category_num ==3):
                    error_list=new_fault_mech_misc_list
                elif(mec_subsystem_num ==3 and mec_category_num ==1):
                    error_list=new_fault_charging_algo_list
                if(mec_subsystem_num ==4 and mec_category_num ==1):
                    error_list=new_fault_int_sys_bms_ota_list
                elif(mec_subsystem_num ==4 and mec_category_num ==2):
                    error_list=new_fault_int_sys_bms_list
                elif(mec_subsystem_num ==4 and mec_category_num ==3):
                    error_list=new_fault_int_sys_misc_list
                elif(mec_subsystem_num ==4 and mec_category_num ==4):
                    error_list=new_fault_int_sys_user_list
                if(mec_subsystem_num ==5 and mec_category_num ==1):
                    error_list=new_fault_eplug_locking_list
                elif(mec_subsystem_num ==5 and mec_category_num ==2):
                    error_list=new_fault_eplug_unlocking_list
                elif(mec_subsystem_num ==5 and mec_category_num ==3):
                    error_list=new_fault_eplug_temperature_list
                elif(mec_subsystem_num ==5 and mec_category_num ==4):
                    error_list=new_fault_eplug_msic_list
                
                master_err_name=error_list[mec_error_identifier-1]

                print_with_log("Master error name: "+str(master_err_name))

                if(master_err_name == fault_name):
                    print_with_log("Master session error code setting pass")
                else:
                    print_with_log("Master session error code setting fail")

            sleep(1)
        if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            if(CMS_internal_can_dict["set_current"]>20):
                print_with_log("Charge continue pass")
            else:
                print_with_log("Charge continue fail")
        else:
            if(CMS_internal_can_dict["set_current"]>20):
                print_with_log("Charge stop fail")
            else:
                print_with_log("Charge stop pass")

    except Exception as e:
        print_with_log("error during checking master session error for fault: "+str(fault_name)+ " err: "+str(e))

def get_display_activity_id():
    global CMS_internal_can_dict
    id=CMS_internal_can_dict["cms_ui_activity_id"]
    return id

fault_state_activity_id={"SPD Fault":83,
                        "ELR Fault":99,
                        "VoltageRelay Fault":101,
                        "EM_SW":103,   
                        "Grid_Power_Cut":101,  
                        "Rectifier - Ref current offset Positive":83,   
                        "Rectifier - Ref current offset Negative":83,
                        "Reference - sensor Current offset  Positive":83,
                        "Reference - sensor Current offset  Negative":83,
                        "Rectifier derated":83,
                        "Over current":99,
                        "No Current Fault":99,
                        "Precharge failed":99,
                        "Current Sense open":99,
                        "Current sensor fail/faulty offset":99,
                        "Gun_Temp_Sense_Failure":99,
                        "Positive GunTempSense lowside fault":83,
                        "Positive GunTempSense highside fault":83,
                        "Negative GunTempSense lowside fault":83,
                        "Negative GunTempSense highside fault":83,
                        "Hot tank Watertemp sense lowside fault":83,
                        "Hot tank Watertemp sense highside fault":83,
                        "Cold tank Watertemp sense lowside fault":83,
                        "Cold tank Watertemp sense highside fault":83,
                        "Inlet Watertemp sense lowside fault":83,
                        "Inlet Watertemp sense highside fault":83,
                        "Outlet Watertemp sense lowside fault":83,
                        "Outlet Watertemp sense highside fault":83,
                        "Charger-DC_Contactor_Open":99,
                        "Charger_DC_polarity_reverse":99,
                        "CMS 48V detection circuit fault":99,
                        "Charger_DC_Contactor_PreCharge_Weld":99,
                        "Charger_DC_Contactor_PreCharge_Weld_reverse":99,
                        "Polarity_Reversal":100,
                        "BMS_Contactor_Weld":83,
                        "BMS_Contactor_Open":100,
                        "Gun_Temp_Sense_Open":83,
                        "Heater_Comm_Fail":83,
                        "Chiller_Comm_Fail":83,
                        "EnergyMeter_Comm_Fail":83,
                        "smoke sensor_detect":99,
                        "Phase reversal":101,
                        "current_sensor_Low_Temp_fault":83,
                        "current_sensor_high_Temp_fault":83,
                        "Chiller_fault_detection":83,
                        "AFT_fault":83,
                        "AFT_fault_cms_computed":83,
                        "HP_fault":83,
                        "Chiller Low water level fault":83,
                        "Chiller_recoverable_faults":83,
                        "Chiller LP fault":83,
                        "Pump_Overload_fault":83,
                        "chiller_compressor_overload_fault":83,
                        "Chiller Non recoverable faults":83,
                        "Chiller_LiquidTemp_Inlet_outlet_water temp offset":83,
                        "Fluid_Inlet_High_Temp_Fault":83,
                        "MBV_Malfuntion":83,
                        "Battery_Conditioning_heating failed":83,
                        "Battery_Conditioning_failed_High Liq Temp":83,
                        "Battery_Conditioning_cooling_failed":83,
                        "Chiller_Setting_Error":83,
                        "Chiller_Remote_Logic_fault":83, 
                        "Cold_Tank_Low_Liquid_Warning":83,
                        "Hot_Tank_Low_Liquid_Warning":83,
                        "CMS_HotTank_Overtemp_protect":83,
                        "CMS_HotTank_Overtemp_cutoff":99,
                        "Heater_Low_Temperature_Fault":83,
                        "Heater_High_Temperature_Fault":83,
                        "CMS_HotTank_open_Offset_Warning":83,
                        "Heater_Low_Water_Level_Fault":83,
                        "Heater_Probe_Fault":83,
                        "Air_Comp_Overheat_Protection":83,
                        "Station Cell over voltage":99,
                        "CellOverTemperature":99,
                        "Cell_Under_Temperature_Fault":100,
                        "Over_current_fault":99,
                        "Incomplete Charge":83,  
                        "Pack_Temperature_Imbalance":83,
                        "Pack_Voltage_Imbalance":100,
                        "tec_failure":83,
                        "Fut_Protection":99,
                        "BMS_ChargeProtection":100,
                        "BMS CAN Freeze":100,
                        "BMS Not in charging State":100,
                        "BMS_Wakeup_Fail":100,
                        "BMS_OTA_Cloud_Display_No_Response":67,
                        "BMS_OTA_Target_Image_Unavailable":67,
                        "BMS_OTA_Don't_Do_Cmd":67,
                        "BMS_OTA_Flasher_Error":67,
                        "BMS_OTA_Attempt_Timeout":67,
                        "BMS_OTA_Attempts_Exhausted":67,
                        "BMS_OTA_Bootloader_Start_Fail":67,
                        "Vehicle blacklisted":49,
                        "GunTempImbalanceFault":83,    
                        "Gun_over_temperature":99,
                        "Gun_over_temp_warning":83,  
                        "GunTempImbalanceDetect":83,
                        "Gun_theft":99,                           
                        "UnIntentional_GunUnlock":83,                           
                        "GunLockFailed_1st_attempt":34, 
                        "Unauthorized_GUN_Removal":99,                             
                        "chiller_tank_over_temperature_computed_by_mcu":83,
                        "Unlock_failure":98,                                                    
                        "GunLockFailed_2nd_attempt":83,
                        "SolFB_1_before_gun_lock":83,
                        "Gun_Locked_In_Air":17                    
                            
                            }

def check_display_activity_id(type,name):
    global fault_state_activity_id,CMS_internal_can_dict
    try:
        # if(CMS_version == 4.0):  
        #     st_time=timer()
        #     while(ota_can_dict["gun_lock_request"]==1):
        #         print_with_log("waiting for gun unlock request from station")
        #         sleep(1)
        #         if(timer()-st_time>30):
        #             print_with_log("timeout. test fail")
        #             break
        #     print_with_log("gun unlock request received")
        #     emulate_solenoid_fb(0)
        #     while(CMS_internal_can_dict["cms_ui_activity_id"]==87):
        #         pass  
        
        # elif(CMS_version == 4.2):
        #     st_time=timer()    
        #     while(CMS_internal_can_dict["cx_actuator_status"]!=1):
        #         print_with_log("waiting for cx unlock actuactor to activate")
        #         sleep(0.1)
        #         if(timer()-st_time>10):
        #             print_with_log("cx unlock actuactor not received.Test fail")
        #             break
        #     sleep(2)
        #     update_cp_state(6)  

        #     st_time=timer()    
        #     while(CMS_internal_can_dict["e_plug_interaction_state"]==3):
        #         print_with_log("waiting for e_plug_interaction_state to chnage")
        #         sleep(0.1)
        #         if(timer()-st_time>10):
        #             print_with_log("e_plug_interaction_state not changed .Test fail")
        #             break
        #     print_with_log("e_plug_interaction_state changed to: "+str(CMS_internal_can_dict["e_plug_interaction_state"]))
        #     sleep(1)


        if(type=="protection"):
            print_with_log("Checking display activity for fault: "+str(name))
            id=CMS_internal_can_dict["cms_ui_activity_id"]
            print_with_log("Display activity id: "+str(id))
            if(id == fault_state_activity_id[name]):
                print_with_log("Display activity id pass")
                sleep(2)
                if(CMS_internal_can_dict["cms_ui_activity_id"] == id):
                    print_with_log("Display activity id persistance after 2 sec. pass")
                else:
                    print_with_log("Display activity id persistance after 2 sec. fail")
            else:
                print_with_log("Display activity id fail.expected val: "+str(fault_state_activity_id[name]))
        elif(type=="direct"):
            print_with_log("Checking display activity as: "+str(name))
            id=CMS_internal_can_dict["cms_ui_activity_id"]
            print_with_log("Display activity id: "+str(id))
            if(id == name):
                print_with_log("Display activity id pass")
            else:
                print_with_log("Display activity id fail.")
    except Exception as e:
        print_with_log("UI_activity id check fail err: "+str(e))








    pass

def check_master_error_code_reset():
    global CMS_internal_can_dict
    sleep(1)
    print_with_log("Checking MEC reset")
    mec_subsystem_num=CMS_internal_can_dict["cms_mec_subsystem_id"]
    mec_category_num=CMS_internal_can_dict["cms_mec_category_id"]
    mec_error_identifier=CMS_internal_can_dict["cms_mec_error_id"]

    print_with_log("Master error code subsystem: "+str(mec_subsystem_num)+" category: "+str(mec_category_num)+" error: "+str(mec_error_identifier))
    if(mec_subsystem_num ==0 and mec_category_num==0 and mec_error_identifier==0):
        print_with_log("MEC reset pass")
    else:
        print_with_log("MEC reset fail")

#endregion

#region result_file definition
dateString = str(datetime.datetime.now().strftime("%Y-%m-%d_%H_%M_%S"))
# Defining storage path and name according to the time for the result file.
filepath = "/home/raspi/Desktop/P4_FW_tests/Data/" + dateString + "_CMS_FW_tests" + ".txt"
file=open(filepath,'a')
file.write("CMS Firmware test results\n")
file.close()
#endregion

#region CAN_functions
can_A_filepath="/home/raspi/Desktop/P4_FW_tests/Data/" + dateString + "_CMS_FW_rectifier_log" + ".csv"
can_B_filepath="/home/raspi/Desktop/P4_FW_tests/Data/" + dateString + "_CMS_FW_CI_log" + ".csv"
can_display_filepath="/home/raspi/Desktop/P4_FW_tests/Data/" + dateString + "_CMS_FW_display_can_log" + ".csv"
display_msg_duration_file="/home/raspi/Desktop/P4_FW_tests/Data/" + dateString + "_CMS_FW_display_can_duration" + ".csv"
log_state=0
file_headers=0


def convert_to_bytes(v):
    hex_val=hex(v)[2:]
    while(len(hex_val)<4):
        hex_val="0"+hex_val
    byte6_hex="0x"+hex_val[:2]
    byte7_hex="0x"+hex_val[-2:]
    byte6_int=int(byte6_hex,16)
    byte7_int=int(byte7_hex,16)
    return byte6_int,byte7_int


def CAN_A_update_fun():
    global can0,CMS_internal_can_dict,dbc_cms_inter,rectifier_control_request,rectifier_readback_values
    global deactivate_rectifiers_num
    can_setup_msg="sudo ip link set can0 type can bitrate 125000"   
    err_count=0
    contactor_msg_last_time=0
    last_time=0
    id_list=["0x108182FE","0x108282FE","0x108382FE","0x108482FE","0x108582FE","0x108682FE","0x108782FE","0x108882FE","0x108982FE","0x108A82FE","0x108B82FE","0x108C82FE"]
    send_list=["0x1081827E","0x1082827E","0x1083827E","0x1084827E","0x1085827E","0x1086827E","0x1087827E","0x1088827E","0x1089827E","0x108A827E","0x108B827E","0x108C827E"]
    int_list=[]
    for a in id_list:
        int_list.append(int(a,16))
    while(1):
        try:
            vol_val_conv=int(rectifier_readback_values["voltage"]*1024.0)
            curr_val_conv=int(rectifier_readback_values["current"]*1024.0)
            v_b6,v_b7=convert_to_bytes(vol_val_conv)
            c_b6,c_b7=convert_to_bytes(curr_val_conv)
            vol_msg_data=[1,117,0,0,0,0,v_b6,v_b7]
            curr_msg_data=[1,130,0,0,0,0,c_b6,c_b7]
        except:
            pass
        try:
            message = can0.recv(1)
            ###rectifier setting broadcast message read
            if(message.is_extended_id==True and message.arbitration_id==int("0x108081FE",16)): ## control broadcast signal
                # print(message)
                err_count=0
                ind_bit=message.data[1]
                byte6=message.data[6]
                byte7=message.data[7]

                if(ind_bit==0):  ### voltage control
                    hex_str_byte6=str(hex(byte6))[2:]
                    hex_str_byte7=str(hex(byte7))[2:]
                    if(len(hex_str_byte6)==1):
                        hex_str_byte6="0"+hex_str_byte6
                    if(len(hex_str_byte7)==1):
                        hex_str_byte7="0"+hex_str_byte7
                    rev_hex="0x"+hex_str_byte6+hex_str_byte7
                    # print(rev_hex)
                    vol_data=int(rev_hex,16)/1024.0
                    if(vol_data!= rectifier_control_request["voltage"]):
                        # print_with_log("CMS requesting rect voltage: "+str(vol_data))
                        rectifier_control_request["voltage"]=vol_data

                if(ind_bit==3):  ### current control
                    hex_str_byte6=str(hex(byte6))[2:]
                    hex_str_byte7=str(hex(byte7))[2:]
                    if(len(hex_str_byte6)==1):
                        hex_str_byte6="0"+hex_str_byte6
                    if(len(hex_str_byte7)==1):
                        hex_str_byte7="0"+hex_str_byte7
                    rev_hex="0x"+hex_str_byte6+hex_str_byte7
                    # print(rev_hex)
                    curr_data=int(rev_hex,16)/20.0
                    if(curr_data!=rectifier_control_request["ind_current"]):
                        print_with_log("CMS requesting rect current: "+str(curr_data))
                        rectifier_control_request["ind_current"]=curr_data
            
            if(message.arbitration_id in int_list):
                ###rectifier readback resonse 
                for i in range(len(id_list)):
                    if(message.is_extended_id==True and message.arbitration_id==int(id_list[i],16)):
                        ind_bit=message.data[1]
                        if(ind_bit==117): ### voltage readback
                            if(i>=deactivate_rectifiers_num):
                                v_msg=can.Message(arbitration_id=int(send_list[i],16),is_extended_id=True,data=vol_msg_data)                    
                                can0.send(v_msg) 
                        elif(ind_bit==130): ### current readback
                            if(i>=deactivate_rectifiers_num):                           
                                c_msg=can.Message(arbitration_id=int(send_list[i],16),is_extended_id=True,data=curr_msg_data)                                               
                                can0.send(c_msg)

            if message is None:
                err_count+=1   
                if(err_count>5):
                    for k in CMS_internal_can_dict.keys():
                        CMS_internal_can_dict[k]=-1  
                    os.system('sudo ip link set can0 down')
                    sleep(0.5)
                    os.system(can_setup_msg)
                    os.system('sudo ip link set can0 up')             
            else:
                err_count=0
                try:                    
                    msg_dict=dbc_cms_inter.decode_message(message.arbitration_id, message.data)
                    # if(message.arbitration_id==11):
                    #     print(msg_dict)
                    # if(message.arbitration_id==769):
                    #     print(float(timer()-last_time))
                    #     last_time=timer()
                    for k in msg_dict.keys():
                        CMS_internal_can_dict[k]=msg_dict[k]
                        # if(k=="cms_fault_charging_algo"):
                        #     print_with_log(str(k)+" : "+str(msg_dict[k]))                            
                        err_count=0
                        
                except:                    
                    pass
        except Exception as ex:
            # print_with_log(ex)
            pass
               

def CAN_B_update_fun():
    global ota_bus,ota_can_dict,ota_db 
    global flasher_current_mainstate,flasher_current_substate,flasher_current_timeout_error,flasher_current_error_code   
    err_count=0
    while(1):
        try:
            message = ota_bus.recv(1)
            # print_with_log(message)
            if(err_count>20):
                for k in ota_can_dict.keys():
                    ota_can_dict[k]=-1  
                os.system('sudo ip link set can1 down')
                sleep(0.5)
                os.system('sudo ip link set can1 type can bitrate 250000')
                os.system('sudo ip link set can1 up')

            if message is None:
                for k in ota_can_dict.keys():
                    ota_can_dict[k]=-1
                # print_with_log("No CAN Message_IN_CI_CAN....")
                err_count+=1                
            else:
                err_count=0
                msg_dict=ota_db.decode_message(message.arbitration_id, message.data)

                if(ota_message_timings[message.arbitration_id]==-1):
                        ota_message_timings[message.arbitration_id]=timer()   
                else:
                    ota_message_timings[message.arbitration_id]=timer()-ota_message_timings[message.arbitration_id] 
                
                for k in msg_dict.keys():
                    ota_can_dict[k]=msg_dict[k]                     
                    if(k=="cms_state"):
                        flasher_current_mainstate=flasher_mainstate_list[msg_dict[k]]
                    if(k=="cms_substate"):
                        flasher_current_substate=flasher_substate_list[msg_dict[k]]
                    if(k=="cms_timeout"):
                        flasher_current_timeout_error=flasher_timeout_error_list[msg_dict[k]]
                    if(k=="cms_error_code"):
                        flasher_current_error_code=flasher_error_code_list[msg_dict[k]]
                # print_with_log(msg_dict)
                
        except Exception as ex:
            # print_with_log(ex)
            pass

def update_chiller_setting_ok_data():
    global CMS_internal_can_dict
    while(1):
        try:
            
            int_val = CMS_internal_can_dict["chiller_diagnostic_status"]
            # bin_val=bin(int_val)[2:].zfill(16)
            bin_val1=bin(int_val)[2:]
            bin_val=bin_val1.zfill(16)
            # print("Chiller diagnostic int: "+str(int_val)+" bin: "+str(bin_val))

            if(int_val != -1):
                chiller_setting_list=[
                    "chiller_comm_status",
                    "chiller_setting_cheched_flag",
                    "chiller_settings_ok",
                    "chiller_high_set_setting_ok",
                    "chiller_low_set_setting_ok",
                    "chiller_set_point_setting_ok",
                    "chiller_diff_setting_ok",
                    "chiller_ht_alrm_setting_ok",
                    "chiller_lt_alrm_setting_ok",
                    "chiller_aft_set_setting_ok",
                    "chiller_aft_diff_setting_ok",
                    "chiller_remote_strt_setting_ok"
                ]

                for i in range(len(chiller_setting_list)):
                    fault_name=chiller_setting_list[i]
                    bin_index=-1*(i+1)
                    signal_val=int(bin_val[bin_index])
                    CMS_internal_can_dict[fault_name]=signal_val 
        except Exception as e :
            print_with_log(" Chiller ok data update error: "+str(e))
        sleep(0.1)
        
update_chiller_setting_ok_data_thread = Thread(target=update_chiller_setting_ok_data)
update_chiller_setting_ok_data_thread.start()


display_can_msg_duration={}
display_can_msg_last_time={}

def decode_rs232_data(data_raw_list):
    global dbc_cms_inter,display_can_dict,display_can_msg_duration,display_can_msg_last_time
    try:
        msg_id= data_raw_list[2]*256+data_raw_list[1]
        if(msg_id not in list(display_can_msg_duration.keys())):
            display_can_msg_duration[msg_id]=0
            display_can_msg_last_time[msg_id]=timer()

        msg_data=[data_raw_list[3],data_raw_list[4],data_raw_list[5],data_raw_list[6],
                data_raw_list[7],data_raw_list[8],data_raw_list[9],data_raw_list[10]]
        
        msg_dict=dbc_cms_inter.decode_message(msg_id, msg_data)
        for k in msg_dict.keys():
            display_can_dict[k]=msg_dict[k]

        display_can_msg_duration[msg_id]= timer()-display_can_msg_last_time[msg_id]
        display_can_msg_last_time[msg_id]= timer()
        
        # print(msg_dict)
    except:
        pass

def update_display_can_fun():
    global ser_232
    while True:
        try:
            if ser_232.in_waiting > 0:  # Check if data is available
                data = ser_232.read_until(b"\x99")
                if(len(data) == 14):
                    decode_rs232_data(list(data))
            sleep(0.001)
        except:
            pass

can_display_update = Thread(target=update_display_can_fun)
can_display_update.start()

###function to send CAN message in OTC CAN bus

def send_can_msg(send_can_msg_name):
    """
    The function `send_can_msg` sends a CAN message using the provided message name and its associated
    signals.

    :param send_can_msg_name: The parameter `send_can_msg_name` is the name of the CAN message that you
    want to send
    """
    # print_with_log("trying to send: "+str(send_can_msg_name))
    global ota_bus,ota_db,ota_can_dict
    signal_list=ota_db.get_message_by_name(send_can_msg_name).signals
    # print_with_log("signal_list: "+str(signal_list))
    signal_data_dict={signal.name:ota_can_dict[signal.name]  for signal in signal_list}
    # print_with_log(signal_data_dict)
    encoded_message = ota_db.encode_message(ota_db.get_message_by_name(send_can_msg_name).frame_id, 
                                            signal_data_dict)
    # print_with_log("encoded msg to send: "+str(encoded_message))
    can_msg = can.Message(arbitration_id=ota_db.get_message_by_name(
        send_can_msg_name).frame_id, data=encoded_message, is_extended_id=False)
    ota_bus.send(can_msg)
    # print_with_log("message sent")

def remove_appostropy(ls_in: list) -> list:
    ls_out=""
    for l in ls_in:        
        ls_out=ls_out+str(l)+","
    return ls_out

def csv_logger():
    global log_state,CMS_internal_can_dict,ota_can_dict,can_A_filepath,can_B_filepath,log_state,file_headers
    global display_can_dict,can_display_filepath,display_msg_duration_file,display_can_msg_duration
    while True: 

        if(log_state==1):
            if(file_headers==0):
                with open(can_A_filepath, "a") as file:                
                    date = "Date"
                    time = "Time"
                    rig_id_header = "RIG_ID"
                    bms_vc_list=list(CMS_internal_can_dict.keys())
                    a=remove_appostropy(bms_vc_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id_header,a)
                    )
                    file.close()
                with open(can_B_filepath, "a") as file:                
                    date = "Date"
                    time = "Time"
                    rig_id_header = "RIG_ID"
                    bms_ci_list=list(ota_can_dict.keys())
                    a=remove_appostropy(bms_ci_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id_header,a)
                    )
                    file.close()
                with open(can_display_filepath, "a") as file:                
                    date = "Date"
                    time = "Time"
                    rig_id_header = "RIG_ID"
                    bms_ci_list=list(display_can_dict.keys())
                    a=remove_appostropy(bms_ci_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id_header,a)
                    )
                    file.close()
                with open(display_msg_duration_file, "a") as file:                
                    date = "Date"
                    time = "Time"
                    rig_id_header = "RIG_ID"
                    bms_vc_list=list(display_can_msg_duration.keys())
                    a=remove_appostropy(bms_vc_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id_header,a)
                    )
                    file.close()
                file_headers=1
            else:
                ctime = datetime.datetime.now()
                date = ctime.strftime("%Y-%m-%d")
                time = ctime.strftime("%H:%M:%S.%f")[:-3]
                rig_id = "FW tester 1"
                with open(can_A_filepath, "a") as file:
                    bms_vc_list=list(CMS_internal_can_dict.values())
                    a=remove_appostropy(bms_vc_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id,a)
                    )
                    file.close()
                with open(can_B_filepath, "a") as file:                
                    bms_ci_list=list(ota_can_dict.values())
                    a=remove_appostropy(bms_ci_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id,a)
                    )
                    file.close()
                with open(can_display_filepath, "a") as file:                
                    bms_ci_list=list(display_can_dict.values())
                    a=remove_appostropy(bms_ci_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id,a)
                    )
                    file.close()
                with open(display_msg_duration_file, "a") as file:                
                    bms_ci_list=list(display_can_msg_duration.values())
                    a=remove_appostropy(bms_ci_list)[:-1]
                    file.write(
                        "{},{},{},{}\n".format(date, time, rig_id,a)
                    )
                    file.close()
                
        sleep(0.2)

canA_update = Thread(target=CAN_A_update_fun)
canB_update = Thread(target=CAN_B_update_fun)
ser_232 = None

def setup_can():
    print_with_log("in can setup function")
    global can0,ota_bus,canA_update,canB_update,csv_thread,BMS_send_thread,bms_send_flag,rect_rb_thread,ser_232
    # can0 is vehicle can and cna1 is charger can
    try:
        os.system('sudo ip link set can1 down')
        os.system('sudo ip link set can0 down')
        can_setup_msg="sudo ip link set can0 type can bitrate 125000"
        os.system(can_setup_msg)
        os.system('sudo ip link set can0 up')
        os.system('sudo ip link set can1 type can bitrate 250000')
        os.system('sudo ip link set can1 up')
        can0 = can.interface.Bus(channel='can0', bustype='socketcan',receive_own_messages=True)
        ota_bus = can.interface.Bus(channel='can1', bustype='socketcan',receive_own_messages=True)
    except Exception as e:
        print_with_log(e)
    
    try:
        ser_232 = serial.Serial(port='/dev/ttyUSB1', baudrate=115200, timeout=1)  # Adjust timeout as needed
    except Exception as e:
        print("RS232 USB converter not detected.")
    sleep(1)
    print_with_log("CAN setup done")
    canA_update.start()
    canB_update.start()
    csv_thread = Thread(target=csv_logger)
    csv_thread.start()
    bms_send_flag=0
    BMS_send_thread.start()

fut_hb_flag=0

def fut_heartbeat_function():
    global can0,fut_hb_flag
    while(1):

        if(fut_hb_flag==1):
            can_hb_msg = can.Message(arbitration_id=640, data=[0,0,0,0,0,0,0,0], is_extended_id=False)
            can0.send(can_hb_msg)

        sleep(0.1)

fut_heartbeat_thread = Thread(target=fut_heartbeat_function)    
fut_heartbeat_thread.start()


#endregion

#region current calibration functions

def send_curr_calibration_values(gain1,gain2,offset1,offset2):
    global can0, CMS_internal_can_dict
    print_with_log("Setting new gain and offset values.g1: "+str(gain1)+" g2: "+str(gain2)+" o1: "+str(offset1)+" o2: "+str(offset2))
    gain1_val=int(gain1*10) 
    gain2_val=int(gain2*10)
    offset1_val=int(offset1*1000)
    offset2_val=int(offset2*1000)

    gain_b0=2
    gain_b1=0
    gain_b2=0
    gain_b3=0
    gain_b5,gain_b4=convert_to_bytes(gain1_val)    
    gain_b7,gain_b6=convert_to_bytes(gain2_val)

    offset_b0=4
    offset_b1=0
    offset_b2=0
    offset_b3=0
    offset_b5,offset_b4=convert_to_bytes(offset1_val)    
    offset_b7,offset_b6=convert_to_bytes(offset2_val)

    can_gain_set_msg = can.Message(arbitration_id=0X401, data=[gain_b0,gain_b1,gain_b2,gain_b3,gain_b4,gain_b5,gain_b6,gain_b7], is_extended_id=False)
    can_offset_set_msg = can.Message(arbitration_id=0X401, data=[offset_b0,offset_b1,offset_b2,offset_b3,offset_b4,offset_b5,offset_b6,offset_b7], is_extended_id=False)
    print_with_log("Gain message: "+str(can_gain_set_msg))
    print_with_log("Offset message: "+str(can_offset_set_msg))

    for i in range(50):
        can0.send(can_gain_set_msg)
        sleep(0.1)

    sleep(3)

    for i in range(50):
        can0.send(can_offset_set_msg)
        sleep(0.1)
    
    print_with_log("waiting for 10 sec for data update in EEPROM")
    sleep(10)
    
    print_with_log("new gain and offset set values.g1: "+str(CMS_internal_can_dict["current_sensor_gain_1"])+
                   " g2: "+str(CMS_internal_can_dict["current_sensor_gain_2"])+" o1: "+str(CMS_internal_can_dict["current_sensor_offset_1"])
                   +" o2: "+str(CMS_internal_can_dict["current_sensor_offset_2"]))

def get_curr_calibartion_values():
    global can0, CMS_internal_can_dict

    g1=CMS_internal_can_dict["current_sensor_gain_1"]
    g2=CMS_internal_can_dict["current_sensor_gain_2"]
    off1=CMS_internal_can_dict["current_sensor_offset_1"]
    off2=CMS_internal_can_dict["current_sensor_offset_2"]
    
    return g1,g2,off1,off2

def get_current_parameters():
    global can0, CMS_internal_can_dict

    g=CMS_internal_can_dict["cms_computed_cs_gain"]    
    off=CMS_internal_can_dict["cms_computed_cs_offset"]
    temp=CMS_internal_can_dict["dc_current_sensor_body_temp"]
    
    return g,off,temp

def linear_interpolate(y1,y2,x1,x2,x):
    x1=float(x1)
    x2=float(x2)
    y1=float(y1)
    y2=float(y2)
    x=float(x)

    if x1 == x2:
        m=1
    else:
        m = (y2 - y1) / (x2 - x1)
    b = y1 - m * x1
    # Calculate and return interpolated y
    return m * x + b

def get_expected_gain_offset_val():
    global CMS_internal_can_dict
    g1,g2,off1,off2=get_curr_calibartion_values()
    temp=CMS_internal_can_dict["dc_current_sensor_body_temp"]

    t1=35
    t2=75
    if(temp<5):
        cal_gain=g1
        cal_offset=off1
    elif(temp<t1):
        cal_offset=linear_interpolate(off1,off2,t1,t2,temp)
        cal_gain=g1
    elif(temp<85):
        cal_offset=linear_interpolate(off1,off2,t1,t2,temp)
        cal_gain=linear_interpolate(g1,g2,t1,t2,temp)
    else:
        cal_gain=g1
        cal_offset=off1

    print_with_log("Sensor body temp: "+str(temp)+" calculated gain: "+str(cal_gain)+" calculated offset: "+str(cal_offset))
    return cal_gain,cal_offset

def set_current_sensor_body_temp(val):
    global all_relay_states
    all_relay_states["CON_DC_TS_P"]=1
    set_temp(val)
    sleep(1)

def reset_currrent_sensor_body_temp():
    global all_relay_states
    all_relay_states["CON_DC_TS_P"]=0
    set_temp(25)
    sleep(1)

#endregion

#region OTC_functions
bl_timeout_err_flag=0
def can_tx_thread_function():
    global ota_can_dict,send_bl_heartbeat_flag
    """
    The function `can_tx_thread` sends CAN messages based on certain conditions and sleeps for 0.1
    seconds.
    """
    global bl_mainstate,bl_substate,bl_timeout_err,bl_err_code
    
    while(1):
        if(send_bl_heartbeat_flag==1):
            try:
                
                if(bl_timeout_err_flag == 0):
                    ota_can_dict['bl_state'] = 3
                    ota_can_dict['bl_substate'] = 2
                    ota_can_dict['bl_timeout'] = 0
                    ota_can_dict['bl_error_code'] = 0
                else:
                    ota_can_dict['bl_state'] = bl_mainstate.value
                    ota_can_dict['bl_substate'] = bl_substate.value
                    ota_can_dict['bl_timeout'] = bl_timeout_err.value
                    ota_can_dict['bl_error_code'] = bl_err_code.value

                go_to_init_inti_state()

            except Exception as e:
                print_with_log("bl send 1 err: "+str(e))
            try:
                send_can_msg("bl_status")
            except Exception as e:
                print_with_log("bl send 2 err: "+str(e))
            try:
                send_can_msg("bl_heartbeat") 
            except Exception as e:
                print_with_log("bl send 3 err: "+str(e))
    
        sleep(0.1)

bl_hb_thread=Thread(target=can_tx_thread_function)
bl_hb_thread.start()

def check_for_jump_to_bl_command(check_for_gun_lock=False):
    global ota_can_dict
    st_time=timer()
    ota_can_dict["cms_jump_bl_command"]=0
    ota_can_dict["gun_lock_request"]=-1
    while(1):
        if(ota_can_dict["cms_jump_bl_command"]==0XAA):
            return True        
        if(timer()-st_time>120):
            print_with_log("CMS Not sending jumpt to BL commnad")
            return False

def send_bl_jump_ack():
    global ota_can_dict,flasher_current_substate
    ota_can_dict["bms_jump_bl_ack"]=0XAA    
    send_can_msg("jump_to_bootloader_ack")    
    print_with_log("Sending bl_jum_ack")


def go_to_init_inti_state():
    global bl_mainstate,bl_substate,send_bl_heartbeat_flag,bl_timeout_err,bl_err_code

    bl_mainstate=bl_mainstate_enum.init
    bl_substate=bl_substate_enum.init_init
    bl_timeout_err=bl_timeout_error_enum.No_timeout
    bl_err_code=bl_error_code_enum.No_error

    ota_can_dict["bl_reset_cause"]=3
    ota_can_dict["bl_image_status"]=0XAA
    ota_can_dict["gun_unlock_retry"]=0
    ota_can_dict["gun_lock_retry"]=0
    ota_can_dict["bl_motor_disable"]=0
    ota_can_dict["bl_pp_detect"]=0
    ota_can_dict["gun_unlock_cmd"]=0
    ota_can_dict["gun_lock_feedback"]=0
    ota_can_dict["gun_lock_cmd"]=0
    ota_can_dict["bl_oem_patch"]=0
    ota_can_dict["bl_fw_version_bugfix"]=0
    ota_can_dict["bl_fw_version_minor"]=5
    ota_can_dict["bl_fw_version_major"]=3
    ota_can_dict["bl_oem_variant"]=0
    ota_can_dict["bl_oem_lookup"]=0

def start_bl_HB():
    global send_bl_heartbeat_flag,bms_send_flag
    bms_send_flag=0
    send_bl_heartbeat_flag=1
    print_with_log("Starting BL HB")

#endregion  

#region heater/chiller server


# # Define the Modbus registers
coils = ModbusSequentialDataBlock(1, [0] * 100)
discrete_inputs = ModbusSequentialDataBlock(1, [0] * 100)
holding_registers = ModbusSequentialDataBlock(1, [0] * 100)
input_registers = ModbusSequentialDataBlock(1, [0] * 100)

# Define the Modbus slave context
slave_context = ModbusSlaveContext(
    di=discrete_inputs,
    co=coils,
    hr=holding_registers,
    ir=input_registers
)



# # Define the Modbus registers
coils_heater = ModbusSequentialDataBlock(1, [0] * 100)
discrete_inputs_heater = ModbusSequentialDataBlock(1, [0] * 100)
holding_registers_heater = ModbusSequentialDataBlock(1, [0]*100)
input_registers_heater = ModbusSequentialDataBlock(1, [0] * 100)
change_heater_flag=1
# Define the Modbus slave context
slave_context_heater = ModbusSlaveContext(
    di=discrete_inputs_heater,
    co=coils_heater,
    hr=holding_registers_heater,
    ir=input_registers_heater
)

slaves_dict={
    0X03: slave_context,
    0X01: slave_context_heater
}

only_heater_dict={
    
    0X01: slave_context_heater
}
only_chiller_dict={
    
    0X03: slave_context
}

rs485_server=None
heater_state=True
chiller_state=True

def run_chiller_heater_server():
    global global_server_dict,slaves_dict,rs485_server,heater_state,chiller_state,stop_server_flag
    while(1):
        # print("heater_chiller function. stop flag: "+str(stop_server_flag))
        # print("heater_state request: "+str(heater_state)+" chiller state request: "+str(chiller_state))
        
        # Start the Modbus serial server
        if(heater_state==True and chiller_state==True and stop_server_flag==0):
            global_server_dict=slaves_dict
            
            try:
                print("Starting heater & chiller servers")
                rs485_server= StartSerialServer(context=ModbusServerContext(slaves=global_server_dict,single=False),defer_start=False,framer=ModbusRtuFramer, port='/dev/ttySC1',baudrate=9600,timeout=1)        
                
                

            except Exception as ex:
                print("chiller/heater start err: "+str(ex))
        
        elif(heater_state==True and chiller_state==False and stop_server_flag==0):
            global_server_dict=only_heater_dict
            print("Starting heater servers")
            try:
                rs485_server= StartSerialServer(context=ModbusServerContext(slaves=global_server_dict,single=False),defer_start=False,framer=ModbusRtuFramer, port='/dev/ttySC1',baudrate=9600,timeout=1)        
                
               
            except Exception as ex:
                print("chiller/heater start err: "+str(ex))

        elif(heater_state==False and chiller_state==True and stop_server_flag==0):
            global_server_dict=only_chiller_dict
            print("Starting chiller servers")
            try:        
                rs485_server= StartSerialServer(context=ModbusServerContext(slaves=global_server_dict,single=False),defer_start=False,framer=ModbusRtuFramer, port='/dev/ttySC1',baudrate=9600,timeout=1)        
                
                
            except Exception as ex:
                print("chiller/heater start err: "+str(ex))
        elif(stop_server_flag==1):
            print("heater/chiller thread ending")
            break
        
            
            
        sleep(0.1)
    

heater_chiller_thread = Thread(target=run_chiller_heater_server)

#endregion


#region EM_RS485 server


# # Define the Modbus registers
default_data=0
EM_coils = ModbusSequentialDataBlock(1, [default_data] * 300)
EM_discrete_inputs = ModbusSequentialDataBlock(1, [default_data] * 300)
EM_holding_registers = ModbusSequentialDataBlock(1, [default_data] * 300)
EM_input_registers = ModbusSequentialDataBlock(1, [default_data] * 300)

# Define the Modbus slave context
EM_slave_context = ModbusSlaveContext(
    di=EM_discrete_inputs,
    co=EM_coils,
    hr=EM_holding_registers,
    ir=EM_input_registers
)



EM_slaves_dict={
    0X02: EM_slave_context,
}


EM_state=True
EM_rs485_server=None

def run_EM_server():
    global EM_slaves_dict,EM_rs485_server,EM_state,stop_server_flag
    while(1):
        # print("EM state request: "+str(EM_state))
        
        # Start the Modbus serial server
        if(EM_state==True and stop_server_flag==0):  
            try:
                print("Starting EM server")
                EM_rs485_server= StartSerialServer(context=ModbusServerContext(slaves=EM_slaves_dict,single=False),defer_start=False,framer=ModbusRtuFramer, port='/dev/ttySC0',baudrate=9600, parity='N', bytsize = 8, stopbits = 1,timeout=1)        
                
            except Exception as ex:
                print("Energy meter start err: "+str(ex))
        elif(stop_server_flag==1):
            print("EM thread ending")
            break

        sleep(0.1)
    

EM_server_thread = Thread(target=run_EM_server)

EM_base_registers_dict={
            'em_watts_total':101,
            'em_watts_r_phase':103,
            'em_watts_y_phase':105,
            'em_watts_b_phase':107,

            'em_power_factor_avg':117,
            'em_power_factor_r_phase':119,
            'em_power_factor_y_phase':121,
            'em_power_factor_b_phase':123,

            'em_apparent_power_total':125,
            'em_apparent_power_r_phase':127,
            'em_apparent_power_y_phase':129,
            'em_apparent_power_b_phase':131,

            'em_voltage_ll_avg':133,
            'em_voltage_ry_phase':135,
            'em_voltage_yb_phase':137,
            'em_voltage_br_phase':139,

            'em_voltage_ln_avg':141,
            'em_voltage_r_phase':143,
            'em_voltage_y_phase':145,
            'em_voltage_b_phase':147,

            'em_current_total':149,
            'em_current_r_phase':151,
            'em_current_y_phase':153,
            'em_current_b_phase':155,

            'em_frequency':157,
            'em_k_watt_hour':159,
            'em_voltage_ampere_hour':161    
        }

EM_can_data_dict={}

for e in EM_base_registers_dict.keys():
    EM_can_data_dict[e]=-1

def update_CAN_EM_data():
    global CMS_internal_can_dict,EM_can_data_dict
    while(1):
        for e in EM_can_data_dict.keys():
            try:
                EM_can_data_dict[e]=CMS_internal_can_dict[e]
            except:
                pass
        sleep(0.2)

EM_update_thread = Thread(target=update_CAN_EM_data)
EM_update_thread.start()

#endregion


#region both_rs485 functions

def set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=True):
    global EM_state,heater_state,chiller_state,stop_server_flag,EM_server_thread,heater_chiller_thread,rs485_server,EM_rs485_server
    EM_state = EM_state_in
    heater_state= heater_state_in
    chiller_state= chiller_state_in
    sleep(2)

    stop_server_flag=1
    sleep(2)
    while(EM_server_thread.is_alive() or heater_chiller_thread.is_alive()):
        try:
            ServerStop()                       
        except Exception as e:
            print("Stop err: "+str(e)) 
        sleep(1)         
        # print("EM tread state: "+str(EM_server_thread.is_alive()))
        # print("heater_chiller tread state: "+str(heater_chiller_thread.is_alive()))

    try:
        EM_server_thread.join()
        # print("EM server joined")
    except Exception as e:
        print("EM server join err: "+str(e))
    try:
        heater_chiller_thread.join()
        # print("heater_chiller server joined")
    except Exception as e:
        print("heater_chiller server join err: "+str(e))
    stop_server_flag=0
    try:
        heater_chiller_thread = Thread(target=run_chiller_heater_server)
        heater_chiller_thread.start()
        # print("heater_chiller server started")
    except Exception as e:
        print("heater servewr strat err:" +str(e))
    
    try:
        EM_server_thread = Thread(target=run_EM_server)
        EM_server_thread.start()
        # print("EM server started")
    except Exception as e:
        print("EM server start err: "+str(e))
    
    sleep(20)

#endregion

#region chiller emulation functions



chiller_data={    
    "chiller_liquid_temp":10,
    "chiller_aft_temp":20,

    "chiller_room_temp_probe_fail":0,
    "chiller_aft_probe_fail":0,
    "chiller_room_temp_probe_ht_fault":0,
    "chiller_room_temp_probe_lt_fault":0,
    
    "chiller_pump_overload_fault":0,
    "chiller_spp_fault":0,
    "chiller_compressor_overload_fault":0,
    "chiller_hp_fault":0,
    "chiller_lp_fault":0,

    "chiller_low_liquid_level_fault":0,
    "chiller_liquid_line_high_temp_fault":0,    
    "chiller_high_temp_fault":0,
    "chiller_aft_fault":0,
    
    "chiller_compressor_on":0,
    "chiller_pump_on":0,
    "chiller_sv_on":0,
    "chiller_alarm_on":0,

    "chiller_set_high_set":40,
    "chiller_set_low_set":9,
    "chiller_set_set_point":10,
    "chiller_set_differential":2,
    "chiller_set_high_temp_alarm":50,
    "chiller_set_low_temp_alarm":8,
    "chiller_set_aft_set_temp":4,
    "chiller_set_aft_differential":2,
    "chiller_remote_start":1,

    }
chiller_fault_list=["chiller_liquid_line_probe_fail",
                    "chiller_aft_probe_fail",
                    "chiller_room_temp_probe_ht_fault",
                    "chiller_room_temp_probe_lt_fault",
                    "chiller_pump_overload_fault",
                    "chiller_compressor_overload_fault",
                    "chiller_hp_fault",
                    "chiller_lp_fault",                    
                    "chiller_low_liquid_level_fault",                    
                    "chiller_high_temp_fault",
                    "chiller_aft_fault"]
chiller_data_base={
    
    "chiller_liquid_temp":10,
    "chiller_aft_temp":20,

    "chiller_room_temp_probe_fail":0,
    "chiller_aft_probe_fail":0,
    "chiller_room_temp_probe_ht_fault":0,
    "chiller_room_temp_probe_lt_fault":0,
    
    "chiller_pump_overload_fault":0,
    "chiller_spp_fault":0,
    "chiller_compressor_overload_fault":0,
    "chiller_hp_fault":0,
    "chiller_lp_fault":0,

    "chiller_low_liquid_level_fault":0,
    "chiller_liquid_line_high_temp_fault":0,
    "chiller_high_temp_fault":0,
    "chiller_aft_fault":0,
    
    "chiller_compressor_on":0,
    "chiller_pump_on":0,
    "chiller_sv_on":0,
    "chiller_alarm_on":0,

    "chiller_set_high_set":40,
    "chiller_set_low_set":9,
    "chiller_set_set_point":10,
    "chiller_set_differential":2,
    "chiller_set_high_temp_alarm":50,
    "chiller_set_low_temp_alarm":8,
    "chiller_set_aft_set_temp":4,
    "chiller_set_aft_differential":2,
    "chiller_remote_start":1,

    }

def convert_bin_list_to_int(ls):
    # print("binary_signals: "+str(ls))
    bin_str=""
    for l in ls:
        bin_str=str(l)+bin_str
    return int(bin_str,2)


def update_chiller_registers():
    global chiller_data,holding_registers,change_chiller_flag,CMS_internal_can_dict
    
    while(1):
        try:
            reg4_data=int(chiller_data["chiller_liquid_temp"]*10)
            reg5_data=int(chiller_data["chiller_aft_temp"]*10)           

            reg10_data=convert_bin_list_to_int([chiller_data["chiller_room_temp_probe_fail"],
                                                chiller_data["chiller_aft_probe_fail"],
                                                chiller_data["chiller_room_temp_probe_ht_fault"],
                                                chiller_data["chiller_room_temp_probe_lt_fault"]])
            
            reg11_data=convert_bin_list_to_int([chiller_data["chiller_pump_overload_fault"],
                                                chiller_data["chiller_spp_fault"],
                                                chiller_data["chiller_compressor_overload_fault"],
                                                chiller_data["chiller_hp_fault"],
                                                chiller_data["chiller_lp_fault"]])
            
            reg12_data=convert_bin_list_to_int([chiller_data["chiller_low_liquid_level_fault"],
                                                chiller_data["chiller_liquid_line_high_temp_fault"],
                                                chiller_data["chiller_high_temp_fault"],
                                                chiller_data["chiller_aft_fault"]])
            
            reg13_data=convert_bin_list_to_int([chiller_data["chiller_compressor_on"],
                                                chiller_data["chiller_pump_on"],
                                                chiller_data["chiller_sv_on"],
                                                chiller_data["chiller_alarm_on"]])
            
            reg28_data=int(chiller_data["chiller_set_high_set"]*10) 
            reg29_data=int(chiller_data["chiller_set_low_set"]*10) 
            reg30_data=int(chiller_data["chiller_set_set_point"]*10) 
            reg34_data=int(chiller_data["chiller_set_differential"]*10) 
            reg35_data=int(chiller_data["chiller_set_high_temp_alarm"]*10) 
            reg36_data=int(chiller_data["chiller_set_low_temp_alarm"]*10) 
            reg38_data=int(chiller_data["chiller_set_aft_set_temp"]*10) 
            reg39_data=int(chiller_data["chiller_set_aft_differential"]*10) 
            reg51_data=int(chiller_data["chiller_remote_start"]) 

            holding_registers.setValues(4, reg4_data)
            holding_registers.setValues(5, reg5_data)            
            holding_registers.setValues(10, reg10_data)
            holding_registers.setValues(11, reg11_data)
            holding_registers.setValues(12, reg12_data)
            holding_registers.setValues(13, reg13_data)
            holding_registers.setValues(28, reg28_data)
            holding_registers.setValues(28, reg28_data)
            holding_registers.setValues(29, reg29_data)
            holding_registers.setValues(30, reg30_data)
            holding_registers.setValues(34, reg34_data)
            holding_registers.setValues(35, reg35_data)
            holding_registers.setValues(36, reg36_data)
            holding_registers.setValues(38, reg38_data)
            holding_registers.setValues(39, reg39_data)
            holding_registers.setValues(51, reg51_data)

            sleep(0.1)
        except Exception as e:
            print_with_log("Chiller register update err: "+str(e))

def add_chiller_setting_offset(sig_name):
    global CMS_internal_can_dict,chiller_data,chiller_data_base
    chiller_data[sig_name] = chiller_data_base[sig_name]+1

def reset_all_chiller_data():
    global CMS_internal_can_dict,chiller_data,chiller_data_base

    for k in chiller_data.keys():
        chiller_data[k]=chiller_data_base[k]



chiller_rb_thread = Thread(target=update_chiller_registers)
chiller_rb_thread.start()


#endregion

#region heater_emulation

heater_data={
    'heater_tank_temperature':25,

    'heater_relay_sts_compressor':1,
    'heater_relay_sts_alarm':1,

    'heater_fault_sts_probe_fail_low':0,
    'heater_fault_sts_probe_fail_high':0,
    'heater_fault_sts_ht':0,
    'heater_fault_sts_lt':0,
    'heater_fault_water_level_low':0,
    'heater_fault':0,

    'heater_run_hours':20,
    "heater_set_point":50,
    
    "heater_high_temp_limit":55,
    "heater_high_temp_alarm_diff":2,
    "heater_low_temp_limit":40,
    "heater_low_temp_alarm_diff":2,
    
    "heater_max_set_point_limit":52,
    "heater_min_set_point_limit":42,
    "heater_relay_on_differential":5,
    "heater_probe_calibration":0,    
    "heater_relay_min_on_time":0,
    "heater_fault_condition_when_probe_fail":0
    }


heater_base_data={
    'heater_tank_temperature':25,

    'heater_relay_sts_compressor':1,
    'heater_relay_sts_alarm':1,

    'heater_fault_sts_probe_fail_low':0,
    'heater_fault_sts_probe_fail_high':0,
    'heater_fault_sts_ht':0,
    'heater_fault_sts_lt':0,
    'heater_fault_water_level_low':0,
    'heater_fault':0,

    'heater_run_hours':20,
    "heater_set_point":50,
    "heater_high_temp_limit":55,
    "heater_high_temp_alarm_diff":2,
    "heater_low_temp_limit":40,
    "heater_low_temp_alarm_diff":2,
    
    "heater_max_set_point_limit":52,
    "heater_min_set_point_limit":42,
    "heater_relay_on_differential":5,
    "heater_probe_calibration":0,    
    "heater_relay_min_on_time":0,
    "heater_fault_condition_when_probe_fail":0
    }

heater_registers={    
    'heater_tank_temperature':6,
    'relay_status':11,
    'fault_status':12,

    'heater_run_hours':14,
    "heater_set_point":31,
    "heater_high_temp_limit":33,
    "heater_high_temp_alarm_diff":34,
    "heater_low_temp_limit":35,
    "heater_low_temp_alarm_diff":36,
    
    "heater_max_set_point_limit":37,
    "heater_min_set_point_limit":38,
    "heater_relay_on_differential":39,
    "heater_probe_calibration":40,    
    "heater_relay_min_on_time":42,
    "heater_fault_condition_when_probe_fail":43    
    }

relay_encoded_list=["heater_relay_sts_alarm","heater_relay_sts_compressor"]
fault_encoded_list=["heater_fault_sts_probe_fail_low","heater_fault_sts_probe_fail_high",
                        "heater_fault_sts_ht","heater_fault_sts_lt","heater_fault_water_level_low",
                        "heater_fault"]
def update_heater_registers():
    global heater_data,holding_registers_heater,change_heater_flag,CMS_internal_can_dict,heater_registers
    global fault_encoded_list,relay_encoded_list
    
    while(1):
        try:

            reg11_data=convert_bin_list_to_int([heater_data["heater_relay_sts_alarm"],
                                                heater_data["heater_relay_sts_compressor"]])
                                                
            
            reg12_data=convert_bin_list_to_int([heater_data["heater_fault_sts_probe_fail_low"],
                                                heater_data["heater_fault_sts_probe_fail_high"],
                                                heater_data["heater_fault_sts_ht"],
                                                heater_data["heater_fault_sts_lt"],
                                                heater_data["heater_fault_water_level_low"],
                                                heater_data["heater_fault"]])
            
            holding_registers_heater.setValues(heater_registers['relay_status'], reg11_data)
            holding_registers_heater.setValues(heater_registers['fault_status'], reg12_data)

            for k in heater_data.keys():
                if(k not in relay_encoded_list and k not in fault_encoded_list):
                    reg_data=int(heater_data[k]*10)
                    holding_registers_heater.setValues(heater_registers[k], reg_data)

            sleep(0.1)
        except Exception as e:
            print_with_log("Heater register update err: "+str(e))
 
heater_rb_thread = Thread(target=update_heater_registers)
heater_rb_thread.start()

#endregion


#region Energy meter_emulation
### byte 1 controls the data after decimal
### byte 2 controls that data before decimal point

EM_data_dict={
        'em_watts_total':0,
        'em_watts_r_phase':0,
        'em_watts_y_phase':0,
        'em_watts_b_phase':0,

        'em_power_factor_avg':0.8,
        'em_power_factor_r_phase':0.7,
        'em_power_factor_y_phase':0.5,
        'em_power_factor_b_phase':0.9,

        'em_apparent_power_total':0,
        'em_apparent_power_r_phase':0,
        'em_apparent_power_y_phase':0,
        'em_apparent_power_b_phase':0,

        'em_voltage_ll_avg':440,
        'em_voltage_ry_phase':440,
        'em_voltage_yb_phase':440,
        'em_voltage_br_phase':440,

        'em_voltage_ln_avg':220.6,
        'em_voltage_r_phase':250.5,
        'em_voltage_y_phase':210.4,
        'em_voltage_b_phase':234.8,

        'em_current_total':0,
        'em_current_r_phase':0,
        'em_current_y_phase':0,
        'em_current_b_phase':0,

        'em_frequency':0,
        'em_k_watt_hour':0,
        'em_voltage_ampere_hour':0,

}


EM_data_dict_base={
        'em_watts_total':0,
        'em_watts_r_phase':0,
        'em_watts_y_phase':0,
        'em_watts_b_phase':0,

        'em_power_factor_avg':0.8,
        'em_power_factor_r_phase':0.7,
        'em_power_factor_y_phase':0.5,
        'em_power_factor_b_phase':0.9,

        'em_apparent_power_total':0,
        'em_apparent_power_r_phase':0,
        'em_apparent_power_y_phase':0,
        'em_apparent_power_b_phase':0,

        'em_voltage_ll_avg':440,
        'em_voltage_ry_phase':440,
        'em_voltage_yb_phase':440,
        'em_voltage_br_phase':440,

        'em_voltage_ln_avg':220.6,
        'em_voltage_r_phase':250.5,
        'em_voltage_y_phase':210.4,
        'em_voltage_b_phase':234.8,

        'em_current_total':0,
        'em_current_r_phase':0,
        'em_current_y_phase':0,
        'em_current_b_phase':0,

        'em_frequency':0,
        'em_k_watt_hour':0,
        'em_voltage_ampere_hour':0,

}

EM_registers_dict={
            'em_watts_total_b1':101,
            'em_watts_r_phase_b1':103,
            'em_watts_y_phase_b1':105,
            'em_watts_b_phase_b1':107,

            'em_power_factor_avg_b1':117,
            'em_power_factor_r_phase_b1':119,
            'em_power_factor_y_phase_b1':121,
            'em_power_factor_b_phase_b1':123,

            'em_apparent_power_total_b1':125,
            'em_apparent_power_r_phase_b1':127,
            'em_apparent_power_y_phase_b1':129,
            'em_apparent_power_b_phase_b1':131,

            'em_voltage_ll_avg_b1':133,
            'em_voltage_ry_phase_b1':135,
            'em_voltage_yb_phase_b1':137,
            'em_voltage_br_phase_b1':139,

            'em_voltage_ln_avg_b1':141,
            'em_voltage_r_phase_b1':143,
            'em_voltage_y_phase_b1':145,
            'em_voltage_b_phase_b1':147,

            'em_current_total_b1':149,
            'em_current_r_phase_b1':151,
            'em_current_y_phase_b1':153,
            'em_current_b_phase_b1':155,

            'em_frequency_b1':157,
            'em_k_watt_hour_b1':159,
            'em_voltage_ampere_hour_b1':161,

            'em_watts_total_b2':102,
            'em_watts_r_phase_b2':104,
            'em_watts_y_phase_b2':106,
            'em_watts_b_phase_b2':108,

            'em_power_factor_avg_b2':118,
            'em_power_factor_r_phase_b2':120,
            'em_power_factor_y_phase_b2':122,
            'em_power_factor_b_phase_b2':124,

            'em_apparent_power_total_b2':126,
            'em_apparent_power_r_phase_b2':128,
            'em_apparent_power_y_phase_b2':130,
            'em_apparent_power_b_phase_b2':132,

            'em_voltage_ll_avg_b2':134,
            'em_voltage_ry_phase_b2':136,
            'em_voltage_yb_phase_b2':138,
            'em_voltage_br_phase_b2':140,

            'em_voltage_ln_avg_b2':142,
            'em_voltage_r_phase_b2':144,
            'em_voltage_y_phase_b2':146,
            'em_voltage_b_phase_b2':148,

            'em_current_total_b2':150,
            'em_current_r_phase_b2':152,
            'em_current_y_phase_b2':154,
            'em_current_b_phase_b2':156,

            'em_frequency_b2':158,
            'em_k_watt_hour_b2':160,
            'em_voltage_ampere_hour_b2':162        
        }


def float_to_bytes(value):
    # Pack float into 32-bit binary, then unpack as hex
    hex_val= hex(struct.unpack('<I', struct.pack('<f', value))[0])    
    while(len(hex_val)<10):
        hex_val=hex_val[:2]+"0"+hex_val[2:]
    
    # print(hex_val)
    byte2= int(hex_val[2:6], 16)
    byte1 = int(hex_val[6:10], 16)

    return byte1,byte2



def update_EM_registers_data():
    global EM_data_dict,EM_holding_registers,CMS_internal_can_dict,EM_registers_dict
    
    
    while(1):
        try:
            for k in EM_data_dict.keys():  
                if(k=="em_k_watt_hour"):
                    in_data=EM_data_dict[k]*1000
                else:
                    in_data=EM_data_dict[k]
                b1,b2=float_to_bytes(in_data)
                reg_name_1=str(k)+"_b1"
                reg_name_2=str(k)+"_b2"
                
                EM_holding_registers.setValues(EM_registers_dict[reg_name_1], b1)
                EM_holding_registers.setValues(EM_registers_dict[reg_name_2], b2)
            sleep(0.1)
        except Exception as e:
            print("EMregister update err: "+str(e))
 
EM_rb_thread = Thread(target=update_EM_registers_data)
EM_rb_thread.start()

#endregion

#region arduino emulation functions

try:
    ard_ser = serial.Serial('/dev/ttyACM0', 9600) # change name, if needed
    sleep(3)
except Exception as ex:
    print(ex)
    while(1):
        pass

try:
    ard_ser_press = serial.Serial('/dev/ttyUSB0', 9600) # change name, if needed
    sleep(3)
except Exception as ex:
    print(ex)
"""
arduino channals
CT : 1 to 16
set current : 17
set temp : 18,
curr rev :19
curr short : 20
relay A : 21 to 36,
relay B : 37 to 52

"""
temp_signal_map={
    "CON_P_TS1":1,
    "CON_P_TS2":2,
    "CON_P_TS3":3,
    "CON_P_TS4":4,
    "CON_AMB_TS5":5,
    "CON_AMB_TS6":6,
    "CON_AMB_TS7":7,
    "CON_AMB_TS8":8,
    "CON_AMB_TS9":9,
    "CON_MOTOR_TS10":10,
    "CON_CHILLER_AMB":11,
    "CON_GP2_TS12":12,
    "CON_WATER_INLET":13,
    "CON_WATER_OUTLET":14,
    "CON_DC_TS_N":15,
    "CON_DC_TS_P":16,
}
temp_can_signal_map={
    "CON_P_TS1":"gun_temp_p_1",
    "CON_P_TS2":"gun_temp_p_2",
    "CON_P_TS3":"gun_temp_n_1",
    "CON_P_TS4":"gun_temp_n_2",
    "CON_AMB_TS5":"pcb_onboard_temp",
    "CON_AMB_TS6":"condenser_inlet_temp",
    "CON_AMB_TS7":"condenser_outlet_temp",
    "CON_AMB_TS8":"hot_tank_temp",
    "CON_AMB_TS9":"air_compressor_temp",
    "CON_MOTOR_TS10":"motor_coolant_temp",
    "CON_CHILLER_AMB":"ambient_chiller_1",
    "CON_GP2_TS12":"refreg_air_inlet_temp",
    "CON_WATER_INLET":"water_inlet_temperature",
    "CON_WATER_OUTLET":"water_outlet_temperature",
    "CON_DC_TS_N":"dc_busbar_temp_positve",
    "CON_DC_TS_P":"dc_current_sensor_body_temp",
}
relay_A_map={
    "SW_GP1":27,
    "SW_GP2":22,
    "Hot tank level out":23,
    "Cold tank level out":24,
    "Stop charging out":25,
    "Air comp pre sensor out":26,
    "gun_limit_switch":21,
    "Smoke sensor out":28,
    "VALVE_FB_1":29,
    "VALVE_FB_2":30,
    "VALVE_FB_3":31,
    "VALVE_FB_4":32,
    "VALVE_FB_5":33,
    "VALVE_FB_6":34,
    "MCU_Digital_SW1":35,
    "u_lock_out":36
}

relay_B_map={
    "MCU_SPD_CB":37,
    "MCU_ELR_CB":38,
    "MCU_PFR_CB":39,
    "Heater_contactor_fb_relay":40,
    "MCU_GP1_AC_SENSE_CB":41,
    "MCU_FAN_CON_230V_CB":42,
    "MCU_COOLENT_CON_FB_CB":43,
    "MCU_EM_SW_CB":44,
    "polarity_1":45,
    "polarity_2":46,
    "CP_1":47,
    "CP_2":48,
    "48v_power":49,
    "master_swt":50,
    "R_B_15":51,
    "R_B_16":52,

    

}
base_relay_states={
    "CON_P_TS1":0,
    "CON_P_TS2":0,
    "CON_P_TS3":0,
    "CON_P_TS4":0,
    "CON_AMB_TS5":0,
    "CON_AMB_TS6":0,
    "CON_AMB_TS7":0,
    "CON_AMB_TS8":0,
    "CON_AMB_TS9":0,
    "CON_MOTOR_TS10":0,
    "CON_CHILLER_AMB":0,
    "CON_GP2_TS12":0,
    "CON_WATER_INLET":0,
    "CON_WATER_OUTLET":0,
    "CON_DC_TS_N":0,
    "CON_DC_TS_P":0,

    "SW_GP1":0,
    "SW_GP2":0,
    "Hot tank level out":0,
    "Cold tank level out":0,
    "Stop charging out":0,
    "Air comp pre sensor out":0,
    "gun_limit_switch":0,
    "Smoke sensor out":0,
    "VALVE_FB_1":0,
    "VALVE_FB_2":0,
    "VALVE_FB_3":0,
    "VALVE_FB_4":0,
    "VALVE_FB_5":0,
    "VALVE_FB_6":0,
    "MCU_Digital_SW1":1,
    "u_lock_out":1,

    "MCU_SPD_CB":1,
    "MCU_ELR_CB":1,
    "MCU_PFR_CB":1,
    "Heater_contactor_fb_relay":1,
    "MCU_GP1_AC_SENSE_CB":1,
    "MCU_FAN_CON_230V_CB":1,
    "MCU_COOLENT_CON_FB_CB":1,
    "MCU_EM_SW_CB":1,

    "polarity_1":0,
    "polarity_2":0,
    "CP_1":0,
    "CP_2":0,
    "48v_power":0,
    "master_swt":0,
    "R_B_15":0,
    "R_B_16":0,

}

all_relay_states={
    "CON_P_TS1":0,
    "CON_P_TS2":0,
    "CON_P_TS3":0,
    "CON_P_TS4":0,
    "CON_AMB_TS5":0,
    "CON_AMB_TS6":0,
    "CON_AMB_TS7":0,
    "CON_AMB_TS8":0,
    "CON_AMB_TS9":0,
    "CON_MOTOR_TS10":0,
    "CON_CHILLER_AMB":0,
    "CON_GP2_TS12":0,
    "CON_WATER_INLET":0,
    "CON_WATER_OUTLET":0,
    "CON_DC_TS_N":0,
    "CON_DC_TS_P":0,

    "SW_GP1":0,
    "SW_GP2":0,
    "Hot tank level out":0,
    "Cold tank level out":0,
    "Stop charging out":0,
    "Air comp pre sensor out":0,
    "gun_limit_switch":0,
    "Smoke sensor out":0,
    "VALVE_FB_1":0,
    "VALVE_FB_2":0,
    "VALVE_FB_3":0,
    "VALVE_FB_4":0,
    "VALVE_FB_5":0,
    "VALVE_FB_6":0,
    "MCU_Digital_SW1":1,
    "u_lock_out":1,

    "MCU_SPD_CB":1,
    "MCU_ELR_CB":1,
    "MCU_PFR_CB":1,
    "Heater_contactor_fb_relay":1,
    "MCU_GP1_AC_SENSE_CB":1,
    "MCU_FAN_CON_230V_CB":1,
    "MCU_COOLENT_CON_FB_CB":1,
    "MCU_EM_SW_CB":1,

    "polarity_1":0,
    "polarity_2":0,
    "CP_1":0,
    "CP_2":0,
    "48v_power":0,
    "master_swt":0,
    "R_B_15":0,
    "R_B_16":0,

}

last_relay_states={
    "CON_P_TS1":-1,
    "CON_P_TS2":-1,
    "CON_P_TS3":-1,
    "CON_P_TS4":-1,
    "CON_AMB_TS5":-1,
    "CON_AMB_TS6":-1,
    "CON_AMB_TS7":-1,
    "CON_AMB_TS8":-1,
    "CON_AMB_TS9":-1,
    "CON_MOTOR_TS10":-1,
    "CON_CHILLER_AMB":-1,
    "CON_GP2_TS12":-1,
    "CON_WATER_INLET":-1,
    "CON_WATER_OUTLET":-1,
    "CON_DC_TS_N":-1,
    "CON_DC_TS_P":-1,

    "SW_GP1":-1,
    "SW_GP2":-1,
    "Hot tank level out":-1,
    "Cold tank level out":-1,
    "Stop charging out":-1,
    "Air comp pre sensor out":-1,
    "gun_limit_switch":-1,
    "Smoke sensor out":-1,
    "VALVE_FB_1":-1,
    "VALVE_FB_2":-1,
    "VALVE_FB_3":-1,
    "VALVE_FB_4":-1,
    "VALVE_FB_5":-1,
    "VALVE_FB_6":-1,
    "MCU_Digital_SW1":-1,
    "u_lock_out":-1,

    "MCU_SPD_CB":-1,
    "MCU_ELR_CB":-1,
    "MCU_PFR_CB":-1,
    "Heater_contactor_fb_relay":-1,
    "MCU_GP1_AC_SENSE_CB":-1,
    "MCU_FAN_CON_230V_CB":-1,
    "MCU_COOLENT_CON_FB_CB":-1,
    "MCU_EM_SW_CB":-1,

    "polarity_1":-1,
    "polarity_2":-1,
    "CP_1":-1,
    "CP_2":-1,
    "48v_power":-1,
    "master_swt":-1,
    "R_B_15":-1,
    "R_B_16":-1,

}
relay_CAN_map={
    "SW_GP1":["sw_gp_1"],
    "SW_GP2":["sw_gp_2"],
    "Hot tank level out":["hot_tank"],
    "Cold tank level out":["cold_tank"],
    "Stop charging out":["stop_charging"],
    "Air comp pre sensor out":["comp_pre"],
    "gun_limit_switch":["limit_switch"],
    "Smoke sensor out":["smoke_detect"],
    "VALVE_FB_1":["valve_fb_1_a","valve_fb_1_b"],
    "VALVE_FB_2":["valve_fb_2_a","valve_fb_2_b"],
    "VALVE_FB_3":["valve_fb_3_a","valve_fb_3_b"],
    "VALVE_FB_4":["valve_fb_4_a","valve_fb_4_b"],
    "VALVE_FB_5":["valve_fb_5_a","valve_fb_5_b"],
    "VALVE_FB_6":["valve_fb_6_a","valve_fb_6_b"],
    "MCU_Digital_SW1":["sol_fb"],
    "u_lock_out":["cx_ulock_status"],

    "MCU_SPD_CB":["spd"],
    "MCU_ELR_CB":["elr"],
    "MCU_PFR_CB":["pfr"],
    "Heater_contactor_fb_relay":["heater_contactor_fb"],
    "MCU_GP1_AC_SENSE_CB":["sw_gp_1"],
    "MCU_FAN_CON_230V_CB":["fan_con_230_v"],
    "MCU_COOLENT_CON_FB_CB":["coolent_con_fb"],
    "MCU_EM_SW_CB":["em_sw"],

}

def master_swt_on():
    global all_relay_states,CMS_internal_can_dict
    update_cp_state(6)
    all_relay_states["master_swt"]=1    
    CMS_internal_can_dict["code_1"]=-1
    str_out= str(50)+","+str(1)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    st_time=timer()
    while(CMS_internal_can_dict["code_1"]==-1):
        sleep(1)
        print_with_log("waiting for CAN msg")
        if(timer()-st_time>3):
            os.system('sudo ip link set can0 down')
            sleep(0.5)
            os.system('sudo ip link set can0 up')
            sleep(0.5)
            st_time=timer()


    print_with_log("Got CAN data")
    sleep(3)

def master_swt_off():
    global all_relay_states
    all_relay_states["master_swt"]=0
    str_out= str(50)+","+str(0)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    sleep(3)

def temp_to_adc(val,ref_res=10000):
    cms_voltage_ref=3.3
    temp_k=val+273.15
    res=(ref_res)/math.exp(3435*((temp_k-298.15)/(298.15*temp_k)))
    v=(res*cms_voltage_ref)/(res +ref_res)
    dac_val=int(v*4096/5)
    if(dac_val<0):
        dac_val=0
    if(dac_val>4095):
        dac_val=4095

    return dac_val

def curr_to_dac(val):
    global calib_state
    ## not needed because of current sensor reversal
    if(calib_state ==1):
        val=val*(-1)
        offset_val=val+600
        voltage=0.5+(offset_val*4.0/1200.0)
        # print_with_log("Setting voltage to: "+str(voltage))
        dac_val=int(voltage*4096/5)
        return dac_val
    else:
        offset_val=val+600
        voltage=0.5+(offset_val*4.0/1200.0)
        # print_with_log("Setting voltage to: "+str(voltage))
        dac_val=int(voltage*4096/5)
        return dac_val


def pressure_to_dac(val):
    voltage=0.5+((val/10.0)*4.0)
    dac_val=int(voltage*4095/5)
    print_with_log("Setting voltage to: "+str(voltage))
    return dac_val

def set_temp(val,ref_res=10000):
    print_with_log("Setting temp to : "+str(val))
    dac_val=temp_to_adc(val,ref_res)
    str_out= str(18)+","+str(dac_val)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    sleep(0.02)

def set_temp_sense_open():
    dac_val=int(3.3*4096/5.0)
    str_out= str(18)+","+str(dac_val)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    sleep(0.02)

def set_curr(val):
    # print_with_log("Setting sensor curr to : "+str(val))
    
    dac_val=curr_to_dac(val)
    str_out= str(17)+","+str(dac_val)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    sleep(0.02)

def set_zero_curr_ADC():
    str_out= str(17)+","+str(0)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    sleep(1)
    str_out= str(20)+","+str(1)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    sleep(1)

def reset_zero_curr_ADC():    
    str_out= str(19)+","+str(0)+"."
    ard_ser.write(bytes(str_out,'utf-8'))
    sleep(1)
    set_curr(0)

def update_relay_states():
    global all_relay_states,last_relay_states
    while(1):
        try:
            for k in all_relay_states.keys():
                if(all_relay_states[k]!=last_relay_states[k]):
                    # print_with_log("Changing state of relay: "+str(k)+" to : "+str(all_relay_states[k]))
                    signal_id=-1
                    if(k in list(temp_signal_map.keys())):
                        signal_id=temp_signal_map[k]
                    elif(k in list(relay_A_map.keys())):
                        signal_id=relay_A_map[k]
                    elif(k in list(relay_B_map.keys())):
                        signal_id=relay_B_map[k]       

                    str_out= str(signal_id)+","+str(all_relay_states[k])+"."
                    ard_ser.write(bytes(str_out,'utf-8'))
                    
                    last_relay_states[k]=all_relay_states[k]
            
            sleep(0.1)
        except:
            pass

def activate_gun_temp_ib(num1,num2,ib_val):
    global all_relay_states
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]
    gun_relay_name1=gun_relay_names_list[num1-1]
    gun_relay_name2=gun_relay_names_list[num2-1]
    if((num1 in [1,2] and num2 in [1,2]) or (num1 in [3,4] and num2 in [3,4])): 
        set_temp(25)
        all_relay_states[gun_relay_name1]=0
        all_relay_states[gun_relay_name2]=1        
        set_temp(25+ib_val)
    else:        
        set_temp(25)
        all_relay_states[gun_relay_names_list[0]]=0
        all_relay_states[gun_relay_names_list[1]]=0       
        all_relay_states[gun_relay_names_list[2]]=1  
        all_relay_states[gun_relay_names_list[3]]=1      
        set_temp(25+ib_val)

def update_gun_limit_state(s):
    global all_relay_states,CMS_version
    if(CMS_version==4.2):
        all_relay_states["gun_limit_switch"] = s

def update_ulock_status(s):
    global all_relay_states,CMS_version
    if(CMS_version==4.2):
        all_relay_states["u_lock_out"] = s

    if(CMS_version==4.0 and s==1):
        st_time=timer()
        while(ota_can_dict["gun_lock_request"]!=1):
            print_with_log("waiting for gun lock request from station")
            sleep(1)
            if(timer()-st_time>3000):
                print_with_log("timeout. No charge. test Fail")
                return
        print_with_log("Emulating battery solenoid lock")
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_req"]=1
        BMS_sent_CAN_msg["Stateflow_Status"]["Battery_State"]=1    
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_status"]=1
        BMS_sent_CAN_msg["Stateflow_Status"]["Motor_Enable_Out"]=1
        BMS_sent_CAN_msg["Stateflow_Status"]["Proximity_Pilot_In"]=1    
        BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Path_Status"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_status"]=0        
        sleep(0.5)

def emulate_gun_lock_in_air():
    global CMS_version
    if(CMS_version==4.2):
        update_cp_state(6)
        update_ulock_status(1)

def emulate_partial_gun_unlock():
    global CMS_version
    if(CMS_version==4.2):
        update_ulock_status(0)

def emulate_full_gun_unlock():
    global CMS_version
    if(CMS_version==4.2):
        update_gun_limit_state(1)
        update_ulock_status(0)
        sleep(0.3)
        update_gun_limit_state(0)







cp_state=0
def update_cp_state(new_state):
    global cp_state
    if(new_state==12):  #short
        all_relay_states["CP_1"]=1
        all_relay_states["CP_2"]=0

    elif(new_state==6):  #1k
        all_relay_states["CP_1"]=0
        all_relay_states["CP_2"]=1
    elif(new_state==4):  #0.5k
        all_relay_states["CP_1"]=1
        all_relay_states["CP_2"]=1
        emulate_plug_connection()
    elif(new_state==0):  #open
        all_relay_states["CP_1"]=0
        all_relay_states["CP_2"]=0
    print_with_log("Changing CP state to: "+str(new_state))
    cp_state=new_state
    

battrty_polarity_state=0
battrty_polarity_state_old=-1

def update_battery_polarity():
    global battrty_polarity_state,battrty_polarity_state_old
    while(1):
        # print(battrty_polarity_state)
        try:
            if(battrty_polarity_state!=battrty_polarity_state_old):

                new_state=battrty_polarity_state
                print_with_log("chnaging polarity to: "+str(new_state))

                if(new_state==2 and battrty_polarity_state_old==1):  #negative 48
                    all_relay_states["48v_power"]=0
                    sleep(0.2)
                    all_relay_states["polarity_1"]=1
                    all_relay_states["polarity_2"]=1
                    sleep(0.2)
                    all_relay_states["48v_power"]=1
                    sleep(0.2)
                if(new_state==2 and battrty_polarity_state_old==0):  #negative 48                
                    all_relay_states["polarity_1"]=1
                    all_relay_states["polarity_2"]=1
                    sleep(0.2)
                    all_relay_states["48v_power"]=1
                    
                if(new_state==1 and battrty_polarity_state_old==2):  #positive 48 
                    all_relay_states["48v_power"]=0
                    sleep(0.5)
                    all_relay_states["polarity_1"]=0
                    all_relay_states["polarity_2"]=0
                    sleep(0.5)
                    all_relay_states["48v_power"]=1 
                    sleep(0.5)
                if(new_state==1 and battrty_polarity_state_old==0):
                    all_relay_states["48v_power"]=1
                if(new_state==0 and battrty_polarity_state_old==1):  #no power
                    all_relay_states["48v_power"]=0

                if(new_state==0 and battrty_polarity_state_old==2):  #no power
                    all_relay_states["48v_power"]=0   
                    sleep(0.5)
                    all_relay_states["polarity_1"]=0
                    all_relay_states["polarity_2"]=0
                        
                battrty_polarity_state_old=new_state
            sleep(0.1)
        except:
            pass

polarity_thread = Thread(target=update_battery_polarity)
polarity_thread.start()  

def set_pressure1(val):
    print_with_log("Setting pressure 1 to : "+str(val))
    dac_val=pressure_to_dac(val)
    str_out= str(1)+","+str(dac_val)+"."
    ard_ser_press.write(bytes(str_out,'utf-8'))
    sleep(0.02)

def set_pressure2(val):
    print_with_log("Setting pressure 2 to : "+str(val))
    dac_val=pressure_to_dac(val)
    str_out= str(2)+","+str(dac_val)+"."
    ard_ser_press.write(bytes(str_out,'utf-8'))
    sleep(0.02)

def emulate_all_gun_temp(val):
    global all_relay_states,CMS_internal_can_dict
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]
    can_msg_names=["gun_temp_n_2","gun_temp_n_1","gun_temp_p_2","gun_temp_p_1"]
    set_temp(val)
    sleep(0.5)
    for r in gun_relay_names_list:
        all_relay_states[r]=1    
    sleep(1)
    can_temp_data=[]
    for c in can_msg_names:
        can_temp_data.append(CMS_internal_can_dict[c])
    print_with_log("Set temp: "+str(val)+" CAN data: "+str(can_temp_data))
    
    



def all_ard_state_reset():
    print_with_log("doing all arduino reset")
    global all_relay_states
    global chiller_data,heater_data,chiller_data_base,heater_base_data
    for k in all_relay_states.keys():
        all_relay_states[k]=base_relay_states[k]
    
    for k in chiller_data:
        chiller_data[k]=chiller_data_base[k]
    
    for k in heater_data:
        heater_data[k]=heater_base_data[k]
    
    set_temp(25)
    set_curr(0)
    set_pressure1(0)
    set_pressure2(0)
    update_ulock_status(s=0)
    update_gun_limit_state(s=0)
    reset_BMS_data()
    print_with_log("arduino reset complete")

relay_thread = Thread(target=update_relay_states)
relay_thread.start()
    


#endregion

#region GPIO control functions
correct_relay_state_flag=1

correct_polarity_response=1
precharge_fail_flag=0
precharge_fail_flag_2=0

dc_contactor_open_flag=0
dc_contactor_forward_weld_flag=0
dc_contactor_rev_weld_flag=0

BMS_contactor_weld_forward=0
BMS_contactor_weld_rev=0
BMS_contactor_open_flag=0
polarity_rev_flag=0
dc_contactor_rev_polarity_flag=0

mbv_open_fault_flag=0
mbv_close_fault_flag=0
tec_flag=1



def emulate_digital_inputs():
    global all_relay_states,CMS_internal_can_dict,correct_relay_state_flag,battrty_polarity_state,precharge_fail_flag,correct_polarity_response
    global precharge_fail_flag,dc_contactor_open_flag,dc_contactor_forward_weld_flag,dc_contactor_rev_weld_flag
    global BMS_contactor_weld_forward,BMS_contactor_weld_rev,BMS_contactor_open_flag,dc_contactor_forward_weld_flag,dc_contactor_rev_weld_flag
    global mbv_open_fault_flag,mbv_close_fault_flag,polarity_rev_flag,BMS_sent_CAN_msg,precharge_fail_flag_2,dc_contactor_rev_polarity_flag

    while(1):
        try:
            if(correct_relay_state_flag==1):
                ### all ok
                if(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                    act_voltage_out_flag=0
                    if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                        # print_with_log("Making polarity 1 due to dc contactor/precharge")
                        act_voltage_out_flag=1
                    elif((BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1)):                    
                        act_voltage_out_flag=1
                    battrty_polarity_state=act_voltage_out_flag

                # #### precharge fail
                # elif(precharge_fail_flag==1 and dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                #    and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                #    and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                #     if(CMS_internal_can_dict["precharge_rel"]==1 and CMS_internal_can_dict["dc_contactor"]==0 and ota_can_dict["CC_On_Req"]==0):
                #         battrty_polarity_state=0
                #     else:
                #         act_voltage_out_flag=0
                #         if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1 or (ota_can_dict["CC_On_Req"]==1 and bms_send_flag==1)):
                #             act_voltage_out_flag=1
                #         battrty_polarity_state=act_voltage_out_flag

                ### DC contactor open
                elif(dc_contactor_open_flag==1 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                    if(CMS_internal_can_dict["precharge_rel"]==0 and CMS_internal_can_dict["dc_contactor"]==1 and ota_can_dict["CC_On_Req"]==0):
                        battrty_polarity_state=0
                    else:
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1
                        elif(BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1): 
                            act_voltage_out_flag=1
                        battrty_polarity_state=act_voltage_out_flag
                    
                ### DC contactor polarity reverse
                elif(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==1):
                    
                    if(CMS_internal_can_dict["precharge_rel"]==0 and CMS_internal_can_dict["dc_contactor"]==1 and ota_can_dict["CC_On_Req"]==0):
                        battrty_polarity_state=2
                    else:
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1
                        elif(BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1): 
                            act_voltage_out_flag=1
                        battrty_polarity_state=act_voltage_out_flag
                
                ### DC contactor forward weld
                elif(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==1
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                    if(rectifier_readback_values["voltage"]>40):
                        battrty_polarity_state=1
                    else:
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1
                        elif((BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1)):                        
                            act_voltage_out_flag=1
                        battrty_polarity_state=act_voltage_out_flag

                ### DC contactor forward weld reverse
                elif(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==1 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                    if(rectifier_readback_values["voltage"]>40):
                        battrty_polarity_state=2
                    else:
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1
                        elif((BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1)):
                            
                            act_voltage_out_flag=1
                        battrty_polarity_state=act_voltage_out_flag

                ### BMS contactor open
                elif(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==1 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                    if(CMS_internal_can_dict["precharge_rel"]==0 and CMS_internal_can_dict["dc_contactor"]==0 and BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1):
                        battrty_polarity_state=0
                    else:
                        
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1 
                        # print("not in contactor open. battery contactor: "+str(act_voltage_out_flag))                      
                        battrty_polarity_state=act_voltage_out_flag

                ### BMS contactor weld forward
                elif(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==1 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                    if(bms_send_flag==1):
                        battrty_polarity_state=1
                    else:
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1
                        elif((BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1)):
                            
                            act_voltage_out_flag=1
                        battrty_polarity_state=act_voltage_out_flag

                ### BMS contactor weld reverse
                elif(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==1
                and BMS_contactor_open_flag==0 and polarity_rev_flag==0 and dc_contactor_rev_polarity_flag==0):
                    
                    if(bms_send_flag==1):
                        battrty_polarity_state=2
                    else:
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1
                        elif((BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1)):
                            
                            act_voltage_out_flag=1
                        battrty_polarity_state=act_voltage_out_flag
                
                ### BMS  reverse voltage
                elif(dc_contactor_open_flag==0 and dc_contactor_forward_weld_flag==0
                and dc_contactor_rev_weld_flag==0 and BMS_contactor_weld_forward==0 and BMS_contactor_weld_rev==0
                and BMS_contactor_open_flag==0 and polarity_rev_flag==1 and dc_contactor_rev_polarity_flag==0):
                    
                    if(CMS_internal_can_dict["dc_contactor"]==0 and CMS_internal_can_dict["precharge_rel"]==0 and (BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1)):
                        
                        battrty_polarity_state=2
                    else:
                        act_voltage_out_flag=0
                        if(CMS_internal_can_dict["dc_contactor"]==1 or CMS_internal_can_dict["precharge_rel"]==1):
                            act_voltage_out_flag=1
                        elif((BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]==1 and bms_send_flag==1)):                        
                            act_voltage_out_flag=1
                        battrty_polarity_state=act_voltage_out_flag

                if(CMS_internal_can_dict["s_valve_1"]):   

                    if(mbv_close_fault_flag==0):
                        if(all_relay_states["VALVE_FB_1"]==0):
                            all_relay_states["VALVE_FB_1"]=1
                            # print_with_log("making MBV1 to 1")
                    else:
                        if(all_relay_states["VALVE_FB_1"]==1):
                            all_relay_states["VALVE_FB_1"]=0
                            # print_with_log("making MBV1 to 0")

                else:
                    if(mbv_open_fault_flag==0):
                        if(all_relay_states["VALVE_FB_1"]==1):
                            all_relay_states["VALVE_FB_1"]=0
                            # print_with_log("making MBV1 to 0")
                    else:
                        if(all_relay_states["VALVE_FB_1"]==0):
                            all_relay_states["VALVE_FB_1"]=1
                            # print_with_log("making MBV1 to 1")

                if(CMS_internal_can_dict["s_valve_2"]):                
                    if(mbv_close_fault_flag==0):
                        if(all_relay_states["VALVE_FB_2"]==0):
                            all_relay_states["VALVE_FB_2"]=1
                            # print_with_log("making MBV2 to 1")
                    else:
                        if(all_relay_states["VALVE_FB_2"]==1):
                            all_relay_states["VALVE_FB_2"]=0
                            # print_with_log("making MBV2 to 0")

                else:
                    if(mbv_open_fault_flag==0):
                        if(all_relay_states["VALVE_FB_2"]==1):
                            all_relay_states["VALVE_FB_2"]=0
                            # print_with_log("making MBV2 to 0")
                    else:
                        if(all_relay_states["VALVE_FB_2"]==0):
                            all_relay_states["VALVE_FB_2"]=1
                            # print_with_log("making MBV2 to 1")

                if(CMS_internal_can_dict["s_valve_3"]):                
                    if(mbv_close_fault_flag==0):
                        if(all_relay_states["VALVE_FB_3"]==0):
                            all_relay_states["VALVE_FB_3"]=1
                            # print_with_log("making MBV3 to 1")
                    else:
                        if(all_relay_states["VALVE_FB_3"]==1):
                            all_relay_states["VALVE_FB_3"]=0
                            # print_with_log("making MBV3 to 0")

                else:
                    if(mbv_open_fault_flag==0):
                        if(all_relay_states["VALVE_FB_3"]==1):
                            all_relay_states["VALVE_FB_3"]=0
                            # print_with_log("making MBV3 to 0")
                    else:
                        if(all_relay_states["VALVE_FB_3"]==0):
                            all_relay_states["VALVE_FB_3"]=1
                            # print_with_log("making MBV3 to 1")

                if(CMS_internal_can_dict["s_valve_4"]):                
                    if(mbv_close_fault_flag==0):
                        if(all_relay_states["VALVE_FB_4"]==0):
                            all_relay_states["VALVE_FB_4"]=1
                            # print_with_log("making MBV4 to 1")
                    else:
                        if(all_relay_states["VALVE_FB_4"]==1):
                            all_relay_states["VALVE_FB_4"]=0
                            # print_with_log("making MBV4 to 0")

                else:
                    if(mbv_open_fault_flag==0):
                        if(all_relay_states["VALVE_FB_4"]==1):
                            all_relay_states["VALVE_FB_4"]=0
                            # print_with_log("making MBV4 to 0")
                    else:
                        if(all_relay_states["VALVE_FB_4"]==0):
                            all_relay_states["VALVE_FB_4"]=1
                            # print_with_log("making MBV4 to 1")

                if(CMS_internal_can_dict["s_valve_5"]):                
                    if(mbv_close_fault_flag==0):
                        if(all_relay_states["VALVE_FB_5"]==0):
                            all_relay_states["VALVE_FB_5"]=1
                            # print_with_log("making MBV5 to 1")
                    else:
                        if(all_relay_states["VALVE_FB_5"]==1):
                            all_relay_states["VALVE_FB_5"]=0
                            # print_with_log("making MBV5 to 0")

                else:
                    if(mbv_open_fault_flag==0):
                        if(all_relay_states["VALVE_FB_5"]==1):
                            all_relay_states["VALVE_FB_5"]=0
                            # print_with_log("making MBV5 to 0")
                    else:
                        if(all_relay_states["VALVE_FB_5"]==0):
                            all_relay_states["VALVE_FB_5"]=1
                            # print_with_log("making MBV5 to 1")

                if(CMS_internal_can_dict["s_valve_6"]):                
                    if(mbv_close_fault_flag==0):
                        if(all_relay_states["VALVE_FB_6"]==0):
                            all_relay_states["VALVE_FB_6"]=1
                            # print_with_log("making MBV6 to 1")
                    else:
                        if(all_relay_states["VALVE_FB_6"]==1):
                            all_relay_states["VALVE_FB_6"]=0
                            # print_with_log("making MBV6 to 0")

                else:
                    if(mbv_open_fault_flag==0):
                        if(all_relay_states["VALVE_FB_6"]==1):
                            all_relay_states["VALVE_FB_6"]=0
                            # print_with_log("making MBV6 to 0")
                    else:
                        if(all_relay_states["VALVE_FB_6"]==0):
                            all_relay_states["VALVE_FB_6"]=1
                            # print_with_log("making MBV6 to 1")
                
                if(mbv_open_fault_flag==0 and mbv_close_fault_flag==0):
                    if(CMS_internal_can_dict["s_valve_1"]!=CMS_internal_can_dict["valve_fb_1_a"]):
                        # print_with_log("wrong fb mbv1")
                        last_relay_states["VALVE_FB_1"]=-1
                        all_relay_states["VALVE_FB_1"]=CMS_internal_can_dict["s_valve_1"]
                        # print_with_log("COrrecting mbv1 to: "+str(CMS_internal_can_dict["s_valve_1"]))
                    
                    if(CMS_internal_can_dict["s_valve_2"]!=CMS_internal_can_dict["valve_fb_2_a"]):
                        # print_with_log("wrong fb mbv2")
                        last_relay_states["VALVE_FB_2"]=-1
                        all_relay_states["VALVE_FB_2"]=CMS_internal_can_dict["s_valve_2"]
                        # print_with_log("COrrecting mbv2 to: "+str(CMS_internal_can_dict["s_valve_2"]))
                    
                    if(CMS_internal_can_dict["s_valve_3"]!=CMS_internal_can_dict["valve_fb_3_a"]):
                        # print_with_log("wrong fb mbv3")
                        last_relay_states["VALVE_FB_3"]=-1
                        all_relay_states["VALVE_FB_3"]=CMS_internal_can_dict["s_valve_3"]
                        # print_with_log("COrrecting mbv3 to: "+str(CMS_internal_can_dict["s_valve_3"]))
                    
                    if(CMS_internal_can_dict["s_valve_4"]!=CMS_internal_can_dict["valve_fb_4_a"]):
                        # print_with_log("wrong fb mbv4")
                        last_relay_states["VALVE_FB_4"]=-1
                        all_relay_states["VALVE_FB_4"]=CMS_internal_can_dict["s_valve_4"]
                        # print_with_log("COrrecting mbv4 to: "+str(CMS_internal_can_dict["s_valve_4"]))

                    if(CMS_internal_can_dict["s_valve_5"]!=CMS_internal_can_dict["valve_fb_5_a"]):
                        # print_with_log("wrong fb mbv5")
                        last_relay_states["VALVE_FB_5"]=-1
                        all_relay_states["VALVE_FB_5"]=CMS_internal_can_dict["s_valve_5"]
                        # print_with_log("COrrecting mbv5 to: "+str(CMS_internal_can_dict["s_valve_5"]))

                    if(CMS_internal_can_dict["s_valve_6"]!=CMS_internal_can_dict["valve_fb_6_a"]):
                        # print_with_log("wrong fb mbv6")
                        last_relay_states["VALVE_FB_6"]=-1
                        all_relay_states["VALVE_FB_6"]=CMS_internal_can_dict["s_valve_6"]
                        # print_with_log("COrrecting mbv6 to: "+str(CMS_internal_can_dict["s_valve_6"]))


                
                
                all_relay_states["SW_GP1"]=CMS_internal_can_dict["relay_gp_1"]
                all_relay_states["SW_GP2"]=CMS_internal_can_dict["relay_gp_2"]

                if(CMS_internal_can_dict["fan"]):
                    all_relay_states["MCU_FAN_CON_230V_CB"]=0
                else:
                    all_relay_states["MCU_FAN_CON_230V_CB"]=1

                if(CMS_internal_can_dict["coolent_motor"]):
                    all_relay_states["MCU_COOLENT_CON_FB_CB"]=0
                else:
                    all_relay_states["MCU_COOLENT_CON_FB_CB"]=1
                    
                
                CMS_internal_can_dict["air_comp"]=all_relay_states["Air comp pre sensor out"]
                ####emulate BMS CAN closing request with BMS message and polarity detection
                if(ota_can_dict["CC_On_Req"]==1):
                    sleep(2)
                    emulate_cc_close()                
                else:
                    emulate_cc_open()
            sleep(0.1)     
        except:
            pass       
                
gpio_thread = Thread(target=emulate_digital_inputs)
gpio_thread.start()                



correct_current_flag=0
correct_rectifier_flag=1
correct_curr_sensor_flag=1

def emulate_current_flow():
    global rectifier_readback_values,rectifier_control_request,battrty_polarity_state,correct_rectifier_flag
    global correct_curr_sensor_flag,precharge_fail_flag,precharge_fail_flag_2,deactivate_rectifiers_num
    while(1):
        try:
            if(correct_current_flag==1):
                if(battrty_polarity_state==1):
                    if(correct_rectifier_flag==1):
                        # rectifier_readback_values["voltage"]=rectifier_control_request["voltage"]
                        rectifier_readback_values["current"]=rectifier_control_request["ind_current"]
                    # print(rectifier_control_request["ind_current"])
                    if(correct_curr_sensor_flag==1):
                        set_curr(rectifier_control_request["ind_current"]*(12.0-deactivate_rectifiers_num))
                else:
                    # rectifier_readback_values["voltage"]=0
                    rectifier_readback_values["current"]=0
                    # print(rectifier_control_request["ind_current"])
                    try:
                        set_curr(0)
                    except:
                        pass
            
            if(correct_rectifier_flag==1):    
                if(precharge_fail_flag==0 and precharge_fail_flag_2==0):
                    rectifier_readback_values["voltage"]=rectifier_control_request["voltage"]
                elif(precharge_fail_flag==1):
                    rectifier_readback_values["voltage"]=CMS_internal_can_dict["battery_voltage"] -5
                elif(precharge_fail_flag_2==1):
                    rectifier_readback_values["voltage"]=CMS_internal_can_dict["battery_voltage"] -3

            sleep(0.1)
        except:
            pass

curr_flow_thread = Thread(target=emulate_current_flow)
curr_flow_thread.start()




#endregion

#region BMS emulation functions

BMS_sent_CAN_msg={
    "Battery_Unique_key":{"Battery_Unique_key":400000005},
    "Battery_FW_HW":{"Hardware_Version":21,
                     "BMS_Firmware_Version":851},
    "Stateflow_Status":{"gun_lock_req":0,
                        "cc_on_request":0,
                        "solenoid_feedback":0,
                        "gun_unlock_failed":0,
                        "gun_unlock_status":0,
                        "gun_lock_failed":0,
                        "gun_lock_status":0,
                        "Shutdown_Flag_3":0,
                        "Shutdown_Flag_2":0,
                        "Shutdown_Flag_1":0,
                        "Charge_Complete_Status":0,
                        "Motor_Enable_Out":0,
                        "Discharge_Precharge_Out":0,
                        "Discharge_Contactor_Out":0,
                        "Charge_Precharge_Out":0,
                        "Charge_Contactor_Out":0,
                        "Proximity_Pilot_In":1,
                        "Key_In":0,
                        "Fast_Charger_Detected":1,
                        "Slow_Charger_Detected":0,
                        "Battery_State":3,
                        "Discharge_Path_Status":0,
                        "Charge_Path_Status":0,
                        "Discharge_PF_OK":1,
                        "Charge_PF_OK":1,
                        "Discharge_IO_OK":1,
                        "Charge_IO_OK":1,
                        "Discharge_Protection_OK":1,
                        "Charge_Protection_OK":1},
    "Safety_Status":{"SC_COC1_Flag":0,
                     "SC_COC1":0,
                     "ccov_flag_bms":0,
                     "ccov_bms":0,
                     "IB1_Flag":0,
                     "IB1":0,
                     "ccuv_flag_bms":0,
                     "ccuv_bms":0,
                     "icp_status":0,
                     "icp_flag":0,
                     "SC_COC_Flag":0,
                     "ROC_flag":0,
                     "SC_COC":0,
                     "ROC":0,
                     "IB_Flag":0,
                     "IB":0,
                     "SCF_Flag":0,
                     "TSO_Flag":0,
                     "CSO_Flag":0,
                     "DUT_Flag":0,
                     "CUT_Flag":0,
                     "DOT_Flag":0,
                     "COT_Flag":0,
                     "DOC_Flag":0,
                     "COC_Flag":0,
                     "PUV_Flag":0,
                     "POV_Flag":0,
                     "CUV_Flag":0,
                     "COV_Flag":0,
                     "SCF":0,
                     "TSO":0,
                     "CSO":0,
                     "DUT":0,
                     "CUT":0,
                     "DOT":0,
                     "COT":0,
                     "DOC":0,
                     "COC":0,
                     "PUV":0,
                     "POV":0,
                     "CUV":0,
                     "COV":0},
    "Algos_Status":{"SOH":100,
                    "Cell_Balancing_Status":0,
                    "SOP":172,
                    "SOC_User":50},
    "Current_Ah_Count":{"Battery_Current":0,
                        "Last_Charge_Ah":0,
                        "Last_Discharge_Ah":0,
                        "Charge_Cycle_Count":67},
    "Min_Max_IB_Pack_Voltage":{"Voltage_Imbalance":0,
                               "Min_Cell_Voltage":3.3,
                               "Max_Cell_Voltage":3.3,
                               "Pack_Voltage":52},
    "Min_Max_IB_Temp":{"characterization_cycle_count":50,
                        "Temp_Imbalance":0,
                       "Min_Cell_Temp":25,
                       "Max_Cell_Temp":25},
    "Min_Max_Index":{"Max_Temp_Index":1,
                     "Min_Temp_Index":2,
                     "Max_Voltage_Index":1,
                     "Min_Voltage_Index":2},
    "History_of_Protections":{"reset_counter_value":0,
                              "reset_cause":3,
                              "SC_COC1_HIST":0,
                              "ccuv_bms_hist":0,
                              "ccov_bms_hist_":0,
                              "IB1_BMS_HIST":0,
                              "icp_hist":0,
                              "fc_soc_convergence_ack":0,
                              "SC_COC_HIST":0,
                              "ROC_HIST":0,
                              "IB_BMS_HIST":0,
                              "SCF_BMS_HIST":0,
                              "TSO_BMS_HIST":0,
                              "CSO_BMS_HIST":.0,
                              "DUT_BMS_HIST":0,
                              "CUT_BMS_HIST":0,
                              "DOT_BMS_HIST":0,
                              "COT_BMS_HIST":0,
                              "DOC_BMS_HIST":0,
                              "COC_BMS_HIST":0,
                              "PUV_BMS_HIST":0,
                              "POV_BMS_HIST":0,
                              "CUV_BMS_HIST":0,
                              "COV_BMS_HIST":0},
    "Debug_SOC_Slow_Charger":{"unlock_retries":0,
                              "lock_retries":0,
                              "Slow_Charger_State":0,
                              "SOC_Memory":50,
                              "SOC_Actual":50},
    "fast_charger_debug":{"debug_dti_ah":100,
                          "debug_before_ah":100,
                          "debug_after_ah":100},
    "bms_tempertaure_1":{"charge_con_busbar":26,
                         "m1_ct3":26,
                         "m1_ct2":26,
                         "m1_ct1":26},
    "bms_tempertaure_2":{"charge_contactor":26,
                         "m2_ct3":26,
                         "m2_ct2":26,
                         "m2_ct1":26},
    "bms_tempertaure_3":{"discharge_contactor":26,
                         "m3_ct3":26,
                         "m3_ct2":26,
                         "m3_ct1":26},
    "bms_temperature_4":{"shunt_resistor":26,
                         "m4_ct3":26,
                         "m4_ct2":26,
                         "m4_ct1":26},
    "bms_hw_oem_pack_version":{"pack_variant":1,
                               "hw_minor":1,
                               "hw_major":2,
                               "fw_oem_variant":0,
                               "fw_oem_lookup":0},
    "bms_fw_version":{"fw_oem_patch":0,
                        "fw_patch":3,
                        "fw_minor":5,
                        "fw_major":3},
    "bms_cmd_ack_msg1":{"bms_calage_ack":0,
                        "bms_calage_cmd_ack":0},
    "bl_bms_meta_data4":{"bl_bms_fw_oem_patch":0,
                         "bl_bms_fw_version_patch":0,
                         "bl_bms_fw_version_minor":0,
                         "bl_bms_fw_version_major":0,
                          },
    "bl_bms_meta_data1":{"bl_bms_pack_variant":1,
                         "bl_bms_hw_version_minor":2,
                         "bl_bms_hw_version_major":2,
                         "bl_bms_oem_variant":0,
                         "bl_bms_oem_lookup":0,                        
                          }          
}


BMS_sent_CAN_msg_base={
    "Battery_Unique_key":{"Battery_Unique_key":400000005},
    "Battery_FW_HW":{"Hardware_Version":21,
                     "BMS_Firmware_Version":851},
    "Stateflow_Status":{"gun_lock_req":0,
                        "cc_on_request":0,
                        "solenoid_feedback":0,
                        "gun_unlock_failed":0,
                        "gun_unlock_status":0,
                        "gun_lock_failed":0,
                        "gun_lock_status":0,
                        "Shutdown_Flag_3":0,
                        "Shutdown_Flag_2":0,
                        "Shutdown_Flag_1":0,
                        "Charge_Complete_Status":0,
                        "Motor_Enable_Out":0,
                        "Discharge_Precharge_Out":0,
                        "Discharge_Contactor_Out":0,
                        "Charge_Precharge_Out":0,
                        "Charge_Contactor_Out":0,
                        "Proximity_Pilot_In":1,
                        "Key_In":0,
                        "Fast_Charger_Detected":1,
                        "Slow_Charger_Detected":0,
                        "Battery_State":3,
                        "Discharge_Path_Status":0,
                        "Charge_Path_Status":0,
                        "Discharge_PF_OK":1,
                        "Charge_PF_OK":1,
                        "Discharge_IO_OK":1,
                        "Charge_IO_OK":1,
                        "Discharge_Protection_OK":1,
                        "Charge_Protection_OK":1},
    "Safety_Status":{"SC_COC1_Flag":0,
                     "SC_COC1":0,
                     "ccov_flag_bms":0,
                     "ccov_bms":0,
                     "IB1_Flag":0,
                     "IB1":0,
                     "ccuv_flag_bms":0,
                     "ccuv_bms":0,
                     "icp_status":0,
                     "icp_flag":0,
                     "SC_COC_Flag":0,
                     "ROC_flag":0,
                     "SC_COC":0,
                     "ROC":0,
                     "IB_Flag":0,
                     "IB":0,
                     "SCF_Flag":0,
                     "TSO_Flag":0,
                     "CSO_Flag":0,
                     "DUT_Flag":0,
                     "CUT_Flag":0,
                     "DOT_Flag":0,
                     "COT_Flag":0,
                     "DOC_Flag":0,
                     "COC_Flag":0,
                     "PUV_Flag":0,
                     "POV_Flag":0,
                     "CUV_Flag":0,
                     "COV_Flag":0,
                     "SCF":0,
                     "TSO":0,
                     "CSO":0,
                     "DUT":0,
                     "CUT":0,
                     "DOT":0,
                     "COT":0,
                     "DOC":0,
                     "COC":0,
                     "PUV":0,
                     "POV":0,
                     "CUV":0,
                     "COV":0},
    "Algos_Status":{"SOH":100,
                    "Cell_Balancing_Status":0,
                    "SOP":172,
                    "SOC_User":50},
    "Current_Ah_Count":{"Battery_Current":0,
                        "Last_Charge_Ah":0,
                        "Last_Discharge_Ah":0,
                        "Charge_Cycle_Count":67},
    "Min_Max_IB_Pack_Voltage":{"Voltage_Imbalance":0,
                               "Min_Cell_Voltage":3.3,
                               "Max_Cell_Voltage":3.3,
                               "Pack_Voltage":52},
    "Min_Max_IB_Temp":{"characterization_cycle_count":50,
                        "Temp_Imbalance":0,
                       "Min_Cell_Temp":25,
                       "Max_Cell_Temp":25},
    "Min_Max_Index":{"Max_Temp_Index":1,
                     "Min_Temp_Index":2,
                     "Max_Voltage_Index":1,
                     "Min_Voltage_Index":2},
    "History_of_Protections":{"reset_counter_value":0,
                              "reset_cause":3,
                              "SC_COC1_HIST":0,
                              "ccuv_bms_hist":0,
                              "ccov_bms_hist_":0,
                              "IB1_BMS_HIST":0,
                              "icp_hist":0,
                              "fc_soc_convergence_ack":0,
                              "SC_COC_HIST":0,
                              "ROC_HIST":0,
                              "IB_BMS_HIST":0,
                              "SCF_BMS_HIST":0,
                              "TSO_BMS_HIST":0,
                              "CSO_BMS_HIST":.0,
                              "DUT_BMS_HIST":0,
                              "CUT_BMS_HIST":0,
                              "DOT_BMS_HIST":0,
                              "COT_BMS_HIST":0,
                              "DOC_BMS_HIST":0,
                              "COC_BMS_HIST":0,
                              "PUV_BMS_HIST":0,
                              "POV_BMS_HIST":0,
                              "CUV_BMS_HIST":0,
                              "COV_BMS_HIST":0},
    "Debug_SOC_Slow_Charger":{"unlock_retries":0,
                              "lock_retries":0,
                              "Slow_Charger_State":0,
                              "SOC_Memory":50,
                              "SOC_Actual":50},
    "fast_charger_debug":{"debug_dti_ah":100,
                          "debug_before_ah":100,
                          "debug_after_ah":100},
    "bms_tempertaure_1":{"charge_con_busbar":26,
                         "m1_ct3":26,
                         "m1_ct2":26,
                         "m1_ct1":26},
    "bms_tempertaure_2":{"charge_contactor":26,
                         "m2_ct3":26,
                         "m2_ct2":26,
                         "m2_ct1":26},
    "bms_tempertaure_3":{"discharge_contactor":26,
                         "m3_ct3":26,
                         "m3_ct2":26,
                         "m3_ct1":26},
    "bms_temperature_4":{"shunt_resistor":26,
                         "m4_ct3":26,
                         "m4_ct2":26,
                         "m4_ct1":26},
    "bms_hw_oem_pack_version":{"pack_variant":1,
                               "hw_minor":1,
                               "hw_major":2,
                               "fw_oem_variant":0,
                               "fw_oem_lookup":0},
    "bms_fw_version":{"fw_oem_patch":0,
                        "fw_patch":3,
                        "fw_minor":5,
                        "fw_major":3},
    "bms_cmd_ack_msg1":{"bms_calage_ack":0,
                        "bms_calage_cmd_ack":0},
    "bl_bms_meta_data4":{"bl_bms_fw_oem_patch":0,
                         "bl_bms_fw_version_patch":0,
                         "bl_bms_fw_version_minor":0,
                         "bl_bms_fw_version_major":0,
                          }    ,
    "bl_bms_meta_data1":{"bl_bms_pack_variant":1,
                         "bl_bms_hw_version_minor":2,
                         "bl_bms_hw_version_major":2,
                         "bl_bms_oem_variant":0,
                         "bl_bms_oem_lookup":0,                        
                          }       

}

BMS_sent_messages=[]
bms_send_flag=0
voltage_cutoff=3.595

def change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_lookup=0,oem_var=0,pack_var=1,oem_patch=0,hw_major=2,hw_minor=1):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["bms_fw_version"]["fw_major"]=maj
    BMS_sent_CAN_msg["bms_fw_version"]["fw_minor"]=min
    BMS_sent_CAN_msg["bms_fw_version"]["fw_patch"]=patch
    BMS_sent_CAN_msg["bms_fw_version"]["fw_oem_patch"]=oem_patch
    BMS_sent_CAN_msg["bms_hw_oem_pack_version"]["fw_oem_lookup"]=oem_lookup
    BMS_sent_CAN_msg["bms_hw_oem_pack_version"]["fw_oem_variant"]=oem_var
    BMS_sent_CAN_msg["bms_hw_oem_pack_version"]["pack_variant"]=pack_var

    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_version_major"]=maj
    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_version_minor"]=min
    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_version_patch"]=patch
    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_oem_patch"]=oem_patch

    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_oem_lookup"]=oem_lookup
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_oem_variant"]=oem_var
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_pack_variant"]=pack_var
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_hw_version_major"]=hw_major
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_hw_version_minor"]=hw_minor

def emulate_bl_bms_fw_ver(maj=3,min=5,patch=2,oem_patch=0):
    global BMS_sent_CAN_msg

def emulate_bms_pack_varient(v):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["bms_hw_oem_pack_version"]["pack_variant"]=v

def emulate_bms_calage_ack(v):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["bms_cmd_ack_msg1"]["bms_calage_ack"]=v

def emulate_bms_calage_cmd_ack(v):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["bms_cmd_ack_msg1"]["bms_calage_cmd_ack"]=v

def emulate_tec_ack(v):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["History_of_Protections"]["fc_soc_convergence_ack"]=int(v)
def emulate_last_charge_ah(v):
    global BMS_sent_CAN_msg,bms_send_flag
    if(v!=-1):
        BMS_sent_CAN_msg["Current_Ah_Count"]["Last_Charge_Ah"]=v 
    else:
        BMS_sent_CAN_msg["Current_Ah_Count"]["Last_Charge_Ah"]=0

    # print_with_log("emulating BMS last charge ah : "+str(v))

def emulate_dti_ah(v):
    global BMS_sent_CAN_msg,bms_send_flag
    if(v!=-1):
        BMS_sent_CAN_msg["fast_charger_debug"]["debug_dti_ah"]=v 
    else:
        BMS_sent_CAN_msg["fast_charger_debug"]["debug_dti_ah"]=0

def emulate_pack_id(val):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Battery_Unique_key"]["Battery_Unique_key"]=val

def change_BMS_unique_id_for_otc(val=400000809):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Battery_Unique_key"]["Battery_Unique_key"]=val


wrong_last_charge_ah_flag=0
matlab_b3_pack=0

def BMS_msg_send():
    global BMS_sent_CAN_msg,BMS_sent_messages,ota_db,ota_bus,bms_send_flag,wrong_last_charge_ah_flag
    global ota_can_dict,matlab_b3_pack,send_bl_heartbeat_flag
    while(1):
        if(bms_send_flag==1):
            if(wrong_last_charge_ah_flag==0):
                try:
                    emulate_last_charge_ah(ota_can_dict["fast_charger_ah"])
                    emulate_dti_ah(ota_can_dict["fast_charger_ah"])
                except:
                    pass
            try:            
                for k in BMS_sent_CAN_msg.keys():                    
                    example_message = ota_db.get_message_by_name(k)
                    data = example_message.encode(BMS_sent_CAN_msg[k])
                    message = can.Message(arbitration_id=example_message.frame_id, data=data,is_extended_id=False)
                    ### dont send pack varient for old B3 matlab based packs
                    if(k =="bms_hw_oem_pack_version" and matlab_b3_pack==1):
                        pass
                    else:
                        ota_bus.send(message)
                    # sleep(0.001)
                    # print_with_log(message)
                
            except Exception as ex:
                # print_with_log("sending err: "+str(ex))
                pass
        if(send_bl_heartbeat_flag ==1):
            go_to_init_inti_state()
            try:
                bl_msg_list=["bl_bms_meta_data4","bl_bms_meta_data1"]
                for m in bl_msg_list:
                    example_message = ota_db.get_message_by_name(m)
                    data = example_message.encode(BMS_sent_CAN_msg[m])
                    message = can.Message(arbitration_id=example_message.frame_id, data=data,is_extended_id=False)
                    ota_bus.send(message)
            except:
                pass

        sleep(0.02)

BMS_send_thread = Thread(target=BMS_msg_send)

def reset_BMS_data():
    global BMS_sent_CAN_msg,BMS_sent_CAN_msg_base,battery_thermal_emulation,matlab_b3_pack
    BMS_sent_CAN_msg["Battery_FW_HW"]["BMS_Firmware_Version"] = BMS_sent_CAN_msg_base["Battery_FW_HW"]["BMS_Firmware_Version"]
    BMS_sent_CAN_msg["Battery_FW_HW"]["Hardware_Version"] =BMS_sent_CAN_msg_base["Battery_FW_HW"]["Hardware_Version"]
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=BMS_sent_CAN_msg_base["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]
    BMS_sent_CAN_msg["Current_Ah_Count"]["Charge_Cycle_Count"]=BMS_sent_CAN_msg_base["Current_Ah_Count"]["Charge_Cycle_Count"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Proximity_Pilot_In"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Proximity_Pilot_In"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Battery_State"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Battery_State"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Path_Status"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Charge_Path_Status"]
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["solenoid_feedback"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Key_In"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Key_In"]
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_req"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["gun_lock_req"]
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_status"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["gun_lock_status"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Motor_Enable_Out"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Motor_Enable_Out"]
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_status"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["gun_unlock_status"]
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_failed"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["gun_lock_failed"]
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_failed"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["gun_unlock_failed"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_PF_OK"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Charge_PF_OK"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Protection_OK"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Charge_Protection_OK"]
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["Charge_Contactor_Out"]
    BMS_sent_CAN_msg["Stateflow_Status"]["cc_on_request"]=BMS_sent_CAN_msg_base["Stateflow_Status"]["cc_on_request"]
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Max_Cell_Temp"]=BMS_sent_CAN_msg_base["Min_Max_IB_Temp"]["Max_Cell_Temp"]
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Min_Cell_Temp"]=BMS_sent_CAN_msg_base["Min_Max_IB_Temp"]["Min_Cell_Temp"]
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Temp_Imbalance"]=BMS_sent_CAN_msg_base["Min_Max_IB_Temp"]["Temp_Imbalance"]
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["characterization_cycle_count"]=BMS_sent_CAN_msg_base["Min_Max_IB_Temp"]["characterization_cycle_count"]
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=BMS_sent_CAN_msg_base["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=BMS_sent_CAN_msg_base["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]
    BMS_sent_CAN_msg["Safety_Status"]["COT"]=BMS_sent_CAN_msg_base["Safety_Status"]["COT"]
    BMS_sent_CAN_msg["Safety_Status"]["COT_Flag"]=BMS_sent_CAN_msg_base["Safety_Status"]["COT_Flag"]
    BMS_sent_CAN_msg["Algos_Status"]["SOC_User"]=BMS_sent_CAN_msg_base["Algos_Status"]["SOC_User"]
    BMS_sent_CAN_msg["Debug_SOC_Slow_Charger"]["SOC_Actual"]=BMS_sent_CAN_msg_base["Debug_SOC_Slow_Charger"]["SOC_Actual"]
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Voltage_Imbalance"]=BMS_sent_CAN_msg_base["Min_Max_IB_Pack_Voltage"]["Voltage_Imbalance"]

    BMS_sent_CAN_msg["bms_tempertaure_1"]["m1_ct3"]=BMS_sent_CAN_msg_base["bms_tempertaure_1"]["m1_ct3"]
    BMS_sent_CAN_msg["bms_tempertaure_1"]["m1_ct2"]=BMS_sent_CAN_msg_base["bms_tempertaure_1"]["m1_ct2"]
    BMS_sent_CAN_msg["bms_tempertaure_1"]["m1_ct1"]=BMS_sent_CAN_msg_base["bms_tempertaure_1"]["m1_ct1"]
    BMS_sent_CAN_msg["bms_tempertaure_2"]["m2_ct3"]=BMS_sent_CAN_msg_base["bms_tempertaure_2"]["m2_ct3"]
    BMS_sent_CAN_msg["bms_tempertaure_2"]["m2_ct2"]=BMS_sent_CAN_msg_base["bms_tempertaure_2"]["m2_ct2"]
    BMS_sent_CAN_msg["bms_tempertaure_2"]["m2_ct1"]=BMS_sent_CAN_msg_base["bms_tempertaure_2"]["m2_ct1"]
    BMS_sent_CAN_msg["bms_tempertaure_3"]["m3_ct3"]=BMS_sent_CAN_msg_base["bms_tempertaure_3"]["m3_ct3"]
    BMS_sent_CAN_msg["bms_tempertaure_3"]["m3_ct2"]=BMS_sent_CAN_msg_base["bms_tempertaure_3"]["m3_ct2"]
    BMS_sent_CAN_msg["bms_tempertaure_3"]["m3_ct1"]=BMS_sent_CAN_msg_base["bms_tempertaure_3"]["m3_ct1"]
    BMS_sent_CAN_msg["bms_temperature_4"]["m4_ct3"]=BMS_sent_CAN_msg_base["bms_temperature_4"]["m4_ct3"]
    BMS_sent_CAN_msg["bms_temperature_4"]["m4_ct2"]=BMS_sent_CAN_msg_base["bms_temperature_4"]["m4_ct2"]
    BMS_sent_CAN_msg["bms_temperature_4"]["m4_ct1"]=BMS_sent_CAN_msg_base["bms_temperature_4"]["m4_ct1"]

    BMS_sent_CAN_msg["bms_cmd_ack_msg1"]["bms_calage_ack"]=BMS_sent_CAN_msg_base["bms_cmd_ack_msg1"]["bms_calage_ack"]
    BMS_sent_CAN_msg["bms_cmd_ack_msg1"]["bms_calage_cmd_ack"]=BMS_sent_CAN_msg_base["bms_cmd_ack_msg1"]["bms_calage_cmd_ack"]

    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_pack_variant"]=BMS_sent_CAN_msg_base["bl_bms_meta_data1"]["bl_bms_pack_variant"]
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_hw_version_minor"]=BMS_sent_CAN_msg_base["bl_bms_meta_data1"]["bl_bms_hw_version_minor"]
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_hw_version_major"]=BMS_sent_CAN_msg_base["bl_bms_meta_data1"]["bl_bms_hw_version_major"]
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_oem_variant"]=BMS_sent_CAN_msg_base["bl_bms_meta_data1"]["bl_bms_oem_variant"]
    BMS_sent_CAN_msg["bl_bms_meta_data1"]["bl_bms_oem_lookup"]=BMS_sent_CAN_msg_base["bl_bms_meta_data1"]["bl_bms_oem_lookup"]

    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_version_major"]=BMS_sent_CAN_msg_base["bl_bms_meta_data4"]["bl_bms_fw_version_major"]
    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_version_minor"]=BMS_sent_CAN_msg_base["bl_bms_meta_data4"]["bl_bms_fw_version_minor"]
    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_version_patch"]=BMS_sent_CAN_msg_base["bl_bms_meta_data4"]["bl_bms_fw_version_patch"]
    BMS_sent_CAN_msg["bl_bms_meta_data4"]["bl_bms_fw_oem_patch"]=BMS_sent_CAN_msg_base["bl_bms_meta_data4"]["bl_bms_fw_oem_patch"]
    battery_thermal_emulation=0
    



def emulate_BMS_FW_version(v):
     global BMS_sent_CAN_msg,bms_send_flag
     BMS_sent_CAN_msg["Battery_FW_HW"]["BMS_Firmware_Version"]=v
     sleep(0.5)
     print_with_log("emulating BMS FW version: "+str(v))


def emulate_BMS_HW_version(v):
     global BMS_sent_CAN_msg,bms_send_flag
     BMS_sent_CAN_msg["Battery_FW_HW"]["Hardware_Version"]=v
     sleep(0.5)
     print_with_log("emulating BMS HW version: "+str(v))

def emulate_pack_voltage(v):
    global BMS_sent_CAN_msg,bms_send_flag
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=v
    sleep(0.5)
    print_with_log("emulating BMS HW version: "+str(v))

def emulate_BMS_cycle_count(v):
     global BMS_sent_CAN_msg,bms_send_flag
     BMS_sent_CAN_msg["Current_Ah_Count"]["Charge_Cycle_Count"]=v
     sleep(0.5)
     print_with_log("emulating BMS cycle count: "+str(v))

def emulate_plug_connection():
    global BMS_sent_CAN_msg,bms_send_flag    
    print_with_log("Emulating battery connection to station")
    BMS_sent_CAN_msg["Stateflow_Status"]["Proximity_Pilot_In"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["Battery_State"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Path_Status"]=0
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
def key_in_toggle():
    global BMS_sent_CAN_msg
    print_with_log("Emulating battery key toggle")
    BMS_sent_CAN_msg["Stateflow_Status"]["Key_In"]=1
    sleep(3)
    BMS_sent_CAN_msg["Stateflow_Status"]["Key_In"]=0

def emulate_gun_lock():
    global BMS_sent_CAN_msg,CMS_version,ota_can_dict
    if(CMS_version==4.0):
        st_time=timer()
        while(ota_can_dict["gun_lock_request"]!=1):
            print_with_log("waiting for gun lock request from station")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. No gun lock request. test Fail")
                return        
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=1
    print_with_log("Emulating battery solenoid lock")
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_req"]=1    
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_status"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["Motor_Enable_Out"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["Proximity_Pilot_In"]=1  
    BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_status"]=0
    if(CMS_version ==4.2):
        update_ulock_status(s=1)
    sleep(0.5)

def emulate_solenoid_fb(s):
    global BMS_sent_CAN_msg,bms_send_flag    
    print_with_log("Emulating solenoid feedback to: "+str(s))    
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=int(s)

def emulate_bms_gun_lock_fail():
    global BMS_sent_CAN_msg,bms_send_flag
    print_with_log("Emulating gun lock fail from BMS")
    if(CMS_version==4.0):
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_failed"]=1
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_status"]=0
    if(CMS_version == 4.2):
        update_ulock_status(s=0)

def emulate_max_voltage(val):
    global BMS_sent_CAN_msg,bms_send_flag
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=val


def emulate_bms_gun_lock_fail_off():
    global BMS_sent_CAN_msg,bms_send_flag
    print_with_log("Emulating gun lock fail from BMS")
    
    
    if(CMS_version == 4.2):
        update_ulock_status(s=1)
    if(CMS_version==4.0):
        emulate_solenoid_fb(1)
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=1
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_failed"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_status"]=1
        

def emulate_bms_gun_unlock_fail():
    global BMS_sent_CAN_msg,bms_send_flag,CMS_version
    print_with_log("Emulating gun unlock fail from BMS")   
    
    if(CMS_version == 4.2):
        update_cp_state(4)
        update_ulock_status(s=1)
    if(CMS_version == 4.0):
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=1
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_failed"]=1
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_status"]=0
        

def emulate_bms_gun_unlock_fail_off():
    global BMS_sent_CAN_msg,bms_send_flag,CMS_internal_can_dict,CMS_version
    print_with_log("Emulating gun unlock fail from BMS")
    if(CMS_version == 4.0):
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_failed"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_status"]=1    
    
    if(CMS_version == 4.2):
        st_time=timer()
        while(CMS_internal_can_dict["cx_actuator_status"]==0):
            print_with_log("waiting for unlock actuator to activate")
            sleep(1)
            if(timer()-st_time>10):
                print_with_log("unlock actuator timeout.Test fail")
                break
        print_with_log("making cp to 6v to indicate the actuator pressing")
        update_cp_state(6)    
        update_ulock_status(s=0)
        st_time=timer()
        while(CMS_internal_can_dict["cx_actuator_status"]==1):
            print_with_log("waiting for unlock actuator to deactivate")
            sleep(1)
            if(timer()-st_time>10):
                print_with_log("unlock actuator stop timeout.Test fail")
                break
        print_with_log("making cp to 6v to indicate the actuator pressing")
        update_cp_state(6)    

    


def emulate_bms_state(s):
    global BMS_sent_CAN_msg,bms_send_flag    
    print_with_log("Emulating battery state to: "+str(s))    
    BMS_sent_CAN_msg["Stateflow_Status"]["Battery_State"]=int(s)
    

def emulate_charge_protection_trigger():
    global BMS_sent_CAN_msg,bms_send_flag
    
    BMS_sent_CAN_msg["Stateflow_Status"]["Battery_State"]=3
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Path_Status"]=0
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_PF_OK"]=0
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Protection_OK"]=0

def emulate_charge_protection_untrigger():
    global BMS_sent_CAN_msg,bms_send_flag    
    BMS_sent_CAN_msg["Stateflow_Status"]["Battery_State"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Path_Status"]=0
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_PF_OK"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Protection_OK"]=1


def emulate_gun_unlock():
    global BMS_sent_CAN_msg,CMS_version
    print_with_log("Emulating battery solenoid unlock")
    if(CMS_version==4.0):
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_req"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_status"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_status"]=1
    if(CMS_version==4.2):
        update_cp_state(6)
        update_ulock_status(s=0)
    sleep(0.5)

def emulate_cc_close():
    global BMS_sent_CAN_msg
    # print_with_log("Emulating battery charge contactor on")
    BMS_sent_CAN_msg["Stateflow_Status"]["Proximity_Pilot_In"]=1    
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Path_Status"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]=1
    BMS_sent_CAN_msg["Stateflow_Status"]["cc_on_request"]=1

def emulate_temp_ib(t):
    emulate_min_max_temp(min_temp_val=(25 - t/2),max_temp_val=(25+t/2))


def emulate_cc_open():
    global BMS_sent_CAN_msg
    # print_with_log("Emulating battery charge contactor off")
    BMS_sent_CAN_msg["Stateflow_Status"]["Proximity_Pilot_In"]=1    
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Path_Status"]=0
    BMS_sent_CAN_msg["Stateflow_Status"]["Charge_Contactor_Out"]=0
    BMS_sent_CAN_msg["Stateflow_Status"]["cc_on_request"]=0
    
def emulate_cell_voltages(cv):
    global BMS_sent_CAN_msg
    print_with_log("Setting all cell voltages to "+str(cv))
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=cv
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=cv
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=cv*16


def emulate_voltage_increase(start_vol,end_vol,steps):
    global BMS_sent_CAN_msg
    voltage_step=(end_vol-start_vol)/steps
    for v in range(int(start_vol*1000),int(end_vol*1000),int(voltage_step*1000)):
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=v/1000.0
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=v/1000.0
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(v/1000.0)*16
        sleep(2)
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=end_vol
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=end_vol
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(end_vol)*16
    sleep(1)

def emulate_voltage_increase_till_cutoff(start_vol,step_v=0.005):
    global BMS_sent_CAN_msg,CMS_internal_can_dict,battery_capacity
    if(CMS_internal_can_dict["set_current"]<100):        
        step_v=step_v/2

    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=start_vol
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=start_vol
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(start_vol)*16
    v=start_vol
    base_cur=CMS_internal_can_dict["set_current"]
    org_c_rate=base_cur/battery_capacity
    print_with_log("Starting voltage cutoff test at C rate: "+str(org_c_rate))
    while(1):
        v=v+step_v
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=v
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=v
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(v)*16        
        sleep(1)
        cur=CMS_internal_can_dict["set_current"]
        # print_with_log("Voltage: "+str(v)+" algo current: "+str(cur))
        if(cur  < 20):
            print_with_log("Voltage cutoff at voltage: "+str(v)+" for C rate: "+str(org_c_rate))
            sleep(1)
            BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=start_vol
            BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=start_vol
            BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(start_vol)*16
            return v
        if(v>3.62):
            print_with_log("No current cutoff till 3.62")
            return v

def emulate_voltage_ib_cutoff(start_vol=3.3,max_limit=100,step_ib = 0.005):
    global BMS_sent_CAN_msg,CMS_internal_can_dict,battery_capacity
    

    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=start_vol
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=start_vol
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Voltage_Imbalance"]=0
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(start_vol)*16

    ib=0
    base_cur=CMS_internal_can_dict["set_current"]
    org_c_rate=base_cur/battery_capacity
    print_with_log("Starting voltage ib cutoff test at C rate: "+str(org_c_rate))
    while(1):
        ib = ib +step_ib ### 5mv ib step
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=start_vol
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=start_vol + ib
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Voltage_Imbalance"]=ib
        BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(start_vol)*16.0 + ib        
        sleep(1)
        cur=CMS_internal_can_dict["set_current"]
        # print_with_log("Voltage: "+str(v)+" algo current: "+str(cur))
        if(cur < base_cur):
            print_with_log("Voltage ib cutoff at imbalance (mV): "+str(ib*1000.0)+" for C rate: "+str(org_c_rate))
            sleep(1) ## stay at high ib value for record and algo check function activation
            BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=start_vol
            BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=start_vol
            BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Voltage_Imbalance"]=0
            BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Pack_Voltage"]=(start_vol)*16
            return ib
        if(ib*1000.0 > max_limit):
            print_with_log("No current cutoff till "+str(max_limit)+"Test fail.")
            return ib


def emulate_BMS_individual_temp_charge(no,val):
    global BMS_sent_CAN_msg
    signal_list=['m1_ct1',"m1_ct2","m1_ct3",'m2_ct1',"m2_ct2","m2_ct3",'m3_ct1',"m3_ct2","m3_ct3",'m4_ct1',"m4_ct2","m4_ct3"]
    message_name_list=["bms_tempertaure_1","bms_tempertaure_2","bms_tempertaure_3","bms_temperature_4"]
    sgn=signal_list[no-1]
    if("m1" in sgn):
        msg=message_name_list[0]
    if("m2" in sgn):
        msg=message_name_list[1]
    if("m3" in sgn):
        msg=message_name_list[2]
    if("m4" in sgn):
        msg=message_name_list[3]
    
    BMS_sent_CAN_msg[msg][sgn]=val
    # print_with_log("Changed temp: "+str(sgn)+" to val: "+str(val))

def emulate_min_max_temp(min_temp_val=25,max_temp_val=26):
    global BMS_sent_CAN_msg
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,min_temp_val)
    emulate_BMS_individual_temp_charge(1,max_temp_val)
    emulate_max_temp(max_temp_val)
    emulate_min_temp(min_temp_val)
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Temp_Imbalance"]=max_temp_val-min_temp_val




def emulate_COT():
    global BMS_sent_CAN_msg
    print_with_log("Emulating battery COT")
    BMS_sent_CAN_msg["Safety_Status"]["COT"]=1
    BMS_sent_CAN_msg["Safety_Status"]["COT_Flag"]=1
    
def emulate_max_temp(val):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Max_Cell_Temp"]=val

def emulate_min_temp(val):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Min_Cell_Temp"]=val

def emulate_user_soc(val):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Algos_Status"]["SOC_User"]=val

def emulate_actual_soc(val):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Debug_SOC_Slow_Charger"]["SOC_Actual"]=val

def emulate_voltage_IB(val,base_voltage):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Voltage_Imbalance"]=val
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Min_Cell_Voltage"]=base_voltage-(val/2.0)
    BMS_sent_CAN_msg["Min_Max_IB_Pack_Voltage"]["Max_Cell_Voltage"]=base_voltage+(val/2.0)

def emulate_chtz_cycle_count(val):
    global BMS_sent_CAN_msg
    BMS_sent_CAN_msg["Min_Max_IB_Temp"]["characterization_cycle_count"]=val

def emulate_unauthorized_gun_removal():
    global CMS_version,bms_send_flag
    if(CMS_version==4.0):
        print_with_log("Emulating unauthorized gun removal")
        update_cp_state(6)
        bms_send_flag=0

def emulate_unauthorized_gun_reconnection(sol_fb):
    global CMS_version,bms_send_flag
    if(CMS_version==4.0):
        print_with_log("Emulating unauthorized gun removal")
        update_cp_state(4)
        emulate_solenoid_fb(sol_fb)
        bms_send_flag=1
    


#endregion

#region display rs232 CAN data check
display_can_check=0
display_can_data_update_timeout=1
def check_display_can_wrt_rectifier_can():
    global CMS_internal_can_dict,display_can_dict
    while(1):
        if(display_can_check==1):
            res_dict={}
            for k in CMS_internal_can_dict.keys():
                res_dict[k]=False
            data_to_check={}
            for k in CMS_internal_can_dict.keys():
                data_to_check[k]=CMS_internal_can_dict[k]

            fail_list=[]
            st_timer=timer()
            while(False in list(res_dict.values())):
                for k in data_to_check.keys():
                    if(display_can_dict[k]==data_to_check[k]):
                        res_dict[k]=True
                if(timer()-st_timer >display_can_data_update_timeout):
                    print_with_log("Display CAN data not matching after timeout.Test fail")
                    
                    for k in res_dict.keys():
                        if(res_dict[k]==False):
                            fail_list.append(k)
                    print_with_log(fail_list)
                    break
                sleep(0.1)
            if(False not in list(res_dict.values())):
                dur=timer()-st_timer
                print_with_log("All data updated in display CAN in time: "+str(dur))
        sleep(1)
            
check_display_can_wrt_rectifier_can_thread = Thread(target=check_display_can_wrt_rectifier_can)    
check_display_can_wrt_rectifier_can_thread.start()

      
#endregion

#region load_charge_profile

algo_charge_profile_file="charge_profiles/TG1_V10.xlsx"
battery_capacity=172.0
tec_SOC=87.0
chtz_scaling_ah=9.0
parallel_drain_check=0
capacity_deration_check=0
battery_conditioning_request_check=0
c_rate_check=0
ramp_up_flag=0

precharge_fail_flag=0
correct_rectifier_flag=1
correct_current_flag=1
emulate_rectifiers=0
battery_thermal_emulation=0
parallel_drain_check=0
capacity_deration_check=0
battery_conditioning_request_check=0
c_rate_check=0
step_chnage_zero_current_flag=0


def load_charge_profile_table(pack_varient=0,start_min_temp=26,matlab_b3=0):
    global df_constants,df_pre_condition_fluid
    global df_capacity_shrinkage_table,df_voltage_limits_normal
    global df_voltage_limits_chtz,df_min_temp_C_limits
    global df_max_temp_C_limits,df_fluid_control
    global df_parallel_drain
    global battery_capacity,tec_SOC,chtz_scaling_ah
    global matlab_b3_pack,start_C_rate

    matlab_b3_pack=0
    profile_name=""

    if(pack_varient == 0):
        profile_name= "charge_profiles/B3_v2.xlsx"   
        matlab_b3_pack = matlab_b3
        emulate_bms_pack_varient(3)     
        emulate_BMS_HW_version(2)
        change_BMS_fw_ver_for_otc()
        start_C_rate=3.71

    elif(pack_varient==1):
        profile_name= "charge_profiles/TG1_V10.xlsx"  
        matlab_b3_pack = matlab_b3 
        emulate_bms_pack_varient(1)       
        emulate_BMS_HW_version(21)
        change_BMS_fw_ver_for_otc()
        start_C_rate=3.43

    elif(pack_varient==2):
        profile_name= "charge_profiles/TG_max_V2.xlsx"       
        emulate_bms_pack_varient(2)   
        emulate_BMS_HW_version(22)
        change_BMS_fw_ver_for_otc(maj=4,min=2,patch=0)
        start_C_rate=2.95
    
    elif(pack_varient==3):
        profile_name= "charge_profiles/TG1_V10.xlsx"  
        matlab_b3_pack = matlab_b3 
        emulate_bms_pack_varient(1)       
        emulate_BMS_HW_version(21)
        change_BMS_fw_ver_for_otc(maj=4,min=3,patch=0)
        start_C_rate=3.43

    print_with_log("Selecting charge profile: "+str(profile_name))

    xls = pd.ExcelFile(profile_name)

    df_constants= pd.read_excel(xls, 'Constants')
    df_pre_condition_fluid= pd.read_excel(xls, 'T1_precooling_preheating')
    df_capacity_shrinkage_table=pd.read_excel(xls, 'T2_capacity')
    df_voltage_limits_normal = pd.read_excel(xls, 'T3_voltage_normal')
    df_voltage_limits_chtz = pd.read_excel(xls, 'T3_voltage_chtz')
    if(start_min_temp < 25):
        df_min_temp_C_limits = pd.read_excel(xls, 'T4_min_temp')
    else:
        df_min_temp_C_limits = pd.read_excel(xls, 'T4_min_temp_high_temp')

    df_max_temp_C_limits = pd.read_excel(xls, 'T5_max_temp')
    df_fluid_control = pd.read_excel(xls, 'T6_fluid') 
    df_parallel_drain = pd.read_excel(xls, 'T7_drain')


    battery_capacity=df_constants.at[0,"battery_capacity"] 
    tec_SOC=df_constants.at[0,"TEC_SOC"] 
    chtz_scaling_ah=df_constants.at[0,"Characterisation cycle Scaling Ah"] 

load_charge_profile_table(pack_varient=1)


#endregion

#region battery thermal emulation
def emulate_thermal_battery_model():
    global battery_thermal_emulation,CMS_internal_can_dict
    set_curr_table=[-5,30,100,200,400,800]    
    #### each curr step has three temp gradient. 
    # first for no water, cold water and hot water flowing. total 15 gardients for 5 curr steps
    temp_grad_table=[0,-0.3,0.3,0.05,-0.05,0.15,0.05,0.05,0.20,0.10,0,0.25,0.15,-0.05,0.3]

    while(1):
        try:
            if(battery_thermal_emulation ==1):
                # print("in thermal_emulation function")
                set_curr_val=CMS_internal_can_dict["set_current"]
                fcs_state=CMS_internal_can_dict["fcs_status"]
                if(set_curr_val !=-1):

                    current_index = bisect.bisect_left(set_curr_table,set_curr_val) -1
                    fcs_index=-1
                    if(fcs_state in [0,1,2,5]):
                        fcs_index=0
                    elif(fcs_state == 3):
                        fcs_index=1
                    elif(fcs_state == 4):
                        fcs_index=2
                    
                    grad_index=(current_index*3)+fcs_index                                        
                    temp_grad_val=temp_grad_table[grad_index]
                    # print("curr: "+str(set_curr_val)+" fcs: "+str(fcs_state)+" curr_idx: "+str(current_index)+" fcs_idx: "+str(fcs_index)+" t grad: "+str(temp_grad_val))
                    min_temp_new_val=BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Min_Cell_Temp"] + temp_grad_val
                    max_temp_new_val=BMS_sent_CAN_msg["Min_Max_IB_Temp"]["Max_Cell_Temp"] + temp_grad_val
                    emulate_min_max_temp(min_temp_val=min_temp_new_val,max_temp_val=max_temp_new_val)
        except Exception as e:
            print(e)        
        sleep(1)

battery_thermal_thread = Thread(target=emulate_thermal_battery_model)
battery_thermal_thread.start()
#endregion

#region parallel drain check function

def get_index_more_than_list(total_list,current_val,prev_filter_index_list):

    max_t_idx=[]
    max_temp_lower_list=total_list
    c_rate_idx=prev_filter_index_list
    max_t_val = current_val

    if(len(c_rate_idx)==0):
        return max_t_idx

    ### filter the max temp_list for selected C rate only
    max_t_list_filter=[]
    for i in range(len(max_temp_lower_list)):
        if(i in c_rate_idx):
            max_t_list_filter.append(max_temp_lower_list[i])
        else:
            max_t_list_filter.append(200)
        
    # print(max_t_list_filter)
    #### get differance of each temp wrt current max temp
    ### positive differance indicates current val more than table value 
    max_t_list_diff=[]
    for i in range(len(max_temp_lower_list)):
        max_t_list_diff.append(max_t_val-max_t_list_filter[i])
    # print(max_t_list_diff)
    ### make all negative values to 1000 to filter them out
    max_t_list_diff_abs=[]
    for i in range(len(max_t_list_diff)):
        if(max_t_list_diff[i]<0):
            max_t_list_diff_abs.append(1000)
        else:
            max_t_list_diff_abs.append(max_t_list_diff[i])
        
    ### to get minimum of all positive values, take abs of all values
    ### as all negative values will always be much more, they will 
    ### newer considered as minimum    
    # print(max_t_list_diff_abs)
    min_value = min(max_t_list_diff_abs)
    ### now subtract minimum of all positive values form each item of diff list
    max_t_list_end_filter=[]
    for i in range(len(max_t_list_diff_abs)):
        max_t_list_end_filter.append(max_t_list_diff_abs[i]-min_value)
    # print(max_t_list_end_filter)
    ### all the zero values in the filtered list are index allowed to go forward
    for i in range(len(max_t_list_end_filter)):
        if(max_t_list_end_filter[i]==0):
            max_t_idx.append(i)
    
    
    return max_t_idx

last_parallel_drain_req=-1

def check_parallel_drain():
    global parallel_drain_check,CMS_internal_can_dict,last_parallel_drain_req,battery_capacity,df_parallel_drain
    global ramp_up_flag,step_chnage_zero_current_flag

    c_rate_list=[]
    max_temp_lower_list=[]
    max_temp_upper_list=[]
    soc_user_lower_list=[]
    soc_user_upper_list=[]
    par_drain_req_list=[]
    err_count=0

    for i in range(df_parallel_drain.shape[0]):
        c_rate_list.append(df_parallel_drain.at[i,"C Rate"])
        max_temp_lower_list.append(df_parallel_drain.at[i,"Max Cell Temp Lower Bound (>)"])
        max_temp_upper_list.append(df_parallel_drain.at[i,"Max Cell Temp Upper Bound (<=)"])
        soc_user_lower_list.append(df_parallel_drain.at[i,"SoC - Lower Bound (>)"])
        soc_user_upper_list.append(df_parallel_drain.at[i,"SoC - Upper Bound (<=)"])
        par_drain_req_list.append(df_parallel_drain.at[i,"Parallel Drain Request"])

    while(1):
        
        
        if(parallel_drain_check==1 and CMS_internal_can_dict["algo_charge_completion_status"]==2):    
            
            drn_req_val=CMS_internal_can_dict["algo_drain_request"]
            set_cur_val=CMS_internal_can_dict["set_current"]

            # max_t_val=ota_can_dict["Max_Cell_Temp"]            
            # soc_user_val=ota_can_dict["SOC_User"] 
            

            max_t_val=CMS_internal_can_dict["max_cell_temp"]          
            
            soc_user_val=CMS_internal_can_dict["soc_user"] 

            if(ramp_up_flag==1):
                c_rate_val=CMS_internal_can_dict["set_current"]/battery_capacity
            else:
                c_rate_val=CMS_internal_can_dict["current_read"]/battery_capacity

            c_rate_quantized=-1          
            for i in range(len(c_rate_list)):
                if(c_rate_list[i]==0):
                    if(c_rate_val < 0.05):
                        c_rate_quantized=0       
                elif(abs((c_rate_val - c_rate_list[i])/c_rate_list[i])<=0.2):
                    c_rate_quantized = c_rate_list[i]

            ####if nothing in table matches, it should continue in last state
            ### during zero current for step change also keep last value
            if(c_rate_quantized==-1 or step_chnage_zero_current_flag == 1):                
                exp_parallel_drain_req = last_parallel_drain_req                
            else:
                for i in range(df_parallel_drain.shape[0]):
                    if((c_rate_quantized == df_parallel_drain.at[i,"C Rate"]) and
                        (max_t_val > df_parallel_drain.at[i,"Max Cell Temp Lower Bound (>)"]) and
                        (max_t_val <= df_parallel_drain.at[i,"Max Cell Temp Upper Bound (<=)"]) and
                        (soc_user_val > df_parallel_drain.at[i,"SoC - Lower Bound (>)"]) and
                        (soc_user_val <= df_parallel_drain.at[i,"SoC - Upper Bound (<=)"])):

                        exp_parallel_drain_req = df_parallel_drain.at[i,"Parallel Drain Request"]                    
                    
            if(exp_parallel_drain_req!=drn_req_val):
                print_with_log("Parallel drain error Exp drain req: "+str(exp_parallel_drain_req)+" CAN drain_req: "+str(drn_req_val)
                            +" err count: "+str(err_count))
                err_count=err_count+1
                if(err_count>10):
                    print_with_log("Parallel drain fail Exp drain req: "+str(exp_parallel_drain_req)+" CAN drain_req: "+str(drn_req_val))
            else:
                err_count=0
            
            if(drn_req_val!=last_parallel_drain_req):
                print_with_log("Algo Drain request val changed to: "+str(drn_req_val))
                print_with_log("Set_curr "+str(set_cur_val)+" c_rate: "+str(c_rate_quantized)+" max_temp: "+str(max_t_val)+" user_SOC: "+str(soc_user_val))
                last_parallel_drain_req=drn_req_val
        else:
            err_count=0
            c_rate_list=[]
            max_temp_lower_list=[]
            max_temp_upper_list=[]
            soc_user_lower_list=[]
            soc_user_upper_list=[]
            par_drain_req_list=[]
            err_count=0

            for i in range(df_parallel_drain.shape[0]):
                c_rate_list.append(df_parallel_drain.at[i,"C Rate"])
                max_temp_lower_list.append(df_parallel_drain.at[i,"Max Cell Temp Lower Bound (>)"])
                max_temp_upper_list.append(df_parallel_drain.at[i,"Max Cell Temp Upper Bound (<=)"])
                soc_user_lower_list.append(df_parallel_drain.at[i,"SoC - Lower Bound (>)"])
                soc_user_upper_list.append(df_parallel_drain.at[i,"SoC - Upper Bound (<=)"])
                par_drain_req_list.append(df_parallel_drain.at[i,"Parallel Drain Request"])

        sleep(0.1)

parallel_drain_check_thread = Thread(target=check_parallel_drain)
parallel_drain_check_thread.start()


#endregion


#region capacity deration check function

### function to give index out for input value less than that index
### will give idx out = len if not found

def get_index_of_val(val,total_list):
    out_idx=-1
    for i in range(len(total_list)):
        if(val <= total_list[i]):
            out_idx=i
            break
    if(out_idx==-1):
        out_idx=len(total_list)
    return out_idx

def get_1d_interpolation(min_y,max_y,min_x,max_x,x):
    y=min_y+(x-min_x)*((max_y-min_y)/(max_x-min_x))
    return y

def get_interpolated_val(input_val,input_list,output_list):

    input_idx=get_index_of_val(input_val,input_list)

    send_val=0
    ### index in between the table
    if(input_idx>0 and input_idx <len(input_list)):
        max_x=input_list[input_idx]
        min_x =input_list[input_idx-1]
        max_y=output_list[input_idx]
        min_y=output_list[input_idx-1]
        send_val=input_val
        output_val=get_1d_interpolation(min_x=min_x,max_x=max_x,min_y=min_y,max_y=max_y,x=send_val)

    #### index = 0, output becomes 0 th value in y table
    elif(input_idx == 0):
        output_val=output_list[0]
    
    #### index == len(list) no value found, send the last value of output table
    elif(input_idx == len(output_list)):
        output_val=output_list[-1]

    return output_val


def check_capacity_deration():
    global CMS_internal_can_dict,battery_capacity,capacity_deration_check,df_capacity_shrinkage_table
    global ota_can_dict
    min_temp_list=[]    
    der_val_list=[]
    for i in range(df_capacity_shrinkage_table.shape[0]):
        min_temp_list.append(df_capacity_shrinkage_table.at[i,"Min cell Temp"])
        der_val_list.append(df_capacity_shrinkage_table.at[i,"deration_val"])  

    last_cap_der_val=0
    timer_count=0
    while(1):        
            if(capacity_deration_check==1  and CMS_internal_can_dict["bms_can_status"]==1):    
                # min_temp_val=ota_can_dict["Min_Cell_Temp"]
                min_temp_val=CMS_internal_can_dict["min_cell_temp_computed"]                 
                timer_count=timer_count+1
                ### one time check after 5sec of BMS connection
                if(timer_count==50):
                    
                    tder_val= ota_can_dict["t_der"]
                    exp_tder_val=get_interpolated_val(input_val=min_temp_val,input_list=min_temp_list,output_list=der_val_list)

                    if(abs(exp_tder_val-last_cap_der_val)>1.0):
                        print_with_log("Capacity deration chnaged from "+str(last_cap_der_val)+" to "+str(exp_tder_val)
                                    + " at min temp: "+str(min_temp_val))
                        last_cap_der_val=exp_tder_val

                    if(abs(exp_tder_val-tder_val)>1.0):
                        print_with_log("Capacity deration value fail. min temp: "+str(min_temp_val)
                                    +" Exp_tder: "+str(exp_tder_val)+" Actual_tder: "+str(tder_val))  
                ### update last value to see the change        
                else:
                    last_cap_der_val =  ota_can_dict["t_der"]
                   

            else:
                timer_count=0
                last_cap_der_val=0
                min_temp_list=[]    
                der_val_list=[]
                for i in range(df_capacity_shrinkage_table.shape[0]):
                    min_temp_list.append(df_capacity_shrinkage_table.at[i,"Min cell Temp"])
                    der_val_list.append(df_capacity_shrinkage_table.at[i,"deration_val"])  

            sleep(0.1)          
        

check_capacity_deration_thread = Thread(target=check_capacity_deration)
check_capacity_deration_thread.start()

#endregion

#region battery_conditioning request check

def check_battery_conditioning_request():
    global CMS_internal_can_dict,battery_capacity,battery_conditioning_request_check,df_fluid_control,df_pre_condition_fluid
    global ramp_up_flag
    last_bat_cond_req=0
    err_count=0
    
    while(1):
        exp_conditioning_request=0
        can_conditioning_request=CMS_internal_can_dict["battery_conditioning_request"]
        
        try:

            if(battery_conditioning_request_check==1 and 
               (CMS_internal_can_dict["algo_charge_completion_status"]==1 or
                CMS_internal_can_dict["algo_charge_completion_status"]==2)):

                ## condition to use when in charge state
                if(CMS_internal_can_dict["algo_charge_completion_status"]==2):    
                    can_conditioning_request=CMS_internal_can_dict["battery_conditioning_request"]
                    ### if nothing in table matches, it should remain in last state
                    exp_conditioning_request=last_bat_cond_req

                    ### constant 0 in case of algo drain request
                    if(CMS_internal_can_dict["algo_drain_request"]==1):
                        exp_conditioning_request=0
                    ##### value from fluid table without algo drain request
                    else:
                        ### keep the last value during step change zero current
                        if(step_chnage_zero_current_flag == 1):
                            exp_conditioning_request=last_bat_cond_req
                        else:
                            #### get value from table otherwise
                            for i in range(df_fluid_control.shape[0]):
                                row_c_rate=df_fluid_control.at[i,"C-Rate"]
                                row_min_cell_low=df_fluid_control.at[i,"Min Cell Temp Lower Bound (>)"]
                                row_min_cell_up=df_fluid_control.at[i,"Min Cell Temp Upper Bound (<=)"]
                                row_max_cell_low=df_fluid_control.at[i,"Max Cell Temp Lower Bound (>)"]
                                row_max_cell_up=df_fluid_control.at[i,"Max Cell Temp Upper Bound (<=)"]
                                row_cond_req=df_fluid_control.at[i,"Battery Conditioning Request"]

                                if(ramp_up_flag==1):
                                    can_c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
                                else:
                                    can_c_rate=CMS_internal_can_dict["current_read"]/battery_capacity

                                # can_min_cell=ota_can_dict["Min_Cell_Temp"]     
                                # can_max_cell=ota_can_dict["Max_Cell_Temp"]    

                                can_min_cell=CMS_internal_can_dict["min_cell_temp_computed"] 
                                can_max_cell=CMS_internal_can_dict["max_cell_temp"] 
                                
                                if(row_c_rate == 0):
                                    if((row_c_rate == 0) and (can_c_rate < 0.1) and
                                    (can_min_cell > row_min_cell_low) and
                                    (can_min_cell <= row_min_cell_up) and
                                    (can_max_cell > row_max_cell_low) and
                                    (can_max_cell <= row_max_cell_up)):
                                        exp_conditioning_request=row_cond_req

                                elif((abs((can_c_rate-row_c_rate)/row_c_rate)<0.2) and 
                                (can_min_cell > row_min_cell_low) and
                                (can_min_cell <= row_min_cell_up) and
                                (can_max_cell > row_max_cell_low) and
                                (can_max_cell <= row_max_cell_up)):
                                    exp_conditioning_request=row_cond_req
                    
                #### condition during preconditioning
                if(CMS_internal_can_dict["algo_charge_completion_status"]==1):
                    can_conditioning_request=CMS_internal_can_dict["battery_conditioning_request"]
                    
                    # ### constant 0 in case of algo drain request
                    # if(CMS_internal_can_dict["algo_drain_request"]==1):
                    #     exp_conditioning_request=0

                    ### if nothing in table matches, it should remain in last state
                    exp_conditioning_request=last_bat_cond_req

                    ##### value from precondition table without algo drain request                                        
                    for i in range(df_pre_condition_fluid.shape[0]):
                        row_max_cell_low=df_pre_condition_fluid.at[i,"Max Cell Temp - Lower Bound (>)"]      
                        row_max_cell_up=df_pre_condition_fluid.at[i,"Max Cell Temp - Upper Bound (<=)"]                                               
                        row_cond_req=df_pre_condition_fluid.at[i,"Battery Conditioning Request"]  

                        # can_min_cell=ota_can_dict["Min_Cell_Temp"]     
                        # can_max_cell=ota_can_dict["Max_Cell_Temp"]   

                        can_min_cell=CMS_internal_can_dict["min_cell_temp_computed"] 
                        can_max_cell=CMS_internal_can_dict["max_cell_temp"] 

                        if((can_max_cell > row_max_cell_low) and
                           (can_max_cell <= row_max_cell_up)):
                            exp_conditioning_request= row_cond_req
                            
                ###log the change
                if(last_bat_cond_req!=exp_conditioning_request):
                    print_with_log("Battery conditioning request changing from "
                                   +str(last_bat_cond_req)+ " to "+str(exp_conditioning_request)
                                   +" min_temp: "+str(ota_can_dict["Min_Cell_Temp"])
                                   + " max temp: "+str(CMS_internal_can_dict["max_cell_temp"])) 
                    last_bat_cond_req=exp_conditioning_request
                
                if(exp_conditioning_request!=can_conditioning_request):
                    # print_with_log("Battery conditioning request error. exp val: "+str(exp_conditioning_request)+ " CAN val: "+str(can_conditioning_request)
                    #                +" err count: "+str(err_count))
                    err_count=err_count+1
                    if(err_count > 20):
                        pass
                        print_with_log("Battery conditioning request fail. exp val: "+str(exp_conditioning_request)+ " CAN val: "+str(can_conditioning_request))
                        print_with_log("C rate: "+str(can_c_rate)+" min temp: "+str(can_min_cell)+" max temp: "+str(can_max_cell))
                else:
                    err_count=0
                
                

            else:
                last_bat_cond_req=0
                err_count=0

        except Exception as e:
            print_with_log("battery conditioning check err: "+str(e))

        sleep(0.1)


check_battery_conditioning_request_thread = Thread(target=check_battery_conditioning_request)
check_battery_conditioning_request_thread.start()

def check_bat_fluid_allowed_state():
    global CMS_internal_can_dict,battery_conditioning_request_check

    while(1):
        if(battery_conditioning_request_check == 1 and 
           (CMS_internal_can_dict["algo_charge_completion_status"]==1 or
                CMS_internal_can_dict["algo_charge_completion_status"]==2)):

            col_bat_temp= CMS_internal_can_dict["max_cell_temp"]
            cold_fcs_temp= CMS_internal_can_dict["chiller_liquid_temp"]
            hot_bat_temp=CMS_internal_can_dict["min_cell_temp_computed"]
            hot_fcs_temp = CMS_internal_can_dict["heater_tank_temperature"] ###  hot_tank_temp
            can_bat_fluid_ok_state=CMS_internal_can_dict["batt_fluid_allowed"]

            cold_ok=0
            hot_ok=0

            if((cold_fcs_temp <= (col_bat_temp-5)) and  cold_fcs_temp > 5):
                cold_ok=1
            else:
                cold_ok=0

            if((hot_fcs_temp >= (hot_bat_temp+5)) and hot_fcs_temp <60):
                hot_ok=1
            else:
                hot_ok=0

            exp_bat_fluid_ok=-1
            
            if(cold_ok == 1 and hot_ok==1):
                exp_bat_fluid_ok=3
            elif(cold_ok == 0 and hot_ok==1):
                exp_bat_fluid_ok=1
            elif(cold_ok == 1 and hot_ok==0):
                exp_bat_fluid_ok=2
            elif(cold_ok == 0 and hot_ok==0):
                exp_bat_fluid_ok=0
            
            if(exp_bat_fluid_ok != can_bat_fluid_ok_state):
                print_with_log("Battery fluid allowed state fail. can value: "+str(can_bat_fluid_ok_state)+" expect vale: "+str(exp_bat_fluid_ok))
                print_with_log("Max bat temp: "+str(col_bat_temp)+" cold_tank: "+str(cold_fcs_temp))
                print_with_log("Min bat temp: "+str(hot_bat_temp)+" hot_tank: "+str(hot_fcs_temp))
    
        sleep(0.1)

check_bat_fluid_allowed_state_thread = Thread(target=check_bat_fluid_allowed_state)
check_bat_fluid_allowed_state_thread.start()    

def check_fcs_status():
    global CMS_internal_can_dict
    exp_fcs_state=0
    req_fcs_state=0    
    delay_counter=0
    err_count=0
    while(1):
        if(battery_conditioning_request_check==1 and 
                (CMS_internal_can_dict["algo_charge_completion_status"]==1 or
                    CMS_internal_can_dict["algo_charge_completion_status"]==2)):
            can_condition_req=CMS_internal_can_dict["battery_conditioning_request"]
            temp_based_cond_allowed=CMS_internal_can_dict["batt_fluid_allowed"]
            can_cold_protection=CMS_internal_can_dict["fcs_bat_cool_protection_status"]
            can_hot_protection=CMS_internal_can_dict["fcs_heating_protection_status"]
            can_fcs_state=CMS_internal_can_dict["fcs_status"]
            ##shift to battery cooling
            if(can_condition_req ==1 and temp_based_cond_allowed in [2,3] and can_cold_protection ==1):
                if(req_fcs_state !=3):
                    delay_counter=51
                    req_fcs_state=3
            ##shift to battery heating
            elif(can_condition_req ==2 and temp_based_cond_allowed in [1,3] and can_hot_protection ==1):
                if(req_fcs_state !=4):
                    delay_counter=51
                    req_fcs_state=4
            ##shift to other ( all others combined to -1)
            else:
                if(req_fcs_state !=-1):
                    delay_counter=51
                    req_fcs_state=-1
            
            if(delay_counter==1):
                exp_fcs_state = req_fcs_state
                print_with_log("Expected FCS status chnaged to: "+str(exp_fcs_state))
                req_fcs_state=0

            
            ### check can value only when battery cooling or heating is expected
            if(exp_fcs_state == 3 or exp_fcs_state == 4 or exp_fcs_state == -1):
                if(can_fcs_state in [0,1,2,5]):
                    can_fcs_state=-1
                if(can_fcs_state != exp_fcs_state):
                    err_count+=1
                else:
                    err_count==0

                if(err_count>10):
                    print_with_log("FCS status failed. can value: "+str(can_fcs_state)+" exp val: "+str(exp_fcs_state))
                    err_count=0

        else:
            exp_fcs_state=0
            delay_counter=0
            err_count=0
        if(delay_counter!=0):
            delay_counter-=1


        sleep(0.1)

check_fcs_status_thread = Thread(target=check_fcs_status)
check_fcs_status_thread.start()    


#endregion


#region check_C_rate

def get_min_temp_c_rate(min_t,soc_user):
    global df_min_temp_C_limits
    out_c_rate=-1

    for i in range(df_min_temp_C_limits.shape[0]):
        row_min_cell_low=df_min_temp_C_limits.at[i,"Min Cell Temp - Lower Bound (>)"]
        row_min_cell_up=df_min_temp_C_limits.at[i,"Min Cell Temp - Upper Bound (<=)"]
        row_soc_low=df_min_temp_C_limits.at[i,"SoC - Lower Bound (>)"]
        row_soc_up=df_min_temp_C_limits.at[i,"SoC - Upper Bound (<=)"]
        row_c_rate=df_min_temp_C_limits.at[i,"C-Rate"]

        if((min_t > row_min_cell_low) and
           (min_t <= row_min_cell_up) and
           (soc_user > row_soc_low) and
           (soc_user <= row_soc_up)):
            
            out_c_rate = row_c_rate

    if(out_c_rate==-1):
        print_with_log("No C rate defined by min temp table.Test fail. min temp val: "+str(min_t)+" SOC_actual: "+str(soc_user))
        return 0
    else:
        return out_c_rate

def get_max_temp_c_rate(max_t,soc_user,cold_tank_t):
    global df_max_temp_C_limits
    out_c_rate=-1

    for i in range(df_max_temp_C_limits.shape[0]):
        row_max_cell_low=df_max_temp_C_limits.at[i,"Max Cell Temp - Lower Bound (>)"]
        row_max_cell_up=df_max_temp_C_limits.at[i,"Max Cell Temp - Upper Bound (<=)"]
        row_soc_low=df_max_temp_C_limits.at[i,"SoC - Lower Bound (>)"]
        row_soc_up=df_max_temp_C_limits.at[i,"SoC - Upper Bound (<=)"]
        row_cold_tank_t_low=df_max_temp_C_limits.at[i,"Cold Tank Liquid - Lower Bound (>)"]
        row_cold_tank_t_up=df_max_temp_C_limits.at[i,"Cold Tank Liquid - Upper Bound (<=)"]
        row_c_rate=df_max_temp_C_limits.at[i,"C-Rate"]

        if((max_t > row_max_cell_low) and
           (max_t <= row_max_cell_up) and
           (soc_user > row_soc_low) and
           (soc_user <= row_soc_up) and
           (cold_tank_t > row_cold_tank_t_low) and
           (cold_tank_t <= row_cold_tank_t_up)):            
            out_c_rate = row_c_rate
    if(out_c_rate==-1):
        print_with_log("No C rate defined by max temp table.Test fail. max temp val: "+str(max_t)+" SOC_actual: "+str(soc_user)+" cold_temp: "+str(cold_tank_t))
        return 0
    else:
        return out_c_rate            

def get_voltage_out_c_rate(vol_c_rate_in,min_t,max_v,vol_ib,chtz_flag):
    global df_voltage_limits_normal,df_voltage_limits_chtz
    df_voltage_limit_table=None
    if(chtz_flag==0):
        df_voltage_limit_table=df_voltage_limits_normal
    elif(chtz_flag==1):
        df_voltage_limit_table=df_voltage_limits_chtz

    c_rate_out=0
    
    min_cell_temp_list=[]
    max_voltage_list=[]
    voltage_ib_list=[]
    post_deration_c_rate_list=[]
    quantized_c_rate=0

    ### get list for temp based cutoff voltage interpolation
    for i in range(df_voltage_limit_table.shape[0]):        
        row_c_rate=df_voltage_limit_table.at[i,"Instantanous C-Rate"]
        row_min_temp=df_voltage_limit_table.at[i,"Min_Cell_Temp (in C)"]
        row_max_v=df_voltage_limit_table.at[i,"Max_Cell_Voltage (in V)"]
        row_vol_ib=df_voltage_limit_table.at[i,"Max_cell_Imbalance (mV)"]
        row_post_deration_c_rate=df_voltage_limit_table.at[i,"Post-Deration C-Rate"]

        ### use row with +- 20% tollerance
        if(row_c_rate==0):
            if((vol_c_rate_in<0.1)):
                quantized_c_rate=row_c_rate
                min_cell_temp_list.append(row_min_temp)
                max_voltage_list.append(row_max_v)
                voltage_ib_list.append(row_vol_ib)
                post_deration_c_rate_list.append(row_post_deration_c_rate)

        elif(abs((vol_c_rate_in - row_c_rate)/row_c_rate)<0.2):
            quantized_c_rate=row_c_rate
            min_cell_temp_list.append(row_min_temp)
            max_voltage_list.append(row_max_v)
            voltage_ib_list.append(row_vol_ib)
            post_deration_c_rate_list.append(row_post_deration_c_rate)
    
    if(len(min_cell_temp_list)==0):
        print_with_log("No data in algo voltage table for C rate: "+str(vol_c_rate_in)+" Test fail.")
        return vol_c_rate_in
    
    c_rate_out=quantized_c_rate
    vol_cutoff_val=get_interpolated_val(input_val=min_t,input_list=min_cell_temp_list,output_list=max_voltage_list)
    vol_ib_cutoff_val=get_interpolated_val(input_val=min_t,input_list=min_cell_temp_list,output_list=voltage_ib_list)
    post_der_c_rate_val=get_interpolated_val(input_val=min_t,input_list=min_cell_temp_list,output_list=post_deration_c_rate_list)

    ### condition for voltage cutoff
    if(max_v >= vol_cutoff_val):
        c_rate_out=post_der_c_rate_val
    ##### condition for voltage ib cutoff
    if(vol_ib >= vol_ib_cutoff_val):
        c_rate_out=post_der_c_rate_val

    return c_rate_out
    

def check_C_rate():
    global CMS_internal_can_dict,battery_capacity,c_rate_check,df_voltage_limits_normal
    global df_voltage_limits_chtz,df_min_temp_C_limits,df_max_temp_C_limits,ramp_up_flag
    global step_chnage_zero_current_flag
    
    exp_C_rate=0
    max_c_rate=5
    min_temp_c_rate=0
    max_temp_c_rate=0
    temp_c_rate=0
    voltage_in_c_rate=0
    voltage_out_c_rate=0
    delay_counter=0
    delay_flag=0 ## represents 5 sec zero current time
    err_count=0
    ramp_up_flag=0
    start_flag=1
    ramp_up_counter=0
    while(1):

        try:
            can_C_rate=CMS_internal_can_dict["set_current"]/battery_capacity

            # can_soc_user=ota_can_dict["SOC_User"]            
            # can_min_temp=ota_can_dict["Min_Cell_Temp"]
            # can_max_temp=ota_can_dict["Max_Cell_Temp"]
            # can_max_vol=ota_can_dict["Max_Cell_Voltage"]            
            # can_min_vol=ota_can_dict["Min_Cell_Voltage"]    

            can_soc_user=CMS_internal_can_dict["soc_user"]     
             
            can_min_temp=CMS_internal_can_dict["min_cell_temp_computed"]
            
            can_max_temp=CMS_internal_can_dict["max_cell_temp"]
            can_max_vol=CMS_internal_can_dict["max_cell_voltage"]
            
            can_min_vol=CMS_internal_can_dict["min_cell_voltage"]  
            


            can_cold_tank_t=10
            can_vol_ib=(can_max_vol-can_min_vol)*1000
            can_chtz_state=CMS_internal_can_dict["characterisation_profile"]
            

            if(c_rate_check==1):
                ## condition to use when in charge state
                if(CMS_internal_can_dict["algo_charge_completion_status"]==3):
                    ### if delay counter = 0, zero current period is done. start passing required current    
                    if(delay_counter==0):
                        step_chnage_zero_current_flag=0

                        ### after recovery delay, we expect new c rate
                        #### only useful first cycle after delay recovery
                        ### voltage_out_c_rate variable remembers the last c rate required
                        if(delay_flag==1):

                            #### start ramp up flag for the new C rate
                            if(exp_C_rate ==0 and voltage_out_c_rate!=0):
                                ramp_up_flag=1
                                ramp_up_counter=80 # 8sec ramp up timer
                                print_with_log("ramp time started for C rate: "+str(voltage_out_c_rate))
                            
                            exp_C_rate=voltage_out_c_rate

                            ### recover delay flag after remembered C rate is set
                            delay_flag=0

                        #### any normal case after 5 sec recovery
                        #### get new voltage_c_rate
                        else:
                            min_temp_c_rate=get_min_temp_c_rate(min_t=can_min_temp,soc_user=can_soc_user)
                            max_temp_c_rate=get_max_temp_c_rate(max_t=can_max_temp,soc_user=can_soc_user,cold_tank_t=can_cold_tank_t)
                            ### use minimum of two temp C rates
                            temp_c_rate=min(min_temp_c_rate,max_temp_c_rate)
                            ### max_c_rate reduces after voltage deration. this keeps c rate from jumping up again
                            v_in_c_rate=min(temp_c_rate,max_c_rate)

                            ### using set c rate during voltage ramp up or startup
                            ### always use set current for chtz step becausse the current offset does not matter
                            if(ramp_up_flag==1 or start_flag==1 or v_in_c_rate <0.3):
                                voltage_in_c_rate=CMS_internal_can_dict["set_current"]/battery_capacity                          
                            #### using actual current based C rate after ramp up
                            else:
                                voltage_in_c_rate=CMS_internal_can_dict["current_read"]/battery_capacity

                            #### send C rate in voltage table only if C rate >0.1
                            if(voltage_in_c_rate>0.1):
                                ### check if voltage cutoff is applicable for given max voltage and ib
                                voltage_out_c_rate=get_voltage_out_c_rate(vol_c_rate_in=voltage_in_c_rate,min_t=can_min_temp,
                                                                        max_v=can_max_vol,vol_ib=can_vol_ib,chtz_flag=can_chtz_state)
                                ### if voltage cutoff is happening, reduce max c rate
                                if(voltage_out_c_rate < voltage_in_c_rate):                                    
                                    max_c_rate=voltage_out_c_rate
                            
                            else:
                                #### use temp C rate only for lower C rates
                                voltage_out_c_rate = v_in_c_rate

                            #### no chnage condition
                            if(voltage_out_c_rate == exp_C_rate):
                                pass
                            else:
                                ###voltage downramp
                                if(voltage_out_c_rate < exp_C_rate):
                                    print_with_log("voltage downramp from "+str(voltage_in_c_rate)+
                                                    " to "+str(voltage_out_c_rate)+" at voltage: "+str(can_max_vol)+" IB: "+str(can_vol_ib))
                                    delay_counter=50                                    
                                    delay_flag=1
                                    step_chnage_zero_current_flag=1

                                #####  downramp due to temperature
                                elif(temp_c_rate < exp_C_rate):
                                    if(temp_c_rate == min_temp_c_rate):
                                        print_with_log("Temperature downramp from "+str(exp_C_rate)+ " to "+str(temp_c_rate)
                                                    + " due to min cell temp: "+str(can_min_temp))
                                    if(temp_c_rate == max_temp_c_rate):
                                        print_with_log("Temperature downramp from "+str(exp_C_rate)+ " to "+str(temp_c_rate)
                                                    + " due to max cell temp: "+str(can_max_temp))                                   

                                #### upramp due to temperature
                                elif(temp_c_rate > exp_C_rate):                             
                                    print_with_log("Temperature upramp from "+str(exp_C_rate)+ " to "+str(temp_c_rate)
                                                + "min temp: "+str(can_min_temp)+" max temp: "+str(can_max_temp))
                                    
                                    #### No delay at start of charge. delay for all transitions once started
                                    if(start_flag==0):
                                        delay_counter=50
                                        delay_flag=1
                                
                                #### start ramp up flag whenever going from 0 to any C rate
                                if(exp_C_rate == 0 and voltage_out_c_rate!=0):
                                    print_with_log("Starting ramp up time")
                                    ramp_up_flag=1
                                    ramp_up_counter=80 # 8sec ramp up timer

                                ### update new c rate in expected value
                                exp_C_rate = voltage_out_c_rate
                                start_flag=0

                    ### if delay counter !=0 , we need to set c rate to zero
                    else:
                        exp_C_rate=0
                
                else:
                    ramp_up_flag=0
                    exp_C_rate=0
                    max_c_rate=5
                    min_temp_c_rate=0
                    max_temp_c_rate=0
                    temp_c_rate=0
                    voltage_in_c_rate=0
                    voltage_out_c_rate=0
                    delay_counter=0
                    delay_flag=0
                    err_count=0
                    start_flag=1

                if(abs(exp_C_rate-can_C_rate)>0.1):
                    # print_with_log("C rate error. Exp C rate: "+str(exp_C_rate)+" CAN_C_rate: "+
                    #                str(can_C_rate)+" err count: "+str(err_count))
                    err_count=err_count+1
                else:
                    err_count=0  
                ### dont say fail for step gap
                if(exp_C_rate ==0):
                    if(err_count > 20):                        
                        print_with_log("C rate request fail. exp val: "+str(exp_C_rate)+ " CAN val: "+str(can_C_rate))
                else:
                    if(err_count > 5):                        
                        print_with_log("C rate request fail. exp val: "+str(exp_C_rate)+ " CAN val: "+str(can_C_rate))
        except Exception as e:
            print_with_log("C rate check err: "+str(e))
        
        sleep(0.1)

        ### delay counter calculations
        if(delay_counter!=0):
            delay_counter=delay_counter-1
        ### ramp up timer calculations
        if(ramp_up_flag==1):
            ramp_up_counter=ramp_up_counter-1
            if(ramp_up_counter==0):
                ramp_up_flag=0 ## reset flag after timer
                print_with_log("Ramp time completed. using sensor current")



check_C_rate_thread = Thread(target=check_C_rate)
check_C_rate_thread.start()

#endregion

#region version print
def print_version_info():
    global CMS_internal_can_dict
    master_swt_on()
    sleep(3)

    out_dict={"cms_fw_version_major":-1,
              "cms_fw_version_minor":-1,
              "cms_fw_version_bugfix":-1,
              "core1_fw_major":-1,
              "core1_fw_minor":-1,
              "core1_fw_bugfix":-1,
              "core2_fw_major":-1,
              "core2_fw_minor":-1,
              "core2_fw_bugfix":-1,
              "core1_fw_minor":-1,
              "core1_fw_minor":-1,
              "core1_fw_minor":-1,
              "core1_fw_minor":-1,
              "core1_fw_minor":-1}
    for k in out_dict.keys():
        try:
            out_dict[k]=CMS_internal_can_dict[k]
        except:
            pass
    
    print_with_log(out_dict)

#endregion

#region input_sanity_test functions

def check_thermistor_mapping():
    global temp_signal_map,CMS_internal_can_dict
    master_swt_on()
    sleep(5)
    for k in temp_signal_map.keys():
        if(k == "CON_WATER_INLET" or k== "CON_WATER_OUTLET"):
            set_temp(50,ref_res=2882)
        else:
            set_temp(50,ref_res=10000)
        print_with_log("Changing temperature for: "+str(k)+" with CAN msg : "+str(temp_can_signal_map[k])) 
        all_relay_states[k]=1
        sleep(5)
        can_t=CMS_internal_can_dict[temp_can_signal_map[k]]
        print_with_log(str(temp_can_signal_map[k])+" : "+str(can_t))
        if(abs(can_t-50)>10):
            print_with_log("Temp setting failed for: "+str(temp_can_signal_map[k]))
        else:
            print_with_log("Temp setting pass for: "+str(temp_can_signal_map[k]))

        all_relay_states[k]=0
        sleep(3)
    
    for k in temp_signal_map.keys():
        if(k == "CON_WATER_INLET" or k== "CON_WATER_OUTLET"):
            set_temp(25,ref_res=2882)
        else:
            set_temp(25,ref_res=10000)
        print_with_log("Changing temperature for: "+str(k)+" with CAN msg : "+str(temp_can_signal_map[k])) 
        all_relay_states[k]=1
        sleep(3)
        can_t=CMS_internal_can_dict[temp_can_signal_map[k]]
        print_with_log(str(temp_can_signal_map[k])+" : "+str(can_t))
        if(abs(can_t-25)>10):
            print_with_log("Temp setting failed for: "+str(temp_can_signal_map[k]))
        else:
            print_with_log("Temp setting pass for: "+str(temp_can_signal_map[k]))
        all_relay_states[k]=0
        sleep(3)

def check_temperature_range():
    global temp_signal_map,temp_can_signal_map,CMS_internal_can_dict
    master_swt_on()
    sleep(5)
    set_temp(25)
    for r in temp_can_signal_map.keys():
        all_relay_states[r]=1
    sleep(5)

    for t in range(-40,150,10):
        print_with_log("Setting temperature to: "+str(t))
        set_temp(t)
        sleep(5)
        print_temp_data()

def check_current_sensor():
    global CMS_internal_can_dict
    master_swt_on()
    sleep(5)
    for v in range(0,650,50):
        print_with_log("Setting current to: "+str(v))
        set_curr(v)
        sleep(10)
        # can_v=CMS_internal_can_dict["current_sensor_ch_2"]
        # can_adc=CMS_internal_can_dict["cs_ch_2"]
        can_curr_read=CMS_internal_can_dict["current_read"]
        if(abs(v-can_curr_read)>10):
            print_with_log("Current setting fail for: "+str(v))
        else:
            print_with_log("Current setting pass for: "+str(v))

        print_with_log("CAN current: "+str(can_curr_read))
        sleep(2)
    for v in range(0,-50,-10):
        print_with_log("Setting current to: "+str(v))
        set_curr(v)
        sleep(2)
        # can_v=CMS_internal_can_dict["current_sensor_ch_2"]
        # can_adc=CMS_internal_can_dict["cs_ch_2"]
        can_curr_read=CMS_internal_can_dict["current_read"]
        if(abs(v-can_curr_read)>10):
            print_with_log("Current setting fail for: "+str(v))
        else:
            print_with_log("Current setting pass for: "+str(v))
        print_with_log("CAN current: "+str(can_curr_read))
        sleep(2)

def check_pressure_sensor():
    global CMS_internal_can_dict
    master_swt_on()
    sleep(5)
    print_with_log("Checking pressure chnage for sensor 1")

    for v in range(0,11,1):
        set_pressure1(v)
        sleep(4)
        can_p1=CMS_internal_can_dict["drain_compressor_pressure"]
        can_p2=CMS_internal_can_dict["fluid_line_pressure"]
        if(abs(v-can_p2)>1):
            print_with_log("Pressure 1 setting fail for: "+str(v))
        else:
            print_with_log("Pressure 1 setting pass for: "+str(v))

        
        print_with_log("Drain comp press: "+str(can_p1)+" fluid pressure: "+str(can_p2))
        sleep(2)

    print_with_log("Checking pressure chnage for sensor 2")

    for v in range(0,11,1):
        set_pressure2(v)
        sleep(2)
        can_p1=CMS_internal_can_dict["drain_compressor_pressure"]
        can_p2=CMS_internal_can_dict["fluid_line_pressure"]
        if(abs(v-can_p1)>1):
            print_with_log("Pressure 2 setting fail for: "+str(v))
        else:
            print_with_log("Pressure 2 setting pass for: "+str(v))
        print_with_log("Drain comp press: "+str(can_p1)+" fluid pressure: "+str(can_p2))
        sleep(2)

def compare_can_data(can_signal_list,expected_data):
    global CMS_internal_can_dict
    r=True
    for i in range(len(expected_data)):
        if(CMS_internal_can_dict[can_signal_list[i]]!=expected_data[i]):
            r=False
    return r

def check_gpio_mapping():
    global CMS_internal_can_dict,correct_relay_state_flag
    master_swt_on()
    correct_relay_state_flag=0
    sleep(5)
    
    for k in relay_CAN_map.keys():     
        # if(k in ["gun_limit_switch"]):
        #     while(1):
        #         all_relay_states[k]=1      
        #         sleep(1)
        #         print_with_log("CAN msg: "+str(CMS_internal_can_dict[relay_CAN_map[k][0]]))
        #         sleep(1)
        #         all_relay_states[k]=0   
        #         sleep(1)
        #         print_with_log("CAN msg: "+str(CMS_internal_can_dict[relay_CAN_map[k][0]]))
        #         sleep(1)



            print_with_log("Checking GPIO for: "+str(k))  
            expected_can_list=[]
            can_signals=[]
            if("VALVE_FB" not in k): 
                can_signals.append(relay_CAN_map[k][0])           
                can_data=CMS_internal_can_dict[relay_CAN_map[k][0]]
                if("MCU_" not in k):
                    expected_can_list=[1]             
                else:
                    expected_can_list=[0]
            else:
                expected_can_list=[1,0]
                can_signals=[relay_CAN_map[k][0],relay_CAN_map[k][1]]
                
            
            print_with_log("Activating relay: "+str(k))
            all_relay_states[k]=1          
            st_time=timer()
            r=True
            while(compare_can_data(can_signals,expected_can_list)==False):
                sleep(0.1)
                print("waiting for activation of: "+str(k))
                if(timer()-st_time>10):
                    print_with_log("Activation timeout. Fail")
                    r=False
                    break
            if(r==True):
                print_with_log("Activation time: "+str(timer()-st_time)+" relay: "+str(k))

            out_dict={}
            for j in relay_CAN_map[k]:
                can_data=CMS_internal_can_dict[j]            
                out_dict[j]=can_data
            print_with_log(out_dict)
            

            expected_can_list=[]
            can_signals=[]
            if("VALVE_FB" not in k): 
                can_signals.append(relay_CAN_map[k][0])           
                can_data=CMS_internal_can_dict[relay_CAN_map[k][0]]
                if("MCU_" not in k):
                    expected_can_list=[0]             
                else:
                    expected_can_list=[1]
            else:
                expected_can_list=[0,1]
                can_signals=[relay_CAN_map[k][0],relay_CAN_map[k][1]]

            print_with_log("Deactivating relay: "+str(k))
            all_relay_states[k]=0
            st_time=timer()
            r=True
            while(compare_can_data(can_signals,expected_can_list)==False):
                sleep(0.1)
                print("waiting for deactivation of: "+str(k))
                if(timer()-st_time>10):
                    print_with_log("Deactivation timeout. Fail")
                    r=False
                    break
            if(r==True):
                print_with_log("Deactivation time: "+str(timer()-st_time)+" relay: "+str(k))

            out_dict={}
            for j in relay_CAN_map[k]:
                can_data=CMS_internal_can_dict[j]
                out_dict[j]=can_data
            print_with_log(out_dict)
     

def check_cp_activation():
    global CMS_internal_can_dict
    master_swt_on()
    sleep(5)
    cp_can_list=["cp_12_v","cp_6_v","cp_4_v"]
    update_cp_state(0)    
    sleep(2)
    for k in cp_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))
    if(CMS_internal_can_dict["cp_12_v"]==0 and CMS_internal_can_dict["cp_6_v"]==0 and CMS_internal_can_dict["cp_4_v"]==0):
        print_with_log("CP0 activation pass")
    else:
        print_with_log("CP0 activation fail")
    
    update_cp_state(12)
    sleep(2)
    for k in cp_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))
    if(CMS_internal_can_dict["cp_12_v"]==1 and CMS_internal_can_dict["cp_6_v"]==0 and CMS_internal_can_dict["cp_4_v"]==0):
        print_with_log("CP12 activation pass")
    else:
        print_with_log("CP12 activation fail")
    
    update_cp_state(6)    
    sleep(2)
    for k in cp_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))
    if(CMS_internal_can_dict["cp_12_v"]==0 and CMS_internal_can_dict["cp_6_v"]==1 and CMS_internal_can_dict["cp_4_v"]==0):
        print_with_log("CP6 activation pass")
    else:
        print_with_log("CP6 activation fail")

    update_cp_state(4)    
    sleep(2)
    for k in cp_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))
    if(CMS_internal_can_dict["cp_12_v"]==0 and CMS_internal_can_dict["cp_6_v"]==0 and CMS_internal_can_dict["cp_4_v"]==1):
        print_with_log("CP4 activation pass")
    else:
        print_with_log("CP4 activation fail")
    update_cp_state(0)
    for k in cp_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))

    print_with_log("Checking deactivation debouce for CP4V signal")
    update_cp_state(4)
    st_time=timer()
    while(CMS_internal_can_dict["cp_4_v"]==0):
        print_with_log("waiting for CP4V activation.")
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("CP4V activation timeout")
            break
    dur=timer()-st_time
    if(CMS_internal_can_dict["cp_4_v"]==1):
        print_with_log("CP4V activated in time: "+str(dur))
    else:
        print_with_log("CP4V not in activated state.test fail")
        return

    print_with_log("Checking non deactivation with fast toggle")
    for _ in range(10):
        update_cp_state(6)
        sleep(0.2)
        if(CMS_internal_can_dict["cp_4_v"]==0):
            print_with_log("CP4V deactivated.test fail")
            break
        update_cp_state(4)
        sleep(0.2)
        if(CMS_internal_can_dict["cp_4_v"]==0):
            print_with_log("CP4V deactivated.test fail")
            break
    
    update_cp_state(6)
    st_time=timer()
    while(CMS_internal_can_dict["cp_4_v"]==1):
        print_with_log("waiting for CP4V deactivation.")
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("CP4V deactivation timeout")
            break
    dur=timer()-st_time
    if(CMS_internal_can_dict["cp_4_v"]==0):
        print_with_log("CP4V activated in time: "+str(dur))
    else:
        print_with_log("CP4V not deactivated state.test fail")
        return


def check_battery_polarity_detection():
    global correct_relay_state_flag
    correct_relay_state_flag=0
    master_swt_on()
    sleep(5)
    global CMS_internal_can_dict,battrty_polarity_state
    polarity_can_list=["volt_detect_48_v","rev_volt_detect_48"]
    battrty_polarity_state=1
    print("changing polarity state to 1")
    sleep(10)  
    for k in polarity_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))
        
    
    if(CMS_internal_can_dict["volt_detect_48_v"]==1):
        print_with_log("48v detect activation pass")
    else:
        print_with_log("48v detect activation fail")

    battrty_polarity_state=2
    print("changing polarity state to 2")
    sleep(10)

    if(CMS_internal_can_dict["rev_volt_detect_48"]==1):
        print_with_log("48v rev detect activation pass")
    else:
        print_with_log("48v rev detect activation fail")
    for k in polarity_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))
    battrty_polarity_state=0
    print("changing polarity state to 0")
    sleep(10)
    if(CMS_internal_can_dict["rev_volt_detect_48"]==0 and CMS_internal_can_dict["volt_detect_48_v"]==0):
        print_with_log("48v non detect activation pass")
    else:
        print_with_log("48v non detect activation fail")

    for k in polarity_can_list:
        print_with_log(str(k)+" : "+str(CMS_internal_can_dict[k]))
    
def check_rectifier_readback():
    global CMS_internal_can_dict,rectifier_readback_values,correct_rectifier_flag,deactivate_rectifiers_num
    correct_rectifier_flag=0
    master_swt_on()
    sleep(5)
    for v in range(0,60,10):
        for i in range(0,40,10):
            rectifier_readback_values["voltage"]=v
            rectifier_readback_values["current"]=i
            sleep(8)
            print_with_log("Setting rectifier voltage: "+str(v)+" current: "+str(i))
            
            print_rectifier_rb_data(exp_v=v,exp_i=i)

    correct_rectifier_flag=1
    sleep(2)
    
    print_with_log("Checking rectifier deactivation logic")
    for i in range(13):
        print_with_log("Number of rectifiers deactivated: "+str(i))
        deactivate_rectifiers_num=i
        sleep(5)
        act_rect_count_can=CMS_internal_can_dict["active_rectifiers"]
        rectifier_voltage_read=CMS_internal_can_dict["voltage_read"]
        set_v=CMS_internal_can_dict["set_voltage"]
        rect_comm_status= CMS_internal_can_dict["rect_can_status"]

        exp_act_count=12-deactivate_rectifiers_num
        exp_rect_comm_status= 1
        if(i>0):
            exp_rect_comm_status= 0



        print_with_log("Expected rect_status: "+str(exp_rect_comm_status)+" Rect_comm_status: "+str(rect_comm_status))
        print_with_log("Expected active count: "+str(exp_act_count)+" CAN_active_rect_count: "+str(act_rect_count_can))
        print_with_log("Set voltage: "+str(set_v)+" Read_voltage: "+str(rectifier_voltage_read))

        if(exp_act_count == act_rect_count_can):
            print_with_log("Activated rectifier count as expected. Test pass")
        else:
            print_with_log("Activated rectifier count not as expected. Test fail")
        
        if(set_v == rectifier_voltage_read):
            print_with_log("Rectifier voltage as expected. Test pass")
        else:
            print_with_log("Rectifier voltage not as expected. Test fail")

        if(exp_rect_comm_status == rect_comm_status):
            print_with_log("Rectifier comm status as expected. Test pass")
        else:
            print_with_log("Rectifier comm status not as expected. Test fail")
 

def check_chiller_readback():
    global chiller_data,change_chiller_flag
    master_swt_on()
    sleep(5)
    print_with_log("Updating chiller data")
    change_chiller_flag=1
    
    for k in chiller_data.keys():   
        if(k in ["chiller_aft_temp","chiller_liquid_temp","chiller_room_temp",
                "chiller_set_high_set","chiller_set_low_set","chiller_set_set_point",
                "chiller_set_differential","chiller_set_high_temp_alarm",
                "chiller_set_low_temp_alarm","chiller_set_aft_set_temp",
                "chiller_set_aft_differential"]):            
            set_values=[-20,-10,0,10,20,30,40,50,60,80,100,110,120]
        elif( k == "chiller_remote_start"):            
            set_values=[1,0,2]    
        else:
            set_values=[1,0] 

        print_with_log("Checking chiller readback for: "+str(k))
        try:
            if(k in ["chiller_room_temp","chiller_set_high_set","chiller_set_low_set","chiller_set_high_temp_alarm",
                    "chiller_set_low_temp_alarm","chiller_set_aft_differential"]):
                print_with_log("Data not in can to check.skipping")
                continue
            else:
                if(k == "chiller_set_set_point"):
                    can_sig_name="chiller_set_point"
                elif(k  == "chiller_set_differential"):
                    can_sig_name="chiller_differential"
                elif(k == "chiller_set_aft_set_temp"):
                    can_sig_name="chiller_aft_set_temperature"
                else:
                    can_sig_name=k
            i=0
            for s in set_values:
                i=i+1
                print_with_log("Setting value to : "+str(s))
                chiller_data[k]=s
                sleep(10)
                if(can_sig_name!=""):
                    print_with_log("CAN value for "+str(k)+" : "+str(CMS_internal_can_dict[can_sig_name]))
                    if(s!=CMS_internal_can_dict[can_sig_name]):
                        print_with_log("Chiller setting failed")
                    else:
                        print_with_log("Chiller setting pass")
        except Exception as e:
            print_with_log("CHiller check error: "+str(e))
                    

            

    chiller_data["chiller_liquid_temp"]=10
    

    change_chiller_flag=0

def check_heater_readback():
    global heater_data,relay_encoded_list,fault_encoded_list
    master_swt_on()
    sleep(5)
    
    
    for k in heater_data.keys():  
        if(k not in ["heater_fault_condition_when_probe_fail","heater_relay_min_on_time",
                     "heater_high_temp_alarm_diff","heater_low_temp_alarm_diff"]):                  
            if(k not in relay_encoded_list and k not in fault_encoded_list):            
                set_values=[-20,-10,0,10,20,30,40,50,60,100,110,120,150]
            else:            
                set_values=[1,0]        
            print_with_log("Checking heater readback for: "+str(k))        
            can_sig_name=k        
            for s in set_values:   
                print_with_log("Setting value to : "+str(s))     
                try:    
                    heater_data[k]=s            
                    sleep(10)
                    if(can_sig_name!=""):
                        print_with_log("CAN value for "+str(k)+" : "+str(CMS_internal_can_dict[can_sig_name]))                
                        if(s!=CMS_internal_can_dict[can_sig_name]):
                            print_with_log("Heater setting failed")
                        else:
                            print_with_log("Heater setting pass")
                except Exception as e:
                    print_with_log("Heater check err: "+str(e))
        

def check_EM_readback():
    global EM_data_dict,CMS_internal_can_dict,EM_data_dict_base
    master_swt_on()
    sleep(5)
    print_with_log("Checking Energy meter readback")
    
    
    for k in EM_data_dict.keys():        
        if(k in ["em_power_factor_b_phase","em_power_factor_y_phase","em_power_factor_r_phase","em_power_factor_avg"]):            
            set_values=[0,0.5,0.8,1,5,10,50,60]
        elif(k in ["em_frequency"]):            
            set_values=[0,10.5,35.6,50.8,60.2] 
        else:
            set_values=[0,10.5,35.6,50.8,60.2,100,200,300,600] 

        print_with_log("Checking EM readback for: "+str(k))
        can_sig_name=k

        i=0
        for s in set_values:
            i=i+1
            print_with_log("Setting value to : "+str(s))
            EM_data_dict[k]=s
            sleep(10)
            if(can_sig_name!=""):
                print_with_log("CAN value for "+str(k)+" : "+str(CMS_internal_can_dict[can_sig_name]))
                if(abs(s-CMS_internal_can_dict[can_sig_name])>0.2):
                    print_with_log("EM setting failed")
                else:
                    print_with_log("EM setting pass")
        
        for k in EM_data_dict.keys():
            EM_data_dict[k]=EM_data_dict_base[k]

def compare_CI_rectifier_BMS_data(bms_msg,bms_signal,cms_msg,step,step_no,allowed_delay=1, timeout=5):
    global CMS_internal_can_dict,BMS_sent_CAN_msg
    print_with_log("Checking changes in "+str(cms_msg))
    v=0
    r=1
    for _ in range(step_no):
        v=v+step        
        BMS_sent_CAN_msg[bms_msg][bms_signal]=v        
        st_time=timer()
        while((abs(CMS_internal_can_dict[cms_msg]-v)/v) >0.01):
            sleep(0.1)
            if(timer()-st_time>timeout):
                print_with_log(str(cms_msg)+" Value not update after 5 sec. Test fail. val: "+str(v))
                r=0
                break
        delay=timer()-st_time
        if((abs(CMS_internal_can_dict[cms_msg]-v)/v) <= 0.01):
            print_with_log(str(cms_msg)+ " data updated updated in time: "+str(delay))
        if(delay>allowed_delay):
            print_with_log("Test fail")
            r=0
    if(r==1):
        print_with_log(str(cms_msg)+" CI can data update pass")
    reset_BMS_data()

def check_BMS_can_datarate():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Checking BMS CAN data chnage test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    update_ulock_status(1)
    
    
    compare_CI_rectifier_BMS_data(bms_msg="Min_Max_IB_Pack_Voltage",bms_signal="Max_Cell_Voltage",
                                  cms_msg="max_cell_voltage",step=0.1,step_no=40,allowed_delay=1, timeout=30)

    
    compare_CI_rectifier_BMS_data(bms_msg="Min_Max_IB_Temp",bms_signal="Max_Cell_Temp",
                                  cms_msg="max_cell_temp",step=1,step_no=60,allowed_delay=1, timeout=30)


    
    
    print_with_log("Checking changes in solenoid_fb")
    r=1
    v=0
    for _ in range(20):
        if(v==0):
            v=1
        else:
            v=0
        emulate_solenoid_fb(v)
        st_time=timer()
        while(CMS_internal_can_dict["sol_fb"]!=v):
            sleep(0.1)
            if(timer()-st_time>5):
                print_with_log("sol value not update after 5 sec. Test fail. val: "+str(v))
                r=0
                break
        delay=timer()-st_time
        if(CMS_internal_can_dict["sol_fb"]==v):
            print_with_log("data updated updated in time: "+str(delay))
        if(delay>1):
            print_with_log("Test fail")
            r=0
    if(r==1):
        print_with_log("sol FB updated within 1 sec pass")
    reset_BMS_data()




    
#endregion


#region OTC tests
# 400000809 : 3 5 3 : cal age days: 100
# 400000420 : 3 5 3 : charge profile 10.1
# 400000174 : 3 5 5
# 400000327 : 3 5 3 blacklist



def check_ota_start(exp_appl_ack=187,bl_hb_flag=1):
    global ota_can_dict,bms_send_flag,send_bl_heartbeat_flag
    
    st_time=timer()
    ota_can_dict["cms_file_progress"]=0
    ota_can_dict["otc_retry_count"]=0
    CMS_internal_can_dict["bms_ota_req"]=0
    CMS_internal_can_dict["bms_ota_cmd"]=0

    display_msg_dict={}
    st_time=timer()
    while(CMS_internal_can_dict["bms_ota_req"]!=10):
        # print_with_log("waiting for OTC request from CMS")
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("OTC request timeout.Test fail")
            return False
    
    print_with_log("CMS sent OTC request command")
    sleep(1)
    st_time=timer()
    while(CMS_internal_can_dict["bms_ota_cmd"]==0):
        print_with_log("Waiting for display OTC_cmd")
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("OTC command timeout.Test fail")
            break

    cmd_rec= CMS_internal_can_dict["bms_ota_cmd"]       
    print_with_log("Received OTC command from CMS: "+str(cmd_rec))
    sleep(0.3)
    appl_cmd=CMS_internal_can_dict["appl_fw_check_ack"]
    if(exp_appl_ack == 0 and appl_cmd ==0):
        print_with_log("No cmd from display pass")
        return True
    if(appl_cmd!=0 and appl_cmd!=-1):
        send_bl_heartbeat_flag=0
        bms_send_flag=1
        if(appl_cmd==exp_appl_ack):
            if(exp_appl_ack==10):                                
                if(cmd_rec==10 and bl_hb_flag==1):
                    r=check_for_jump_to_bl_command()
                    if(r==False):
                        print_with_log("Did not receive jump to bl command.test fail")
                        return False
                    else:
                        print_with_log("BMS received Jump to bootloader command. Stopping BMS application CAN messsages")                    
                    send_bl_jump_ack()
                    go_to_init_inti_state()
                    start_bl_HB()
                    sleep(0.5)
                print_with_log("OTC started.Test pass")
                return True
            if(exp_appl_ack==160):
                print_with_log("Image check fail.Required image not available in CMS.Test pass")
                return True
            if(exp_appl_ack==187):
                print_with_log("Cloud responded with no OTC required.Test pass")
                return True 
        else:
            print_with_log("Rec cmd: "+str(appl_cmd)+" Exp cmd: "+str(exp_appl_ack)+" Test fail")
            return False
    else:
        print_with_log("APPL_fw_cmd not updating.Test fail")
        return False

def check_blacklisting(exp_cmd=10):
    global CMS_internal_can_dict
    st_time=timer()
    while(CMS_internal_can_dict["bms_black_list_cmd"]==0):
        print_with_log("waiting for blacklisting response")
        sleep(1)
        if(timer()-st_time>15):
            print_with_log("blacklisting cmd timeout.test fail")
            return False
    
    if(CMS_internal_can_dict["bms_black_list_cmd"] == exp_cmd):
        if(exp_cmd==10):
            print_with_log("No blacklisted as expected. Test pass")
            return True
        if(exp_cmd==160):
            print_with_log("Blacklisted as expected. Test pass")
            return True
    else:
        print_with_log("Blacklisting command not as expected.Test fail. rec cmd: "+str(CMS_internal_can_dict["bms_black_list_cmd"]))
        return False

def check_no_display_response():
    global bms_send_flag,correct_current_flag,correct_relay_state_flag
    error_name="BMS_OTA_Cloud_Display_No_Response"
    i=int(input("Enter 1 after turning off internet: "))
    if(i==1):
        correct_current_flag=1
        correct_relay_state_flag=1
        print_with_log("Starting normal OTC test")
        change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_patch=0)
        change_BMS_unique_id_for_otc(val=400000809)
        
        print_with_log("master on")
        master_swt_on()
        sleep(5)   
             
        print_with_log("Emulating CP6")
        update_cp_state(6)
        sleep(3)
        print_with_log("Starting BMS data sending")
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
        bms_send_flag=1    
        update_cp_state(4)    
        if(CMS_version==4.2):
            emulate_gun_lock()
        
        r=check_ota_start(exp_appl_ack=0)
        if(r==False):
            print_with_log("No display cmd pass")
        else:
            print_with_log("No display cmd fail")
        if(CMS_version==4.0):
            emulate_gun_lock()
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")            
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("No charge. test fail")
                update_cp_state(6)
                bms_send_flag=0
                master_swt_off()
                sleep(5) 
                return False
                
        sleep(5)
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
        print_with_log("Charging started. Test pass")

        if(fault_dict_new[error_name]==1):
            print_with_log("fault activation pass")
        else:
            print_with_log("fault activation fail")
        
        res=evaluate_protection_state(
            input_power_protection_status=1,
            output_power_protection_status=1,
            fcs_heating_protection_status=1,
            e_plug_protection_status=1,
            bms_protection_status=1,
            charging_algo_protections_status=1,
            fcs_cooling_protection_status=1,
            fcs_int_cooling_prot_status=1
        )
        if(res==True):
            print_with_log("Protection ok as expected.test pass")
        else:
            print_with_log("Protection ok not as expected.test fail")
        print_protection_status()

        compare_fault_code_structure()
        check_master_session_code(error_name)
        check_display_activity_id(type="protection",name=error_name) 
        

        emulate_solenoid_fb(0)
        sleep(3)
        update_cp_state(6)
        st_time=timer()
        while(CMS_internal_can_dict["e_plug_interaction_state"]>=2):
            print_with_log("waiting for eplug interation status to change")
            sleep(1)
            if(timer()-st_time>10):
                print_with_log("Eplug state not changing")
                break
        sleep(1)
        if(fault_dict_new[error_name]==0):
            print_with_log("fault deactivation pass")
        else:
            print_with_log("fault deactivation fail")
        check_master_error_code_reset()
        bms_send_flag=0
        master_swt_off()
        sleep(5)     

def check_otc_response_from_display():
    global CMS_internal_can_dict,fault_dict_new
    # j=int(input("Enter 1 after flashing OSM 3.5.3 FW with fut: "))
    j=1
    if(j):
        while(1):
            try:

                # system_reset(HW_version=21,FW_version=850,cycle_count=67)
                while(fault_dict_new["Unauthorized_GUN_Removal"]==1):
                    print_with_log("unauthorized gun removal error.")
                    sleep(5)
                
                sleep(10)
                check_normal_otc()   
            
                # system_reset(HW_version=21,FW_version=850,cycle_count=67)          
                    
                while(fault_dict_new["Unauthorized_GUN_Removal"]==1):
                    print_with_log("unauthorized gun removal error.")
                    sleep(5)

                sleep(10)
                check_direct_charge_latest_fw()
            except:
                pass
            
            # system_reset(HW_version=21,FW_version=850,cycle_count=67)
    

def check_otc_flasher_err():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,bl_timeout_err_flag,send_bl_heartbeat_flag
    print_with_log("Checking OTC flasher error and reattempt")
    error_name="BMS_OTA_Flasher_Error"
    bl_timeout_err_flag = 0

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting normal OTC test")
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_patch=0)
    change_BMS_unique_id_for_otc(val=400000809)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
     
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=1    
    update_cp_state(4)    
    print_with_log("Emulating CP4")  
    if(CMS_version==4.2):
        emulate_gun_lock()

    r=check_ota_start(exp_appl_ack=10)
    if(r==True):
        print_with_log("Normal OTC start pass")
    else:
        print_with_log("Normal OTC start fail")
    
    attemp_count=0
    while(1):
        st_time=timer()
        while(fault_dict_new[error_name]==0):
            print_with_log("waiting for flasher error activation")
            sleep(1)
            if(timer()-st_time>10):
                print_with_log("no error activation. timeout")
                break
        
        if(fault_dict_new[error_name]==1):
            print_with_log(str(error_name)+" activation pass")
            print_with_log("ota attempt counter: "+str(CMS_internal_can_dict["bms_ota_attempt_count"]))
        
        st_time=timer()
        ### wait for display to show reconnect gun screen
        while(CMS_internal_can_dict["cms_ui_activity_id"] != 69):
            print_with_log("waiting for reattempt screen")
            sleep(1)
            if(timer()-st_time> 20):
                print_with_log("Reattemp screen not shown.test fail")
                break
        print("Doing gun reconnect.")
        update_cp_state(6)
        bms_send_flag=0
        send_bl_heartbeat_flag=0
        sleep(5)
        update_cp_state(4)
        bms_send_flag=0
        send_bl_heartbeat_flag=1
        sleep(5)

        r=check_ota_start(exp_appl_ack=10)
        if(r==True):
            print_with_log("Normal OTC start request pass")
        else:
            print_with_log("Normal OTC start request fail")
        
        st_time=timer()
        ### wait for display to show immobilized screen
        while(CMS_internal_can_dict["cms_ui_activity_id"] != 68):
            print_with_log("waiting for immobilized screen")
            sleep(1)
            if(timer()-st_time> 10):
                print_with_log("Reattemp screen not shown.test fail")
                break
        if(CMS_internal_can_dict["cms_ui_activity_id"] == 68):
            print_with_log("got immobilized screen.Test pass")
            sleep(2)
            if(fault_dict_new["BMS_OTA_Attempts_Exhausted"]==1):
                print_with_log("OTC attempt exhaused fault trigger pass")
            else:
                print_with_log("OTC attempt exhaused fault trigger fail")
            break

        attemp_count+=1
        if(attemp_count>4):
            print_with_log("No immobilized screen after 4 attempts.Test fail")
            break


    
    bms_send_flag=0
    send_bl_heartbeat_flag=0

    master_swt_off()
    sleep(5)    


# def check_otc_flasher_timeout_err():
#     global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
#     global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,bl_timeout_err_flag,send_bl_heartbeat_flag
#     print_with_log("Checking OTC flasher timeout error")
#     error_name="BMS_OTA_Attempt_Timeout"
#     bl_timeout_err_flag = 1

#     correct_current_flag=1
#     correct_relay_state_flag=1
#     print_with_log("Starting normal OTC test")
#     change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_patch=0)
#     change_BMS_unique_id_for_otc(val=400000809)
    
#     print_with_log("master on")
#     master_swt_on()
#     sleep(5)    
     
        
#     print_with_log("Emulating CP6")
#     update_cp_state(6)
#     sleep(3)
#     print_with_log("Starting BMS data sending")
#     BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
#     bms_send_flag=1    
#     update_cp_state(4)    
#     print_with_log("Emulating CP4")  
#     if(CMS_version==4.2):
#         emulate_gun_lock() 

#     r=check_ota_start(exp_appl_ack=10)
#     if(r==True):
#         print_with_log("Normal OTC start pass")
#     else:
#         print_with_log("Normal OTC start fail")
    
#     attemp_count=0
#     while(1):
#         st_time=timer()
#         c=0
#         while(fault_dict_new[error_name]==0):
#             print_with_log("waiting for flasher error activation count: "+str(c))
#             c+=1
#             sleep(1)
#             if(timer()-st_time>500):
#                 print_with_log("no error activation. timeout")
#                 break
        
#         if(fault_dict_new[error_name]==1):
#             print_with_log(str(error_name)+" activation pass")
#             print_with_log("ota attempt counter: "+str(CMS_internal_can_dict["bms_ota_attempt_count"]))
        
#         st_time=timer()
#         ### wait for display to show reconnect gun screen
#         while(CMS_internal_can_dict["cms_ui_activity_id"] != 69):
#             print_with_log("waiting for reattempt screen")
#             sleep(1)
#             if(timer()-st_time> 20):
#                 print_with_log("Reattemp screen not shown.test fail")
#                 break

#         update_cp_state(6)
#         bms_send_flag=0
#         sleep(5)
#         update_cp_state(4)
#         bms_send_flag=1
#         sleep(5)

#         r=check_ota_start(exp_appl_ack=10)
#         if(r==True):
#             print_with_log("Normal OTC start request pass")
#         else:
#             print_with_log("Normal OTC start request fail")
        
#         st_time=timer()
#         ### wait for display to show immobilized screen
#         while(CMS_internal_can_dict["cms_ui_activity_id"] != 68):
#             print_with_log("waiting for immobilized screen")
#             sleep(1)
#             if(timer()-st_time> 10):
#                 print_with_log("Reattemp screen not shown.test fail")
#                 break
#         if(CMS_internal_can_dict["cms_ui_activity_id"] == 68):
#             print_with_log("got immobilized screen.Test pass")
#             sleep(2)
#             if(fault_dict_new["BMS_OTA_Attempts_Exhausted"]==1):
#                 print_with_log("OTC attempt exhaused fault trigger pass")
#             else:
#                 print_with_log("OTC attempt exhaused fault trigger fail")
#             break

#         attemp_count+=1
#         if(attemp_count>4):
#             print_with_log("No immobilized screen after 4 attempts.Test fail")
#             break


    
#     bms_send_flag=0
#     send_bl_heartbeat_flag=0
#     bl_timeout_err_flag = 0
    
#     master_swt_off()
#     sleep(5)    

def check_bl_hb_timeout():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg
    
    error_name="BMS_OTA_Bootloader_Start_Fail"

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting check_bl_hb_timeout")
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_patch=0)
    change_BMS_unique_id_for_otc(val=400000420)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
     
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=1    
    update_cp_state(4)    
    print_with_log("Emulating CP4")  
    if(CMS_version==4.2):
        emulate_gun_lock()

    r=check_ota_start(exp_appl_ack=10,bl_hb_flag=0)
    if(r==True):
        print_with_log("Normal OTC start request pass")
    else:
        print_with_log("Normal OTC start request fail")
    if(CMS_version==4.0):
        emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("No charge. test fail")
            update_cp_state(6)
            bms_send_flag=0
            master_swt_off()
            sleep(5) 
            return False
            
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_with_log("Charging started. Test pass")

    if(fault_dict_new[error_name]==1):
        print_with_log("fault activation pass")
    else:
        print_with_log("fault activation fail")
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(res==True):
        print_with_log("Protection ok as expected.test pass")
    else:
        print_with_log("Protection ok not as expected.test fail")
    print_protection_status()

    compare_fault_code_structure()
    check_master_session_code(error_name)
    check_display_activity_id(type="protection",name=error_name) 
    

    gun_remove_function()
    sleep(1)
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    master_swt_off()
    sleep(5)    

def check_direct_charge_latest_fw():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg
    print_with_log("Checking direct charge latest fw")
    error_name="BMS_OTA_Don't_Do_Cmd"
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting direct_charge_latest_fw test")
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=3,oem_patch=0)
    change_BMS_unique_id_for_otc(val=400000420)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
       
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=1    
    update_cp_state(4)    
    print_with_log("Emulating CP4")  

    if(CMS_version==4.2):
        emulate_gun_lock()

    r=check_ota_start(exp_appl_ack=187)

    if(CMS_version==4.0):
        emulate_gun_lock()

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("no fault activation. timeout")
            break

    if(fault_dict_new[error_name]==1):
        print_with_log("fault activation pass")
    else:
        print_with_log("fault activation fail")
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(res==True):
        print_with_log("Protection ok as expected.test pass")
    else:
        print_with_log("Protection ok not as expected.test fail")
    print_protection_status()
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    check_display_activity_id(type="protection",name=error_name) 
    if(r==False):
        update_cp_state(6)
        bms_send_flag=0
        gun_remove_function()
        # master_swt_off()
        sleep(5) 
        return False
    
    if(CMS_version==4.0):
        emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        # print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
            
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_with_log("Charging started. Test pass")
    
    

    emulate_solenoid_fb(0)
    sleep(3)
    update_cp_state(6)
    gun_remove_function()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    # master_swt_off()
    sleep(5)    


def check_direct_charge_bms_id():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg
    

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting check_direct_charge_bms_id OTC test")
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_patch=0)
    change_BMS_unique_id_for_otc(40001)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=1    
    update_cp_state(4)   
    if(CMS_version==4.2):
        emulate_gun_lock()

    r=check_ota_start(exp_appl_ack=187)
    if(r==False):
        update_cp_state(6)        
        gun_remove_function()
        master_swt_off()
        sleep(5) 
        return False
    
            
    if(CMS_version==4.0):
        emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
            
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_with_log("Charging started. Test pass")
    check_master_error_code_reset()

    emulate_solenoid_fb(0)
    sleep(3)
    update_cp_state(6)    
    gun_remove_function()
    master_swt_off()
    sleep(5)    


def check_direct_charge_fw_not_available():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,fault_dict_new
    

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting direct_charge_not_available OTC test")
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=4,oem_patch=0)
    change_BMS_unique_id_for_otc(val=400000174)
    error_name="BMS_OTA_Target_Image_Unavailable"
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=1    
    update_cp_state(4)    
    print_with_log("Emulating CP4")  
    if(CMS_version==4.2):
        emulate_gun_lock()

    r=check_ota_start(exp_appl_ack=160)
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("no fault activation. timeout")
            break
    if(CMS_version==4.0):
        emulate_gun_lock()

    if(fault_dict_new[error_name]==1):
        print_with_log("fault activation pass")
    else:
        print_with_log("fault activation fail")
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(res==True):
        print_with_log("Protection ok as expected.test pass")
    else:
        print_with_log("Protection ok not as expected.test fail")
    print_protection_status()

    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_with_log("Charging started. Test pass")

    compare_fault_code_structure()
    check_master_session_code(error_name)
    check_display_activity_id(type="protection",name=error_name) 

    if(r==False):
        update_cp_state(6)        
        gun_remove_function()
        master_swt_off()
        sleep(5) 
        return False
    
            
    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    
            
    sleep(5)
    
    
    
    


    emulate_solenoid_fb(0)
    sleep(3)
    update_cp_state(6)
    gun_remove_function()

    st_time=timer()
    while(CMS_internal_can_dict["e_plug_interaction_state"]>=2):
        print_with_log("waiting for eplug interation status to change")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("Eplug state not changing")
            break
    sleep(1)
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    master_swt_off()
    sleep(5)    


def check_no_charge_blacklisted_veh():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg
    
    error_name="Vehicle blacklisted"
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting no charge for blacklisted vehicle test")
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=3,oem_patch=0)
    change_BMS_unique_id_for_otc(400000327)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=1    
    update_cp_state(4)    
    print_with_log("Emulating CP4")  
    if(CMS_version==4.2):
        emulate_gun_lock()
    
   
    r= check_blacklisting(exp_cmd=160)
    

    if(r==False):
        update_cp_state(6)
        bms_send_flag=0
        master_swt_off()
        sleep(5) 
        gun_remove_function()
        return False
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("no fault activation. timeout")
            break

    if(fault_dict_new[error_name]==1):
        print_with_log("fault activation pass")
    else:
        print_with_log("fault activation fail")
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(res==True):
        print_with_log("Protection ok as expected.test pass")
    else:
        print_with_log("Protection ok not as expected.test fail")
    print_protection_status()
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    check_display_activity_id(type="protection",name=error_name) 

      
    if(CMS_version==4.0):
        emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("No charge. test Pass")
            update_cp_state(6)
            st_time=timer()
            while(CMS_internal_can_dict["e_plug_interaction_state"]>=2):
                print_with_log("waiting for eplug interation status to change")
                sleep(1)
                if(timer()-st_time>10):
                    print_with_log("Eplug state not changing")
                    break
            sleep(1)
            if(fault_dict_new[error_name]==0):
                print_with_log("fault deactivation pass")
            else:
                print_with_log("fault deactivation fail")
            check_master_error_code_reset()
            gun_remove_function()
            bms_send_flag=0
            master_swt_off()
            sleep(5) 
            return False
            
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_with_log("Charging started. Test fail")
    

    emulate_solenoid_fb(0)
    sleep(3)
    update_cp_state(6)
    gun_remove_function()
    bms_send_flag=0
    sleep(3)
    change_BMS_unique_id_for_otc(4000001)
    master_swt_off()
    sleep(5)    


def check_charge_non_blacklisted_veh():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg
    

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting charge_non_blacklisted_veh test")
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=3,oem_patch=0)
    change_BMS_unique_id_for_otc(val=400000420)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=1    
    update_cp_state(4)    
    print_with_log("Emulating CP4")  
    if(CMS_version==4.2):
        emulate_gun_lock()

    
    
    r=check_ota_start(exp_appl_ack=187)
    if(r==False):
        update_cp_state(6)
        
        gun_remove_function()
        master_swt_off()
        sleep(5) 
        return False
    r= check_blacklisting(exp_cmd=10)
    if(r==False):
        update_cp_state(6)
        
        gun_remove_function()
        master_swt_off()
        sleep(5) 
        return False

   
    if(CMS_version==4.0):
        emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("charge timeout. test fail")
            update_cp_state(6)
            bms_send_flag=0
            master_swt_off()
            sleep(5) 
            return False
            
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_with_log("Charging started. Test pass")
    

    emulate_solenoid_fb(0)
    sleep(3)
    update_cp_state(6)
    gun_remove_function()
    bms_send_flag=0
    master_swt_off()
    sleep(5)    

def check_ota_with_only_bootloader_FW_available():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global send_bl_heartbeat_flag,bms_send_flag
    print_with_log("check_ota_with_only_bootloader with FW available")
    error_name="BMS_OTA_Flasher_Error"
    bl_timeout_err_flag = 0

    correct_current_flag=1
    correct_relay_state_flag=1
    
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_patch=0,oem_lookup=0,oem_var=0,hw_major=2,hw_minor=1)
    change_BMS_unique_id_for_otc(val=400000809)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
     
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting bootloader data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=0
    send_bl_heartbeat_flag=1

    update_cp_state(4)    
    print_with_log("Emulating CP4")  
    if(CMS_version==4.2):
        emulate_gun_lock()

    r=check_ota_start(exp_appl_ack=10)
    if(r==True):
        print_with_log("Normal OTC start pass. OTA with only bootloader")
    else:
        print_with_log("Normal OTC start fail")
    
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for flasher error activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("no error activation. timeout")
            break
    
    if(fault_dict_new[error_name]==1):
        print_with_log(str(error_name)+" activation pass")
        print_with_log("ota attempt counter: "+str(CMS_internal_can_dict["bms_ota_attempt_count"]))

    emulate_solenoid_fb(0)
    sleep(3)
    update_cp_state(6)
    gun_remove_function()
    bms_send_flag=0
    send_bl_heartbeat_flag=0
    master_swt_off()
    sleep(5)    


def check_ota_with_only_bootloader_FW_not_available():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global send_bl_heartbeat_flag,bms_send_flag
    print_with_log("check_ota_with_only_bootloader with FW not available")
    error_name="BMS_OTA_Target_Image_Unavailable"
    bl_timeout_err_flag = 0

    correct_current_flag=1
    correct_relay_state_flag=1
    
    change_BMS_fw_ver_for_otc(maj=3,min=5,patch=2,oem_patch=0,oem_lookup=4,oem_var=0,hw_major=2,hw_minor=2)
    change_BMS_unique_id_for_otc(val=400000809)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
     
        
    print_with_log("Emulating CP6")
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting bootloader data sending")
    BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
    bms_send_flag=0
    send_bl_heartbeat_flag=1

    update_cp_state(4)    
    print_with_log("Emulating CP4")  
    if(CMS_version==4.2):
        emulate_gun_lock()

    r=check_ota_start(exp_appl_ack=160)
    if(r==True):
        print_with_log("No FW available pass")
    else:
        print_with_log("No FW available  fail")
    
    sleep(5)
    if(get_display_activity_id() != 68):
        print_with_log("No immobilized screen after no FW available. test fail")
    else:   
        print_with_log("Got immobilized screen after no FW available. test pass")
    st_time=timer()
    while(1):
        if(timer()-st_time>200):
            break
    
    emulate_solenoid_fb(0)
    sleep(3)
    update_cp_state(6)
    gun_remove_function()
    bms_send_flag=0
    send_bl_heartbeat_flag=0
    master_swt_off()
    sleep(5)   

        



#endregion

#region new_structure protection_functions

#region input grid

def spd_fault_protection_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    print_with_log("Starting spd protection test")
    print_protection_status()
    
    if(CMS_internal_can_dict["input_power_protection_status"]==1 and fault_dict_new["SPD Fault"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        print(fault_dict_new)
        return

    
    print_with_log("Activating SPD fault")
    all_relay_states["MCU_SPD_CB"]=0
    st_time=timer()
    while(fault_dict_new["SPD Fault"]==0):
        print_with_log("waiting for fault activation. val_new: "+str(fault_dict_new["SPD Fault"])+" val_old: "+str(fault_dict_old["SPD Fault"]))
        sleep(0.1)
        if(timer()-st_time>5):
            print_with_log("Fault activation timeout. Test fail")
            break
    dur=timer()-st_time

    # print(fault_dict_new["SPD Fault"])
    
    if(fault_dict_new["SPD Fault"]==1):
        print_with_log("Fault activation pass in time: "+str(dur))
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")        
        return
    sleep(1)

    compare_fault_code_structure()
    check_master_session_code("SPD Fault")

    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
        check_display_activity_id(type="protection",name="SPD Fault")
        display_check=1

    print_protection_status()
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1,
        drain_prot_status=1,
    )
    if(res==True):
        print_with_log("Protection ok as expected.Pass")
    else:
        print_with_log("Protection ok not as expected.fail")
    
    # update_cp_state(4)
    # sleep(5)
    all_relay_states["MCU_SPD_CB"]=1
    sleep(8)
    
    if(fault_dict_new["SPD Fault"]==1):
        print_with_log("Fault not deactivation with only SPD pass")
    else:
        print_with_log("Fault deactivating with only SPD. fail")        
        return
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["SPD Fault"])

    st_time=timer()
    while(fault_dict_new["SPD Fault"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))
    
    if(fault_dict_new["SPD Fault"]==0):
        print_with_log("Fault deactivation with SPD and CP pass")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
    
    check_master_error_code_reset()

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()
    
def elr_fault_protection_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    start_charge_function()
    
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("Starting elr protection test")
    print_protection_status()
    
    if(CMS_internal_can_dict["input_power_protection_status"]==1 and fault_dict_new["ELR Fault"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
       
        return

    
    print_with_log("Activating ELR fault")
    all_relay_states["MCU_ELR_CB"]=0

    st_time=timer()
    while(fault_dict_new["ELR Fault"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>5):
            print_with_log("Fault activation timeout. Test fail")
            break
    dur=timer()-st_time

    
    
    if(fault_dict_new["ELR Fault"]==1):
        print_with_log("Fault activation pass in time: "+str(dur))
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")        
        return

    compare_fault_code_structure()
    check_master_session_code("ELR Fault")

    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
        check_display_activity_id(type="protection",name="ELR Fault")
        display_check=1
    

    print_protection_status()
    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0,
        drain_prot_status=1,
    )
    if(res==True):
        print_with_log("Protection ok as expected.Pass")
    else:
        print_with_log("Protection ok not as expected.fail")
    # update_cp_state(4)
    # sleep(3)
    all_relay_states["MCU_ELR_CB"]=1
    sleep(8)
    
    if(CMS_internal_can_dict["input_power_protection_status"]==0 and  fault_dict_new["ELR Fault"]==1):
        print_with_log("Fault not deactivation with only ELR pass")
    else:
        print_with_log("Fault deactivating with only ELR. fail")
        print(fault_dict_new)
        return
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["ELR Fault"])

    st_time=timer()
    while(fault_dict_new["ELR Fault"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    if(fault_dict_new["ELR Fault"]==0):
        print_with_log("Fault deactivation with ELR and CP pass")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()
    
def VR_fault_protection_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("Starting voltage_relay protection test")
    print_protection_status()
    
    if(CMS_internal_can_dict["input_power_protection_status"]==1 and fault_dict_new["VoltageRelay Fault"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        print(fault_dict_new)
        return

    
    print_with_log("Activating voltage_relay fault")
    all_relay_states["MCU_PFR_CB"]=0
    st_time=timer()
    while(fault_dict_new["VoltageRelay Fault"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>5):
            print_with_log("Fault activation timeout. Test fail")
            break
    dur=timer()-st_time

    
    
    if(fault_dict_new["VoltageRelay Fault"]==1):
        print_with_log("Fault activation pass in time: "+str(dur))
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")        
        return

    compare_fault_code_structure()
    check_master_session_code("VoltageRelay Fault")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="VoltageRelay Fault")
            display_check=1

    

    print_protection_status()
    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0,
        drain_prot_status=1,
    )
    if(res==True):
        print_with_log("Protection ok as expected.Pass")
    else:
        print_with_log("Protection ok not as expected.fail")

    # update_cp_state(4)
    # sleep(3)
    all_relay_states["MCU_PFR_CB"]=1
    sleep(8)
    
    if(CMS_internal_can_dict["input_power_protection_status"]==0 and  fault_dict_new["VoltageRelay Fault"]==1):
        print_with_log("Fault not deactivation with only voltage_relay pass")
    else:
        print_with_log("Fault deactivating with only voltage_relay. fail")
        print(fault_dict_new)
        return
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["VoltageRelay Fault"])

    st_time=timer()
    while(fault_dict_new["VoltageRelay Fault"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    if(fault_dict_new["VoltageRelay Fault"]==0):
        print_with_log("Fault deactivation with voltage_relay and CP pass")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
    
    check_master_error_code_reset()

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()
    
def em_sw_fault_protection_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("Starting EM_sw protection test")
    print_protection_status()
    
    if(CMS_internal_can_dict["input_power_protection_status"]==1 and fault_dict_new["EM_SW"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        print(fault_dict_new)
        return

    
    print_with_log("Activating EM_sw fault")
    all_relay_states["MCU_EM_SW_CB"]=0
    
    st_time=timer()
    while(fault_dict_new["EM_SW"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>5):
            print_with_log("Fault activation timeout. Test fail")
            break
    dur=timer()-st_time

    
    
    if(fault_dict_new["EM_SW"]==1):
        print_with_log("Fault activation pass in time: "+str(dur))
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")        
        return

    compare_fault_code_structure()
    check_master_session_code("EM_SW")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="EM_SW")
            display_check=1

 

    print_protection_status()
    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0,
        drain_prot_status=1,
    )
    if(res==True):
        print_with_log("Protection ok as expected.Pass")
    else:
        print_with_log("Protection ok not as expected.fail")

    # update_cp_state(4)
    # sleep(3)
    all_relay_states["MCU_EM_SW_CB"]=1
    sleep(8)
    
    if(CMS_internal_can_dict["input_power_protection_status"]==0 and  fault_dict_new["EM_SW"]==1):
        print_with_log("Fault not deactivation with only EM_sw pass")
    else:
        print_with_log("Fault deactivating with only EM_sw. fail")
        print(fault_dict_new)
        return
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["EM_SW"])

    st_time=timer()
    while(fault_dict_new["EM_SW"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    if(fault_dict_new["EM_SW"]==0):
        print_with_log("Fault deactivation with EM_sw and CP pass")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
    
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()
    
def grid_power_cut_protection_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("Starting Grid_Power_Cut test")
    print_protection_status()
    
    if(fault_dict_new["Grid_Power_Cut"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")        
        return

    
    print_with_log("Activating Grid_Power_Cut fault")
    all_relay_states["MCU_SPD_CB"]=0
    all_relay_states["MCU_ELR_CB"]=0
    all_relay_states["MCU_PFR_CB"]=0
    all_relay_states["MCU_EM_SW_CB"]=0

    
    st_time=timer()
    while(fault_dict_new["Grid_Power_Cut"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault activation timeout. Test fail")
            break
    dur=timer()-st_time

    
    
    if(fault_dict_new["Grid_Power_Cut"]==1):
        print_with_log("Fault activation pass in time: "+str(dur))
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")        
        return

    compare_fault_code_structure()
    check_master_session_code("Grid_Power_Cut")

    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Grid_Power_Cut")
            display_check=1


    

    print_protection_status()
    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0,
        drain_prot_status=1,
    )
    if(res==True):
        print_with_log("Protection ok as expected.Pass")
    else:
        print_with_log("Protection ok not as expected.fail")

    # update_cp_state(4)
    # sleep(3)
    
    all_relay_states["MCU_SPD_CB"]=1
    all_relay_states["MCU_ELR_CB"]=1
    all_relay_states["MCU_PFR_CB"]=1
    all_relay_states["MCU_EM_SW_CB"]=1
    sleep(10)
    
    if(fault_dict_new["Grid_Power_Cut"]==1):
        print_with_log("Fault not deactivation with only power on pass")
    else:
        print_with_log("Fault deactivating with only power on. fail")
        print(fault_dict_new)
        
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Grid_Power_Cut"])

    st_time=timer()
    while(fault_dict_new["Grid_Power_Cut"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    if(fault_dict_new["Grid_Power_Cut"]==0):
        print_with_log("Fault deactivation with power on and CP pass")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
        
    
    print_with_log("Checking fault deactivation with only VR on")
    print_with_log("Activating Grid_Power_Cut fault")
    
    all_relay_states["MCU_SPD_CB"]=0
    all_relay_states["MCU_ELR_CB"]=0
    all_relay_states["MCU_PFR_CB"]=0
    all_relay_states["MCU_EM_SW_CB"]=0
    sleep(5)
    all_relay_states["MCU_PFR_CB"]=1    
    st_time=timer()
    while(fault_dict_new["Grid_Power_Cut"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    if(fault_dict_new["Grid_Power_Cut"]==0):
        print_with_log("Fault deactivation with VR reset")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
        
    check_master_error_code_reset()

    print_with_log("Checking fault deactivation with only SPD on")
    print_with_log("Activating Grid_Power_Cut fault")
    all_relay_states["MCU_SPD_CB"]=0
    all_relay_states["MCU_ELR_CB"]=0
    all_relay_states["MCU_PFR_CB"]=0
    all_relay_states["MCU_EM_SW_CB"]=0
    sleep(5)
    all_relay_states["MCU_SPD_CB"]=1    
    st_time=timer()
    while(fault_dict_new["Grid_Power_Cut"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    if(fault_dict_new["Grid_Power_Cut"]==0):
        print_with_log("Fault deactivation with SPD reset")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
        
    
    print_with_log("Checking fault deactivation with only ELR on")
    print_with_log("Activating Grid_Power_Cut fault")
    all_relay_states["MCU_SPD_CB"]=0
    all_relay_states["MCU_ELR_CB"]=0
    all_relay_states["MCU_PFR_CB"]=0
    all_relay_states["MCU_EM_SW_CB"]=0
    sleep(5)
    all_relay_states["MCU_ELR_CB"]=1
    st_time=timer()
    while(fault_dict_new["Grid_Power_Cut"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    if(fault_dict_new["Grid_Power_Cut"]==0):
        print_with_log("Fault deactivation with ELR reset")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
        



    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

#endregion

#region output_power
##### Rectifier - Ref current offset Positive
def rectifier_ref_curr_offset_positive():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_curr_sensor_flag=1
    correct_rectifier_flag=1
    print_with_log("Starting Rectifier - Ref current offset Positive fault activation ")
    start_charge_function()
    sleep(5)
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["set_current"]<20):
            print_with_log("waiting for current start")
            sleep(1)
            if(timer()-st_time>20):
                break
        print_with_log("Starting current : "+str(CMS_internal_can_dict["set_current"]))
        if(CMS_internal_can_dict["set_current"]<400):
            break         
        emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)

    if(not initial_condition_check()):
        return
    

    print_protection_status()
    print_with_log("Rectifier - Ref current offset Positive error state: "+str(fault_dict_new["Rectifier - Ref current offset Positive"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
        )
    if(fault_dict_new["Rectifier - Ref current offset Positive"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return

    
    correct_current_flag=0

    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"]+120)/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"])

    sleep(8)
    if(fault_dict_new["Rectifier - Ref current offset Positive"]==0 ):
        print_with_log("Non activation pass")
    else:
        print_with_log("Non activation  fail")
        
    
    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"]+150)/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"])
    st_time=timer()
    while(fault_dict_new["Rectifier - Ref current offset Positive"]==0):
        print_with_log("waiting for fault activation")        
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_protection_status()
    print_with_log("Rectifier - Ref current offset Positive error state: "+str(fault_dict_new["Rectifier - Ref current offset Positive"]))
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Rectifier - Ref current offset Positive"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code("Rectifier - Ref current offset Positive")

    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Rectifier - Ref current offset Positive")
            display_check=1

    

    print_with_log("Checking non deactivation with only correct current ")
    correct_rectifier_flag=1
    correct_curr_sensor_flag=1
    correct_current_flag=1
    sleep(5)
    
    print_with_log("Rectifier - Ref current offset Positive error state: "+str(fault_dict_new["Rectifier - Ref current offset Positive"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Rectifier - Ref current offset Positive"]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Rectifier - Ref current offset Positive"])

    st_time=timer()
    while(fault_dict_new["Rectifier - Ref current offset Positive"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_protection_status()
    print_with_log("Rectifier - Ref current offset Positive error state: "+str(fault_dict_new["Rectifier - Ref current offset Positive"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Rectifier - Ref current offset Positive"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    
    check_master_error_code_reset()
        

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

##### Rectifier - Ref current offset Negative
def rectifier_ref_curr_offset_negative():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_curr_sensor_flag=1
    correct_rectifier_flag=1
    print_with_log("Starting Rectifier - Ref current offset Negative fault activation ")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_protection_status()
    print_with_log("Rectifier - Ref current offset Negative error state: "+str(fault_dict_new["Rectifier - Ref current offset Negative"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
        )
    if(fault_dict_new["Rectifier - Ref current offset Negative"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return

    
    correct_current_flag=0

    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"]-120)/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"])

    sleep(8)
    if(fault_dict_new["Rectifier - Ref current offset Negative"]==0 ):
        print_with_log("Non activation pass")
    else:
        print_with_log("Non activation  fail")
        
    
    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"]-150)/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"])
    st_time=timer()
    while(fault_dict_new["Rectifier - Ref current offset Negative"]==0):
        print_with_log("waiting for fault activation")        
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_protection_status()
    print_with_log("Rectifier - Ref current offset Negative error state: "+str(fault_dict_new["Rectifier - Ref current offset Negative"]))
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Rectifier - Ref current offset Negative"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code("Rectifier - Ref current offset Negative")

    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Rectifier - Ref current offset Negative")
            display_check=1


    

    print_with_log("Checking non deactivation with only correct current ")
    correct_rectifier_flag=1
    correct_curr_sensor_flag=1
    correct_current_flag=1
    sleep(5)
    
    print_with_log("Rectifier - Ref current offset Negative error state: "+str(fault_dict_new["Rectifier - Ref current offset Negative"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Rectifier - Ref current offset Negative"]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Rectifier - Ref current offset Negative"])

    

    st_time=timer()
    while(fault_dict_new["Rectifier - Ref current offset Negative"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_protection_status()
    print_with_log("Rectifier - Ref current offset Negative error state: "+str(fault_dict_new["Rectifier - Ref current offset Negative"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Rectifier - Ref current offset Negative"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
        
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


##### Reference - sensor Current offset  Positive
def Reference_sensor_Current_offset_Positive():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_curr_sensor_flag=1
    correct_rectifier_flag=1
    print_with_log("Starting Reference - sensor Current offset  Positive fault activation ")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_protection_status()
    print_with_log("Reference - sensor Current offset  Positive error state: "+str(fault_dict_new["Reference - sensor Current offset  Positive"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
        )
    if(fault_dict_new["Reference - sensor Current offset  Positive"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        

    
    correct_current_flag=0

    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"])/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"]-120)

    sleep(8)
    if(fault_dict_new["Reference - sensor Current offset  Positive"]==0 ):
        print_with_log("Non activation pass")
    else:
        print_with_log("Non activation  fail")
        
    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"])/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"]-200)

    
    st_time=timer()
    while(fault_dict_new["Reference - sensor Current offset  Positive"]==0):
        print_with_log("waiting for fault activation")        
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_protection_status()
    print_with_log("Reference - sensor Current offset  Positive error state: "+str(fault_dict_new["Reference - sensor Current offset  Positive"]))
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Reference - sensor Current offset  Positive"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code("Reference - sensor Current offset  Positive")

    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Reference - sensor Current offset  Positive")
            display_check=1

    

    print_with_log("Checking non deactivation with only correct current ")
    correct_rectifier_flag=1
    correct_curr_sensor_flag=1
    correct_current_flag=1
    sleep(5)
    
    print_with_log("Reference - sensor Current offset  Positive error state: "+str(fault_dict_new["Reference - sensor Current offset  Positive"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Reference - sensor Current offset  Positive"]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        return
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Reference - sensor Current offset  Positive"])

    st_time=timer()
    while(fault_dict_new["Reference - sensor Current offset  Positive"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_protection_status()
    print_with_log("Reference - sensor Current offset  Positive error state: "+str(fault_dict_new["Reference - sensor Current offset  Positive"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Reference - sensor Current offset  Positive"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    
    check_master_error_code_reset()

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

##### Reference - sensor Current offset  Negative
def Reference_sensor_Current_offset_Negative():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_curr_sensor_flag=1
    correct_rectifier_flag=1
    print_with_log("Starting Reference - sensor Current offset  Negative fault activation ")
    start_charge_function()
    sleep(5)
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["set_current"]<20):
            print_with_log("waiting for current start")
            sleep(1)
            if(timer()-st_time>20):
                break
        print_with_log("Starting current : "+str(CMS_internal_can_dict["set_current"]))
        if(CMS_internal_can_dict["set_current"]<400):
            break         
        emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
    if(not initial_condition_check()):
        return
    

    print_protection_status()
    print_with_log("Reference - sensor Current offset  Negative error state: "+str(fault_dict_new["Reference - sensor Current offset  Negative"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
        )
    if(fault_dict_new["Reference - sensor Current offset  Negative"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        

    
    correct_current_flag=0

    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"])/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"]+120)

    sleep(10)
    if(fault_dict_new["Reference - sensor Current offset  Negative"]==0 ):
        print_with_log("Non activation pass")
    else:
        print_with_log("Non activation  fail")
        
    
    rectifier_readback_values["current"]=(CMS_internal_can_dict["set_current"])/(12-deactivate_rectifiers_num)
    set_curr(CMS_internal_can_dict["set_current"]+200)
    st_time=timer()
    while(fault_dict_new["Reference - sensor Current offset  Negative"]==0):
        print_with_log("waiting for fault activation")        
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_protection_status()
    print_with_log("Reference - sensor Current offset  Negative error state: "+str(fault_dict_new["Reference - sensor Current offset  Negative"]))
    
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Reference - sensor Current offset  Negative"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code("Reference - sensor Current offset  Negative")
    sleep(1)

    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Reference - sensor Current offset  Negative")
            display_check=1


    

    print_with_log("Checking non deactivation with only correct current ")
    correct_rectifier_flag=1
    correct_curr_sensor_flag=1
    correct_current_flag=1
    sleep(5)
    
    print_with_log("Reference - sensor Current offset  Negative error state: "+str(fault_dict_new["Reference - sensor Current offset  Negative"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Reference - sensor Current offset  Negative"]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        return
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Reference - sensor Current offset  Negative"])

    

    st_time=timer()
    while(fault_dict_new["Reference - sensor Current offset  Negative"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_protection_status()
    print_with_log("Reference - sensor Current offset  Negative error state: "+str(fault_dict_new["Reference - sensor Current offset  Negative"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Reference - sensor Current offset  Negative"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
        
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

##### Rectifier derated
def Rectifier_derated():
    pass
###  TODO

###### Over current
def Over_current():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag,deactivate_rectifiers_num
    voltage_cutoff=3.605   
    over_current_intermediate_value=620
    over_current_limit=635
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Over current fault activation")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_protection_status()
    print_with_log("Over current error state: "+str(fault_dict_new["Over current"]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Over current"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    correct_curr_sensor_flag=0
    correct_rectifier_flag=0
    rectifier_readback_values["voltage"]=rectifier_control_request["voltage"]
    rectifier_readback_values["current"]=over_current_intermediate_value/(12.0-deactivate_rectifiers_num)
    set_curr(over_current_intermediate_value)
    


    print_with_log("Over current error state: "+str(fault_dict_new["Over current"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Over current"]==0 and res):
        print_with_log("Non activation at current: "+str(over_current_intermediate_value)+" pass")
    else:
        print_with_log("Non activation at current: "+str(over_current_intermediate_value)+" fail")
        return
    
    rectifier_readback_values["voltage"]=rectifier_control_request["voltage"]
    rectifier_readback_values["current"]=over_current_limit/(12.0-deactivate_rectifiers_num)
    set_curr(over_current_limit)

    st_time=timer()
    while(fault_dict_new["Over current"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("Over current error state: "+str(fault_dict_new["Over current"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Over current"]==1 and res):
        print_with_log("fault activation at current: "+str(over_current_limit)+" pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation at current: "+str(over_current_limit)+" fail")
        
    
    compare_fault_code_structure()
    check_master_session_code("Over current")

    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Over current")
            display_check=1

    

    print_with_log("Checking non deactivation with only correct current ")
    correct_rectifier_flag=1
    correct_curr_sensor_flag=1    
    sleep(5)


    print_with_log("Over current error state: "+str(fault_dict_new["Over current"]))
    print_protection_status()
    

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=-1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1
    )
    if(fault_dict_new["Over current"]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Over current"])

    
    st_time=timer()
    while(fault_dict_new["Over current"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    
    print_with_log("Over current error state: "+str(fault_dict_new["Over current"]))
    print_protection_status()

    
    if(fault_dict_new["Over current"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    
    check_master_error_code_reset()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

###### No Current Fault
def No_Current_Fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    

    correct_current_flag=1
    correct_relay_state_flag=1
    start_seq=0
    print_with_log("Starting NNo Current Fault test")    
    start_charge_function()
    sleep(5)    
            
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        sleep(10)
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
        sleep(2)

        if(start_seq==0):
            correct_current_flag=0            
            rectifier_readback_values["current"]=1
            set_curr(20)   
            sleep(2)
            print_with_log("Sensor curr: "+str(CMS_internal_can_dict["current_read"]))
            print_with_log("Checking non activation before limit")
            sleep(10)
            if(fault_dict_new["No Current Fault"]==0):
                print_with_log("No activation before limit pass")
            else:
                print_with_log("No activation before limit fail")
            
            rectifier_readback_values["current"]=0
            set_curr(5)   

            print_with_log("Dropping current to zero")
            print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
            

            st_time=timer()
            while(fault_dict_new["No Current Fault"]==0):
                print_with_log("waiting for fault activation")
                sleep(1)
                if(timer()-st_time>30):
                    print_with_log("Activation timeout.test fail")
                    break
            sleep(1)
            res=evaluate_protection_state(
            input_power_protection_status=1,
            output_power_protection_status=0,
            fcs_heating_protection_status=1,
            e_plug_protection_status=1,
            bms_protection_status=1,
            charging_algo_protections_status=0,
            fcs_cooling_protection_status=1,
            fcs_int_cooling_prot_status=1
            )

            if(res==True):
                print_with_log("protection activation pass")
            else:
                print_with_log("protection activation fail")
            
            dur=timer()-st_time
            if(fault_dict_new["No Current Fault"]==1):
                print_with_log("No Current Fault activation pass. duration: "+str(dur))
                print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
            else:
                print_with_log("No Current Fault activation fail")
            print_protection_status()
            compare_fault_code_structure()
            check_master_session_code("No Current Fault")
            sleep(1)
            display_check=0
            if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
                    check_display_activity_id(type="protection",name="No Current Fault")
                    display_check=1

            
            n_curr=CMS_internal_can_dict["set_current"]
            print_with_log("New current: "+str(n_curr))
            if(n_curr>100):
                print_with_log("charge stop with No Current Fault test fail")
            else:
                print_with_log("charge stop with No Current Fault test pass")
            start_seq=1

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

        cv=emulate_voltage_increase_till_cutoff(3.3)

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
    sleep(5)
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["No Current Fault"])

    check_master_error_code_reset()
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()

##### Precharge failed

def precharge_fail_protection_before_relay():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,precharge_fail_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    precharge_fail_flag=1
    correct_rectifier_flag=1

    print_with_log("Starting Precharge failed fault activation before relay closing")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
        
    
    update_cp_state(6)
    sleep(3)
   

    
    print_with_log("Precharge failed error state: "+str(fault_dict_new["Precharge failed"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
        
    )
    if(fault_dict_new["Precharge failed"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    st_time=timer()
    while(fault_dict_new["Precharge failed"]==0):
        print_with_log("waiting for fault activation")        
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log("Precharge failed error state: "+str(fault_dict_new["Precharge failed"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=-1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Precharge failed"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code("Precharge failed")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Precharge failed")
            display_check=1

    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Precharge failed"])

    
    st_time=timer()
    while(fault_dict_new["Precharge failed"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    
    print_with_log("Precharge failed error state: "+str(fault_dict_new["Precharge failed"]))
    print_protection_status()

    
    if(fault_dict_new["Precharge failed"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    correct_rectifier_flag=1
    precharge_fail_flag=0
    sleep(5)
    all_ard_state_reset()

def precharge_fail_protection_after_relay():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,precharge_fail_flag,precharge_fail_flag_2
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    
    correct_rectifier_flag=1

    print_with_log("Starting Precharge failed fault activation after relay closing")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
        
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    
    
    print_with_log("Precharge failed error state: "+str(fault_dict_new["Precharge failed"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Precharge failed"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    update_cp_state(4)
    emulate_gun_lock()  

    
    
    st_time=timer()
    while(CMS_internal_can_dict["precharge_rel"]==0):
        print_with_log("waiting for precharge relay closing")
        sleep(0.1)
        if(timer()-st_time>60):
            print_with_log("Precharge activation timeout. test fail")
            return
    
    print_with_log("Precharge relay on")  
    precharge_fail_flag_2=1
    st_time=timer()
    while(fault_dict_new["Precharge failed"]==0):
        print_with_log("waiting for fault activation")        
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log("Precharge failed error state: "+str(fault_dict_new["Precharge failed"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=-1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Precharge failed"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code("Precharge failed")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Precharge failed")
            display_check=1

    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Precharge failed"])

    
    st_time=timer()
    while(fault_dict_new["Precharge failed"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    
    print_with_log("Precharge failed error state: "+str(fault_dict_new["Precharge failed"]))
    print_protection_status()

    
    if(fault_dict_new["Precharge failed"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    correct_rectifier_flag=1
    precharge_fail_flag=0
    sleep(5)
    all_ard_state_reset()

#endregion

#region sensor failure 1
##### Current Sense open
def current_sensor_open_protection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,precharge_fail_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    

    print_with_log("Starting Current Sense open fault activation")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return

    print_with_log("Current Sense open error state: "+str(fault_dict_new["Current Sense open"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Current Sense open"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    set_zero_curr_ADC()
    # print_with_log("ADC set to: "+str(CMS_internal_can_dict["cs_ch_2"]))

    st_time=timer()
    while(fault_dict_new["Current Sense open"]==0):
        print_with_log("waiting for fault activation")        
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log("Current Sense open error state: "+str(fault_dict_new["Current Sense open"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Current Sense open"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        return

    compare_fault_code_structure()
    check_master_session_code("Current Sense open")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name="Current Sense open")
            display_check=1


    

    print_with_log("Checking non deactivation with ADC reset")
    reset_zero_curr_ADC()
    # print_with_log("ADC set to: "+str(CMS_internal_can_dict["cs_ch_2"]))
    sleep(8)

    
    print_with_log("Current Sense open state: "+str(fault_dict_new["Current Sense open"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Current Sense open"]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id["Current Sense open"])

    st_time=timer()
    while(fault_dict_new["Current Sense open"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    
    print_with_log("Current Sense open error state: "+str(fault_dict_new["Current Sense open"]))
    print_protection_status()

    
    if(fault_dict_new["Current Sense open"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

##### Current sensor fail/faulty offset
def Current_sensor_fail_faulty_offset():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag
    voltage_cutoff=3.605   
    correct_current_flag=0
    correct_relay_state_flag=1
    offset_activation=30
    offset_deactivation=5

    fault_name="Current sensor fail/faulty offset"
    error_name="Current sensor fail/faulty offset"

    print_with_log("Starting Current sensor fail/faulty offset check")

    # start_charge_function()
    # sleep(5)  

    if(not initial_condition_check()):
        return
    correct_current_flag=0
    set_curr(offset_activation)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")        
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    set_curr(offset_deactivation)
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    correct_current_flag=0
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

###### Gun_Temp_Sense_Failure
def gun_temp_sensor_open_low_protection_1_2():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,precharge_fail_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    low_temp_intermediate_limit=-10
    low_temp_open_limit=-25
    high_temp_intermediate_limit=90
    high_temp_open_limit=110
    error_name="Gun_Temp_Sense_Failure"

    

    print_with_log("Starting Gun_Temp_Sense_Failure low fault activation 1 and 2")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
  
    print_with_log("Gun_Temp_Sense_Open error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("Checking non activation at intermediate temperature")

    set_temp(low_temp_intermediate_limit)
    all_relay_states["CON_P_TS1"]=1
    all_relay_states["CON_P_TS2"]=1
    sleep(1)
    print_with_log("gun_temp_p_1: "+str(CMS_internal_can_dict["gun_temp_p_1"]))
    sleep(3)

    
    print_with_log("Gun_Temp_Sense_Open error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_p_1"])+" pass")
    else:
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_p_1"])+" fail")
        
    
    set_temp(low_temp_open_limit)

    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("waiting for fault activation")        
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        

    compare_fault_code_structure()
    check_master_session_code("Gun_Temp_Sense_Failure")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("Checking  non deactivation with single temp reset")
    all_relay_states["CON_P_TS1"]=0

    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>60):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

def gun_temp_sensor_open_high_protection_1_2():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,precharge_fail_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    
    high_temp_intermediate_limit=106
    high_temp_open_limit=115
    error_name="Gun_Temp_Sense_Failure"

    

    print_with_log("Starting Gun_Temp_Sense_Failure fault high activation 1 and 2")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
       
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("Checking non activation at intermediate temperature")

    set_temp(high_temp_intermediate_limit)
    all_relay_states["CON_P_TS1"]=1
    all_relay_states["CON_P_TS2"]=1
    sleep(1)
    print_with_log("gun_temp_p_1: "+str(CMS_internal_can_dict["gun_temp_p_1"]))
    sleep(3)

    
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_p_1"])+" pass")
    else:
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_p_1"])+" fail")
        
    
    set_temp(high_temp_open_limit)

    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("waiting for fault activation")        
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        

    compare_fault_code_structure()
    check_master_session_code("Gun_Temp_Sense_Failure")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("Checking  deactivation with single temp reset")
    all_relay_states["CON_P_TS1"]=0

    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>60):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

   
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

def gun_temp_sensor_open_low_protection_3_4():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,precharge_fail_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    low_temp_intermediate_limit=-10
    low_temp_open_limit=-25
    error_name="Gun_Temp_Sense_Failure"

    

    print_with_log("Starting Gun_Temp_Sense_Failure fault low activation 3 and 4")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
      
   
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("Checking non activation at intermediate temperature")

    set_temp(low_temp_intermediate_limit)
    all_relay_states["CON_P_TS3"]=1
    all_relay_states["CON_P_TS4"]=1
    sleep(1)
    print_with_log("gun_temp_n_1: "+str(CMS_internal_can_dict["gun_temp_n_1"]))
    sleep(3)

    
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_n_1"])+" pass")
    else:
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_n_1"])+" fail")
        
    
    set_temp(low_temp_open_limit)

    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("waiting for fault activation")        
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        

    compare_fault_code_structure()
    check_master_session_code("Gun_Temp_Sense_Failure")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("Checking  deactivation with single temp reset")
    all_relay_states["CON_P_TS3"]=0  
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

def gun_temp_sensor_open_high_protection_3_4():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,precharge_fail_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    high_temp_intermediate_limit=106
    high_temp_open_limit=115
    error_name="Gun_Temp_Sense_Failure"


    

    print_with_log("Starting Gun_Temp_Sense_Failure fault high activation 3 and 4")
    print_with_log("master on")
    start_charge_function()
    if(not initial_condition_check()):
        return
         
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("Checking non activation at intermediate temperature")

    set_temp(high_temp_intermediate_limit)
    all_relay_states["CON_P_TS3"]=1
    all_relay_states["CON_P_TS4"]=1
    sleep(1)
    print_with_log("gun_temp_n_1: "+str(CMS_internal_can_dict["gun_temp_n_1"]))
    sleep(3)

    
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_n_1"])+" pass")
    else:
        print_with_log("Non activation at temp: "+str(CMS_internal_can_dict["gun_temp_n_1"])+" fail")
        
    
    set_temp(high_temp_open_limit)

    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==0):
        print_with_log("waiting for fault activation")        
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new["Gun_Temp_Sense_Failure"]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        

    compare_fault_code_structure()
    check_master_session_code("Gun_Temp_Sense_Failure")
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("Checking  deactivation with single temp reset")
    all_relay_states["CON_P_TS3"]=0   
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new["Gun_Temp_Sense_Failure"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

   
    print_with_log("Gun_Temp_Sense_Failure error state: "+str(fault_dict_new["Gun_Temp_Sense_Failure"]))
    print_protection_status()

    
    if(fault_dict_new["Gun_Temp_Sense_Open"]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

##### Positive GunTempSense lowside fault
def Positive_GunTempSense_lowside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=0
    gun_temp_open_warning_activation=-10
    gun_temp_opne_warning_deactivation=5

    fault_name="Positive GunTempSense lowside fault"
    error_name="Positive GunTempSense lowside fault"
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2"]
    
    
    gun_temp_can_list=["gun_temp_p_1","gun_temp_p_2"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)

    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

##### Positive GunTempSense highside fault
def Positive_GunTempSense_highside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=100
    gun_temp_open_warning_activation=110
    gun_temp_opne_warning_deactivation=95

    fault_name="Positive GunTempSense highside fault"
    error_name="Positive GunTempSense highside fault"
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2"]
    
    
    gun_temp_can_list=["gun_temp_p_1","gun_temp_p_2"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

##### Negative GunTempSense lowside fault
def Negative_GunTempSense_lowside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=0
    gun_temp_open_warning_activation=-10
    gun_temp_opne_warning_deactivation=5

    fault_name="Negative GunTempSense lowside fault"
    error_name="Negative GunTempSense lowside fault"
    gun_relay_names_list=["CON_P_TS3","CON_P_TS4"]        
    gun_temp_can_list=["gun_temp_n_1","gun_temp_n_2"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

##### Negative GunTempSense highside fault
def Negative_GunTempSense_highside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=100
    gun_temp_open_warning_activation=110
    gun_temp_opne_warning_deactivation=95

    fault_name="Negative GunTempSense highside fault"
    error_name="Negative GunTempSense highside fault"
    gun_relay_names_list=["CON_P_TS3","CON_P_TS4"]
    
    
    gun_temp_can_list=["gun_temp_n_1","gun_temp_n_2"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]])+" val 2: "+str(CMS_internal_can_dict[gun_temp_can_list[1]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

###### Hot tank Watertemp sense lowside fault
def Hot_tank_Watertemp_sense_lowside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   

    temp_base_val=50
    temp_non_activation=5
    temp_activation=-10
    temp_deactivation=10

    fault_name="Hot tank Watertemp sense lowside fault"
    error_name="Hot tank Watertemp sense lowside fault"
    temp_can=["hot_tank_temp"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    set_temp(temp_base_val)
    all_relay_states["CON_AMB_TS8"]=1    
    sleep(5)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    set_temp(temp_non_activation)
    
    sleep(10)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    


    set_temp(temp_activation)
    
    sleep(2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    set_temp(temp_deactivation)    
    sleep(2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    all_relay_states["CON_AMB_TS8"]=0
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    heater_data["heater_tank_temperature"]=temp_base_val
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

###### Hot tank Watertemp sense highside fault
def Hot_tank_Watertemp_sense_highside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   

    temp_base_val=50
    temp_non_activation=100
    temp_activation=110
    temp_deactivation=95

    fault_name="Hot tank Watertemp sense highside fault"
    error_name="Hot tank Watertemp sense highside fault"
    temp_can=["hot_tank_temp"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(temp_base_val)
    all_relay_states["CON_AMB_TS8"]=1  
    sleep(5)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(temp_non_activation)
    
    sleep(10)

    if(fault_dict_new[error_name] == 0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    


    set_temp(temp_activation)
    
    sleep(2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    set_temp(temp_deactivation)
    
    sleep(2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    all_relay_states["CON_AMB_TS8"]=0
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    heater_data["heater_tank_temperature"]=temp_base_val
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)


###### Cold tank Watertemp sense lowside fault
def Cold_tank_Watertemp_sense_lowside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   

    temp_base_val=10
    temp_non_activation=0
    temp_activation=-10
    temp_deactivation=10

    fault_name="Cold tank Watertemp sense lowside fault"
    error_name="Cold tank Watertemp sense lowside fault"
    temp_can=["chiller_liquid_temp"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    
    chiller_data["chiller_liquid_temp"]=temp_base_val

    sleep(15)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    
    chiller_data["chiller_liquid_temp"]=temp_non_activation
    sleep(20)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    
    chiller_data["chiller_liquid_temp"]=temp_activation
    sleep(20)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    chiller_data["chiller_liquid_temp"]=temp_deactivation
    sleep(2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    
    chiller_data["chiller_liquid_temp"]=temp_base_val
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)


###### Cold tank Watertemp sense highside fault
def Cold_tank_Watertemp_sense_highside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   

    temp_base_val=10
    temp_non_activation=100
    temp_activation=110
    temp_deactivation=95

    fault_name="Cold tank Watertemp sense highside fault"
    error_name="Cold tank Watertemp sense highside fault"
    temp_can=["chiller_liquid_temp"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    
    chiller_data["chiller_liquid_temp"]=temp_base_val

    sleep(5)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    
    chiller_data["chiller_liquid_temp"]=temp_non_activation
    sleep(10)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    
    chiller_data["chiller_liquid_temp"]=temp_activation
    sleep(2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    chiller_data["chiller_liquid_temp"]=temp_deactivation
    sleep(2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[temp_can[0]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    
    chiller_data["chiller_liquid_temp"]=temp_base_val
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

##### Inlet Watertemp sense lowside fault
### "CON_WATER_INLET":"water_inlet_temperature",
def Inlet_Watertemp_sense_lowside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=0
    gun_temp_open_warning_activation=-40
    gun_temp_opne_warning_deactivation=15

    fault_name="Inlet Watertemp sense lowside fault"
    error_name="Inlet Watertemp sense lowside fault"
    gun_relay_names_list=["CON_WATER_INLET"]
    
    
    gun_temp_can_list=["water_inlet_temperature"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

##### Inlet Watertemp sense highside fault
### "CON_WATER_INLET":"water_inlet_temperature",
def Inlet_Watertemp_sense_highside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=100
    gun_temp_open_warning_activation=140
    gun_temp_opne_warning_deactivation=80

    fault_name="Inlet Watertemp sense highside fault"
    error_name="Inlet Watertemp sense highside fault"
    gun_relay_names_list=["CON_WATER_INLET"]
    
    
    gun_temp_can_list=["water_inlet_temperature"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        

    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

##### Outlet Watertemp sense lowside fault
### "CON_WATER_OUTLET":"water_outlet_temperature",
def Outlet_Watertemp_sense_lowside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=0
    gun_temp_open_warning_activation=-40
    gun_temp_opne_warning_deactivation=15

    fault_name="Outlet Watertemp sense lowside fault"
    error_name="Outlet Watertemp sense lowside fault"
    gun_relay_names_list=["CON_WATER_OUTLET"]
    
    
    gun_temp_can_list=["water_outlet_temperature"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

##### Outlet Watertemp sense highside fault
### "CON_WATER_OUTLET":"water_outlet_temperature",
def Outlet_Watertemp_sense_highside_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_non_activation=100
    gun_temp_open_warning_activation=150
    gun_temp_opne_warning_deactivation=80

    fault_name="Outlet Watertemp sense highside fault"
    error_name="Outlet Watertemp sense highside fault"
    gun_relay_names_list=["CON_WATER_OUTLET"]
    
    
    gun_temp_can_list=["water_outlet_temperature"]
    
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    set_temp(gun_temp_open_warning_non_activation)
    sleep(6)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation pass")
    else:
        print_with_log("Fault non activation fail")
    



    set_temp(gun_temp_open_warning_activation)
    sleep(0.2)
    print_with_log("Temperature val1: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(2)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature val: "+str(CMS_internal_can_dict[gun_temp_can_list[0]]))
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    for gun_relay_name in gun_relay_names_list:
        all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

#endregion

#region sensor_failure 2

####"Charger-DC_Contactor_Open":"Charger_DC_Contactor_Open",
def charge_DC_contcator_open_protection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_polarity_response=1
    
    
    fault_name="Charger-DC_Contactor_Open"
    error_name="Charger-DC_Contactor_Open"

    print_with_log("Checking "+fault_name)
    master_swt_on()
    sleep(5)  
    if(not initial_condition_check()):
        return  
       
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)    
    emulate_gun_lock()
    dc_contactor_open_flag=1
    while(CMS_internal_can_dict["dc_contactor"]==0):
        print_with_log("waiting for CMS to request closing DC contactor")
        sleep(0.1)
    print_with_log("CMS requesting DC contactor closing")

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(2)
    check_master_error_code_reset()

    dc_contactor_open_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

######## "Charger_DC_polarity_reverse":"None",
#### dc_contactor_rev_polarity_flag
def Charger_DC_polarity_reverse():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,dc_contactor_rev_polarity_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_polarity_response=1
    dc_contactor_rev_polarity_flag=0
    
    
    fault_name="Charger_DC_polarity_reverse"
    error_name="Charger_DC_polarity_reverse"

    print_with_log("Checking "+fault_name)
    master_swt_on()
    sleep(5)  
    if(not initial_condition_check()):
        return  
       
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    
    while(CMS_internal_can_dict["dc_contactor"]==0):
        print_with_log("waiting for CMS to request closing DC contactor")
        sleep(0.1)
    print_with_log("CMS requesting DC contactor closing")
    dc_contactor_rev_polarity_flag=1

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(2)
    check_master_error_code_reset()

    dc_contactor_open_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    dc_contactor_rev_polarity_flag=0
    sleep(5)
    all_ard_state_reset()

##### CMS 48V detection circuit fault
def CMS_48V_detection_circuit_fault():
    ###TODO
    print_with_log("CMS 48V detection circuit fault test not possible with HIL")
    
##### "Charger_DC_Contactor_PreCharge_Weld":"Charger_DC_Contactor_PreCharge_Weld",
def check_dc_contactor_weld_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_forward_weld_flag,dc_contactor_rev_weld_flag,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    
    
    fault_name="charge_DC_contcator_weld_protection"
    error_name="Charger_DC_Contactor_PreCharge_Weld"

    print_with_log("master on")
    print_with_log("Activating dc contactor weld after reset")
    dc_contactor_forward_weld_flag=1    
    master_swt_on()
    sleep(5)
    print_with_log("Checking for: "+fault_name)
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    dc_contactor_forward_weld_flag=0
    print_with_log("Deactivating dc contcator weld")
    sleep(10)

    if(fault_dict_new[error_name]==1):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    
    master_swt_off()
    sleep(2)
    master_swt_on()
    sleep(5)

    

    print_with_log("Starting normal charge")
    emulate_BMS_cycle_count(67)    
    emulate_BMS_HW_version(21)

    

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=24,max_temp_val=25)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)    
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")            
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")            
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return        
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["set_current"])) 
        
        
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
        
        # cv=emulate_voltage_increase_till_cutoff(3.3)
        cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
    
    dc_contactor_forward_weld_flag=1   
    
    charge_end_function()
    chg_compl_start=timer()
    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    # emulate_last_charge_ah(sent_ah)
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):            
            print_with_log("Received convergance command")    
            print_with_log("changing SOC as per convergance")
            emulate_actual_soc(tec_SOC)
            emulate_user_soc(100.4)            
            break
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test fail")
            break
        
    gun_remove_function()
    
    gun_unlock_delay=timer()-chg_compl_start
    print_with_log("Gun unlock delay: "+str(gun_unlock_delay))    
    emulate_gun_unlock()
    sleep(2)
    bms_send_flag=0
    update_cp_state(6)    
    
    dc_contactor_forward_weld_flag=1    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
    else:
        print_with_log("Fault activation fail")   
    sleep(5)
    compare_fault_code_structure()
    check_master_session_code(error_name)
    check_display_activity_id(type="protection",name=error_name)
    print_with_log("Checking non_deactivation")
    dc_contactor_forward_weld_flag=0
    sleep(10)
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    dc_contactor_forward_weld_flag=0
    all_ard_state_reset()
    sleep(5)


##### "Charger_DC_Contactor_PreCharge_Weld_reverse":"Charger_DC_Contactor_PreCharge_Weld",
def check_dc_contactor_rev_weld_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_forward_weld_flag,dc_contactor_rev_weld_flag,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    
    
    fault_name="Charger_DC_Contactor_PreCharge_Weld_reverse"
    error_name="Charger_DC_Contactor_PreCharge_Weld_reverse"
    dc_contactor_rev_weld_flag=1 
    print_with_log("master on")
    master_swt_on()
    sleep(5)
   
    
    print_with_log("Checking for: "+fault_name)
    
    print_with_log("Activating dc contactor weld after reset")
       
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    dc_contactor_rev_weld_flag=0
    print_with_log("Deactivating dc contcator weld")
    sleep(10)

    if(fault_dict_new[error_name]==1):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    master_swt_off()
    sleep(2)
    master_swt_on()
    sleep(5)
    
   
    print_with_log("Starting normal charge")
    emulate_BMS_cycle_count(67)    
    emulate_BMS_HW_version(21)

    

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    sleep(2)
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"]))  
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
               
        cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
    
    dc_contactor_rev_weld_flag=1
    charge_end_function()
    chg_compl_start=timer()
    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    # emulate_last_charge_ah(sent_ah)
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):            
            print_with_log("Received convergance command")    
            print_with_log("changing SOC as per convergance")
            emulate_actual_soc(tec_SOC)
            emulate_user_soc(100.4)
            sleep(0.1)
            break
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test fail")
            break
    gun_remove_function()
    
    gun_unlock_delay=timer()-chg_compl_start
    print_with_log("Gun unlock delay: "+str(gun_unlock_delay))
        
    
    emulate_gun_unlock()
    sleep(2)
    bms_send_flag=0
    update_cp_state(6)    
    

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
    else:
        print_with_log("Fault activation fail")
    
    print_with_log("CHecking non deactivation")
    dc_contactor_rev_weld_flag=0
    sleep(10)

   
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()
    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=-1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    dc_contactor_rev_weld_flag=0
    all_ard_state_reset()
    sleep(5)

#####"Polarity_Reversal":"Polarity_Reversal",

def polarity_reverse_protection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,polarity_rev_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_polarity_response=1
    
    fault_name="BMS_polarity_reverse_protection"
    error_name="Polarity_Reversal"

    print_with_log("Checking "+fault_name)
    master_swt_on()
    sleep(5)  
    if(not initial_condition_check()):
        return  
       
    polarity_rev_flag=1
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    print_with_log("starting to send BMS data")
    for _ in range(10):
        print_with_log("BMS solenoid feedback: "+str(BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]))
        sleep(0.5)
    update_cp_state(4)    
    emulate_gun_lock()

    while(ota_can_dict["CC_On_Req"]==0):
        print_with_log("waiting for CMS to request closing BMS contactor")
        sleep(0.1)
    print_with_log("CMS requesting BMS contactor closing")

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    polarity_rev_flag=0
    sleep(2)
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            break
    
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    
    check_master_error_code_reset()

    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

########"BMS_Contactor_Weld":"BMS_Contactor_Weld",

def BMS_contactor_weld_forward_protection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,polarity_rev_flag,BMS_contactor_weld_forward 
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_polarity_response=1
    
    fault_name="BMS_weld_forward_protection"
    error_name="BMS_Contactor_Weld"

    print_with_log("Checking "+fault_name)
    master_swt_on()
    sleep(5) 
    if(not initial_condition_check()):
        return   
    update_cp_state(6)
    sleep(3)
    BMS_contactor_weld_forward=1
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)        
    emulate_gun_lock()
    

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    BMS_contactor_weld_forward=0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            break
    
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")

    check_master_error_code_reset()
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()
    

def BMS_contactor_weld_rev_protection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,polarity_rev_flag,BMS_contactor_weld_forward,BMS_contactor_weld_rev 
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_polarity_response=1
    
    fault_name="BMS_weld_reverse_protection"
    error_name="BMS_Contactor_Weld"

    print_with_log("Checking "+fault_name)
    master_swt_on()
    sleep(5)    
    if(not initial_condition_check()):
        return
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_contactor_weld_rev=1
    bms_send_flag=1
    update_cp_state(4) 
    emulate_gun_lock()

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    BMS_contactor_weld_rev=0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            break
    
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

###########"BMS_Contactor_Open":"BMS_Contactor_Open",

def BMS_contactor_open_protection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,polarity_rev_flag,BMS_contactor_weld_forward,BMS_contactor_open_flag 
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    correct_polarity_response=1
    

    fault_name="BMS_contactor_open_protection"
    error_name="BMS_Contactor_Open"

    print_with_log("Checking "+fault_name)
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    BMS_contactor_open_flag=1
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    
    while(ota_can_dict["CC_On_Req"]==0):
        print_with_log("waiting for CMS to request closing BMS contactor")
        sleep(0.1)
    print_with_log("CMS requesting BMS contactor closing")
    

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    BMS_contactor_open_flag=0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            break
    
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()
 
###########"Gun_Temp_Sense_Open":"GunTemp_Sense_Open_Warning",

def GunTemp_Sense_Open_Warning_low(num):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_activation=-25
    gun_temp_opne_warning_deactivation=10

    fault_name="GunTemp_Sense_Open_Warning_low"
    error_name="Gun_Temp_Sense_Open"
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]
    gun_relay_name=gun_relay_names_list[num-1]
    
    gun_temp_can_list=["gun_temp_p_1","gun_temp_p_2","gun_temp_n_1","gun_temp_n_2"]
    temp_can_msg=gun_temp_can_list[num-1]
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name+" for sensor: "+str(num))
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    set_temp(gun_temp_open_warning_activation)
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

def GunTemp_Sense_Open_Warning_high(num):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_open_warning_activation=115
    gun_temp_opne_warning_deactivation=95

    fault_name="GunTemp_Sense_Open_Warning_high"
    error_name="Gun_Temp_Sense_Open"
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]
    gun_relay_name=gun_relay_names_list[num-1]
    
    gun_temp_can_list=["gun_temp_p_1","gun_temp_p_2","gun_temp_n_1","gun_temp_n_2"]
    temp_can_msg=gun_temp_can_list[num-1]
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name+" for sensor: "+str(num))
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    set_temp(25)
    all_relay_states[gun_relay_name]=1
    sleep(5)
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    set_temp(gun_temp_open_warning_activation)    
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(gun_temp_opne_warning_deactivation)
    sleep(0.2)
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg]))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)
    all_relay_states[gun_relay_name]=0
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)


##########"Heater_Comm_Fail":"Heater_Comm_Fail",

def Heater_Comm_Fail_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data,heater_state,chiller_state
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Heater_Comm_Fail test")
    error_name="Heater_Comm_Fail"
    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    
    print_with_log("Heater_Comm_Fail error state: "+str(fault_dict_new["Heater_Comm_Fail"]))
    print_protection_status()
    

    
    if(fault_dict_new["Heater_Comm_Fail"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    set_slave_states(EM_state_in=True,heater_state_in=False,chiller_state_in=True)
    st_time=timer()
    while(fault_dict_new["Heater_Comm_Fail"]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("Heater_Comm_Fail error state: "+str(fault_dict_new["Heater_Comm_Fail"]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["Heater_Comm_Fail"]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=True)
    print_with_log("Restarted heater communication")
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new["Heater_Comm_Fail"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>20):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))
    
    print_with_log("Heater_Comm_Fail error state: "+str(fault_dict_new["Heater_Comm_Fail"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    if(fault_dict_new["Heater_Comm_Fail"]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    
    check_master_error_code_reset()

    
    emulate_gun_unlock()
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#########"Chiller_Comm_Fail":"Chiller_Comm_Fail",

def Chiller_Comm_Fail_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data,chiller_data,heater_state,chiller_state
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Chiller_Comm_Fail test")
    error_name="Chiller_Comm_Fail"
    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

   
    print_with_log("Chiller_Comm_Fail error state: "+str(fault_dict_new["Chiller_Comm_Fail"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    

    
    if(fault_dict_new["Chiller_Comm_Fail"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=False)
    print_with_log("Stopping chiller communication")

    st_time=timer()
    while(fault_dict_new["Chiller_Comm_Fail"]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log("Chiller_Comm_Fail error state: "+str(fault_dict_new["Chiller_Comm_Fail"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new["Chiller_Comm_Fail"]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=True)
    print_with_log("Restarting chiller communication")
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new["Chiller_Comm_Fail"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>20):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    

   
    print_with_log("Chiller_Comm_Fail error state: "+str(fault_dict_new["Chiller_Comm_Fail"]))
    print_protection_status()
   
    
    if(fault_dict_new["Chiller_Comm_Fail"]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()

    
    emulate_gun_unlock()
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()



#########"EnergyMeter_Comm_Fail":"EnergyMeter_Comm_Fail",

def EM_Comm_Fail_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data,chiller_data,heater_state,chiller_state
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting EM_Comm_Fail test")
    error_name="EnergyMeter_Comm_Fail"
    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("EnergyMeter_Comm_Fail error state: "+str(fault_dict_new["EnergyMeter_Comm_Fail"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    

    
    if(fault_dict_new["EnergyMeter_Comm_Fail"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    set_slave_states(EM_state_in=False,heater_state_in=True,chiller_state_in=True)
    print_with_log("Stopping EM communication")

    st_time=timer()
    while(fault_dict_new["EnergyMeter_Comm_Fail"]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("EnergyMeter_Comm_Fail error state: "+str(fault_dict_new["EnergyMeter_Comm_Fail"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["EnergyMeter_Comm_Fail"]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=True)
    print_with_log("Restarting EM communication")
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new["EnergyMeter_Comm_Fail"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>20):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    

    
    print_with_log("EnergyMeter_Comm_Fail error state: "+str(fault_dict_new["EnergyMeter_Comm_Fail"]))
    print_protection_status()
    
    if(fault_dict_new["EnergyMeter_Comm_Fail"]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()

    
    emulate_gun_unlock()
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#########"smoke sensor_detect":"None",

def smoke_sensor_detect_protection_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    start_charge_function()
    error_name="smoke sensor_detect"

    sleep(5)
    if(not initial_condition_check()):
        return
    print_with_log("Starting smoke_sensor_detect_protection_test")
    print_protection_status()
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        print(fault_dict_new)
        return


    print_with_log("Activating smoke fault")
    all_relay_states["Smoke sensor out"]=1
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>5):
            print_with_log("Fault activation timeout. Test fail")
            break
    dur=timer()-st_time

    # print(fault_dict_new["SPD Fault"])
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault activation pass in time: "+str(dur))
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")        
        return
    sleep(1)

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    print_protection_status()
    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0,
        drain_prot_status=1,
    )
    if(res==True):
        print_with_log("Protection ok as expected.Pass")
    else:
        print_with_log("Protection ok not as expected.fail")
    
    # update_cp_state(4)
    all_relay_states["Smoke sensor out"]=0
    sleep(8)
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault not deactivation with only detection off pass")
    else:
        print_with_log("Fault deactivating with only detection off. fail")        
        return
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation with SPD and CP pass")
    else:
        print_with_log("Fault deactivating fail")
        print(fault_dict_new)
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()
  

########"Phase reversal":"None",
def phase_reversal_test():
    pass
####TODO

def current_sensor_Low_Temp_fault_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data,chiller_data,heater_state,chiller_state
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting current_sensor_Low_Temp_fault test")
    error_name="current_sensor_Low_Temp_fault"
    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    if(fault_dict_new["current_sensor_Low_Temp_fault"]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    base_gain,base_offset,base_temp=get_current_parameters()
    print_with_log("base gain: "+str(base_gain)+" base_offset: "+str(base_offset))

    set_current_sensor_body_temp(-5)    
    sleep(1)
    t_val=CMS_internal_can_dict["dc_current_sensor_body_temp"]
    print_with_log("Setting low current sesnor body temp to: "+str(t_val))


    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log(str(error_name)+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    new_gain,new_offset,new_temp=get_current_parameters()
    print_with_log("new gain: "+str(new_gain)+" new_offset: "+str(new_offset))

    if(new_gain == base_gain and new_offset == base_offset):
        print_with_log(" Gain and offset values not changed with protection. test fail")
    else:
        print_with_log(" Gain and offset values changed with protection. test pass")


    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    reset_currrent_sensor_body_temp()
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>20):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))
    
    print_with_log("error state: "+str(fault_dict_new[error_name]))
    print_protection_status()
    
    if(fault_dict_new[error_name]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    
    emulate_gun_unlock()
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


def current_sensor_High_Temp_fault_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data,chiller_data,heater_state,chiller_state
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting current_sensor_high_Temp_fault test")
    error_name="current_sensor_high_Temp_fault"
    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("current_sensor_high_Temp_fault error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    base_gain,base_offset,base_temp=get_current_parameters()
    print_with_log("base gain: "+str(base_gain)+" base_offset: "+str(base_offset))

    set_current_sensor_body_temp(100)    
    sleep(1)
    t_val=CMS_internal_can_dict["dc_current_sensor_body_temp"]
    print_with_log("Setting high current sesnor body temp to: "+str(t_val))


    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log(str(error_name)+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    new_gain,new_offset,new_temp=get_current_parameters()
    print_with_log("new gain: "+str(new_gain)+" new_offset: "+str(new_offset))

    if(new_gain == base_gain and new_offset == base_offset):
        print_with_log(" Gain and offset values not changed with protection. test fail")
    else:
        print_with_log(" Gain and offset values changed with protection. test pass")


    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    reset_currrent_sensor_body_temp()
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>20):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))
    
    print_with_log("error state: "+str(fault_dict_new[error_name]))
    print_protection_status()
    
    if(fault_dict_new[error_name]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    
    emulate_gun_unlock()
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#endregion

#region mechanical

#########"Chiller_fault_detection":"Chiller_fault_detection",

def chiller_faul_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,chiller_fault_list
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Chiller_fault_detection"
    print_with_log("Starting chiller_faul_detection test")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    for k in chiller_data.keys():
        if(k  in chiller_fault_list):
            print_with_log("Checking fault detection for: "+str(k))
            print_protection_status()
            print_with_log("Chiller_fault_detection error state: "+str(fault_dict_new["Chiller_fault_detection"]))
            protection_states=get_protection_states()
            print_with_log(protection_states)

            res=evaluate_protection_state(
                input_power_protection_status=1,
                output_power_protection_status=1,
                fcs_heating_protection_status=1,
                e_plug_protection_status=1,
                bms_protection_status=1,
                charging_algo_protections_status=1,
                fcs_cooling_protection_status=1,
                fcs_int_cooling_prot_status=1
            )
            if(fault_dict_new["Chiller_fault_detection"]==0 and res):
                print_with_log("Initial condition pass")
            else:
                print_with_log("Initial condition fail")
                
            if(k=="chiller_liquid_line_probe_fail"):
                k="chiller_room_temp_probe_fail"

            chiller_data[k]=1
            st_time=timer()
            fail=0
            while(fault_dict_new["Chiller_fault_detection"]==0):
                print_with_log("waiting for fault activation")
                sleep(1)
                if(timer()-st_time>20):
                    print_with_log("fault activation timeout. test fail")
                    fail=1
                    break
                    
            if(fail==0):                    
                print_with_log("Fault activated in time: "+str(timer()-st_time))
                sleep(1)

                
                print_with_log("Chiller_fault_detection error state: "+str(fault_dict_new["Chiller_fault_detection"]))
                print_protection_status()

                res=evaluate_protection_state(
                    input_power_protection_status=1,
                    output_power_protection_status=1,
                    fcs_heating_protection_status=1,
                    e_plug_protection_status=1,
                    bms_protection_status=1,
                    charging_algo_protections_status=1,
                    fcs_cooling_protection_status=1,
                    fcs_int_cooling_prot_status=0)
                
                if(fault_dict_new["Chiller_fault_detection"]==1 and res):
                    print_with_log("Fault activation pass")
                    print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
                else:
                    print_with_log("Fault activation fail")
                
                compare_fault_code_structure()
                check_master_session_code(error_name)
                sleep(1)
                display_check=0
                if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
                        check_display_activity_id(type="protection",name=error_name)
                        display_check=1
         

                    
                chiller_data[k]=0
                print_with_log("Starting deactivation")
                ### if display check happened for charge continue
                if(display_check==1):
                    gun_remove_function(activity_id_check=-1)
                ### if display check has to be done after gun unlock cmd
                else:
                    gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

                st_time=timer()                
                while(fault_dict_new["Chiller_fault_detection"]==1):
                    sleep(3)
                    print_with_log("waiting for fault deactivation")
                    if(timer()-st_time>250):
                        print_with_log("fault decativation timeout.Test fail")
                        break
                dur=timer()-st_time
               
                print_with_log("Chiller_fault_detection error state: "+str(fault_dict_new["Chiller_fault_detection"]))                
                
                if(fault_dict_new["Chiller_fault_detection"]==0):
                    print_with_log("Fault deactivation pass in time."+str(dur))
                else:
                    print_with_log("Fault deactivation fail")
                check_master_error_code_reset()
                
                master_swt_off()
                sleep(2)
                start_charge_function()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

########"AFT_fault":"AFT_fault",

def chiller_aft_fault_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="chiller_aft_fault"
    error_name="AFT_fault"

    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    print_with_log("Checking fault detection for: "+fault_name)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
            " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log("Chiller_fault_detection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    chiller_data[fault_name]=1
    
    chiller_data["chiller_liquid_temp"]=11
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    chiller_reset_state=CMS_internal_can_dict["chiller_reset"]
    print_with_log("CHiller reset val after fault activation: "+str(chiller_reset_state))

    if(chiller_reset_state ==0):
        print_with_log("Chiller reset pass")
    else:
        print_with_log("Chiller reset fail")  

    chiller_data[fault_name]=0
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(3)
        if(timer()-st_time>200):
            print_with_log("fault deactivation timeout. test fail")
            break

    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    
    else:
        print_with_log("Fault deactivation fail")
    
    check_master_error_code_reset()

    chiller_reset_state=CMS_internal_can_dict["chiller_reset"]
    print_with_log("CHiller reset val after fault activation: "+str(chiller_reset_state))

    if(chiller_reset_state ==1):
        print_with_log("Chiller reset restart pass")
    else:
        print_with_log("Chiller reset restart fail")  

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

######"AFT_fault_cms_computed":"None",

def AFT_fault_cms_computed_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="AFT_fault_cms_computed"
    error_name="AFT_fault_cms_computed"

    
    print_with_log("master on")
    start_charge_function()
    if(not initial_condition_check()):
        return
    print_with_log("Checking fault detection for: "+fault_name)

    
    print_with_log("AFT_fault_cms_computed error state: "+str(fault_dict_new[error_name]))
   
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    
    chiller_data["chiller_aft_temp"]=3
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    chiller_data["chiller_aft_temp"]=5
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(3)
        if(timer()-st_time>200):
            print_with_log("fault deactivation timeout. test fail")
            break
    dur=timer()-st_time

    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass in time: "+str(dur))
    
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#######"HP_fault":"HP_fault",

def chiller_hp_fault_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="chiller_hp_fault"
    error_name="HP_fault"

    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("Checking fault detection for: "+fault_name)

   
    print_with_log("Chiller_fault_detection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    chiller_data[fault_name]=1
    
    chiller_data["chiller_liquid_temp"]=12
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    sleep(1)
    chiller_reset_state=CMS_internal_can_dict["chiller_reset"]
    print_with_log("CHiller reset val after fault activation: "+str(chiller_reset_state))

    if(chiller_reset_state ==0):
        print_with_log("Chiller reset pass")
    else:
        print_with_log("Chiller reset fail")

    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1
 

    chiller_data[fault_name]=0
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(3)
        if(timer()-st_time>800):
            print_with_log("fault deactivation timeout. test fail")
            break
    dur=timer()-st_time

    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass in time: "+str(dur))
    
    else:
        print_with_log("Fault deactivation fail")
    
    check_master_error_code_reset()
    chiller_reset_state=CMS_internal_can_dict["chiller_reset"]
    print_with_log("CHiller reset val after fault deactivation: "+str(chiller_reset_state))

    if(chiller_reset_state ==1):
        print_with_log("Chiller reset started pass")
    else:
        print_with_log("Chiller reset start fail")


    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

########"Chiller Low water level fault":"Chiller Low water level fault",
def chiller_low_liquid_level_fault_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="chiller_low_liquid_level_fault"
    error_name="Chiller Low water level fault"

    
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("Checking fault detection for: "+fault_name)
   
    print_with_log("Chiller_fault_detection error state: "+str(fault_dict_new[error_name]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    chiller_data[fault_name]=1
    
    chiller_data["chiller_liquid_temp"]=10
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    chiller_data[fault_name]=0
        
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(3)
        if(timer()-st_time>30):
            print_with_log("fault deactivation timeout. test fail")
            break
    dur=timer()-st_time    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass in time: "+str(dur))
    
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


########"Chiller_recoverable_faults":"None",

def chiller_recoverable_faul_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,chiller_fault_list

    chiller_recoverable_fault_list=["chiller_room_temp_probe_ht_fault",
                    "chiller_room_temp_probe_lt_fault",
                    "chiller_fls_fault",                    
                    "chiller_liquid_line_high_temp_fault",
                    "chiller_high_temp_fault"]
    
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Chiller_recoverable_faults"
    print_with_log("Starting Chiller_recoverable_faults test")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    for k in chiller_data.keys():
        if(k  in chiller_recoverable_fault_list):
            print_with_log("Checking fault detection for: "+str(k))
            print_protection_status()
            print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))           

            res=evaluate_protection_state(
                input_power_protection_status=1,
                output_power_protection_status=1,
                fcs_heating_protection_status=1,
                e_plug_protection_status=1,
                bms_protection_status=1,
                charging_algo_protections_status=1,
                fcs_cooling_protection_status=1,
                fcs_int_cooling_prot_status=1
            )
            if(fault_dict_new[error_name]==0 and res):
                print_with_log("Initial condition pass")
            else:
                print_with_log("Initial condition fail")
            
        
            chiller_data[k]=1
            st_time=timer()
            fail=0
            while(fault_dict_new[error_name]==0):
                print_with_log("waiting for fault activation")
                sleep(1)
                if(timer()-st_time>20):
                    print_with_log("fault activation timeout. test fail")
                    fail=1
                    break
                    
            if(fail==0):                    
                print_with_log("Fault activated in time: "+str(timer()-st_time))
                sleep(1)
                
                print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
                print_protection_status()

                res=evaluate_protection_state(
                    input_power_protection_status=1,
                    output_power_protection_status=1,
                    fcs_heating_protection_status=1,
                    e_plug_protection_status=1,
                    bms_protection_status=1,
                    charging_algo_protections_status=1,
                    fcs_cooling_protection_status=1,
                    fcs_int_cooling_prot_status=0)
                
                if(fault_dict_new[error_name]==1 and res):
                    print_with_log("Fault activation pass")
                    print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
                else:
                    print_with_log("Fault activation fail")
                
                compare_fault_code_structure()
                check_master_session_code(error_name)
                sleep(1)
                display_check=0
                if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
                        check_display_activity_id(type="protection",name=error_name)
                        display_check=1
        

                    
                chiller_data[k]=0
                print_with_log("Starting deactivation")
                ### if display check happened for charge continue
                if(display_check==1):
                    gun_remove_function(activity_id_check=-1)
                ### if display check has to be done after gun unlock cmd
                else:
                    gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

                st_time=timer()                
                while(fault_dict_new[error_name]==1):
                    sleep(3)
                    print_with_log("waiting for fault deactivation")
                    if(timer()-st_time>30):
                        print_with_log("fault decativation timeout.Test fail")
                        break
                dur=timer()-st_time
               
                print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))                
                
                if(fault_dict_new[error_name]==0):
                    print_with_log("Fault deactivation pass in time."+str(dur))
                else:
                    print_with_log("Fault deactivation fail")
                
                check_master_error_code_reset()
                
                master_swt_off()
                sleep(2)
                start_charge_function()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

##########"Chiller LP fault":"Chiller LP fault",

def chiller_LP_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting chiller_LP_fault test")
    error_name="Chiller LP fault"
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    chiller_data["chiller_lp_fault"] =1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("Starting non deactivation")
    chiller_data["chiller_lp_fault"] =0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    print_with_log("waiting for 200 sec")
    sleep(200)

    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#########"Pump_Overload_fault":"Pump_Overload_fault",

def pump_overload_fault_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,polarity_rev_flag,BMS_contactor_weld_forward,BMS_contactor_open_flag 
    

    fault_name="Pump_Overload_fault"
    error_name="Pump_Overload_fault"

    print_with_log("Checking "+fault_name)
    start_charge_function()
    sleep(5)    
    if(not initial_condition_check()):
        return    
    print_with_log(fault_name+" error state: "+str(fault_dict_new[error_name]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    chiller_data["chiller_pump_overload_fault"]=1
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>150):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_protection_status()
    print_with_log(fault_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    chiller_data["chiller_pump_overload_fault"]=0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(5)
        if(timer()-st_time>200):
            print_with_log("fault deactivation timeout.")
            break
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivated in time: "+str(timer()-st_time))
        sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non deactivation fail")
    else:
        print_with_log("Fault non deactivation pass")
    check_master_error_code_reset()
    
    sleep(2)
    all_ard_state_reset()

########"chiller_compressor_overload_fault":"None",

def chiller_compressor_overload_fault_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,polarity_rev_flag,BMS_contactor_weld_forward,BMS_contactor_open_flag 
    

    fault_name="chiller_compressor_overload_fault"
    error_name="chiller_compressor_overload_fault"

    print_with_log("Checking "+fault_name)
    start_charge_function()
    sleep(5)    
    if(not initial_condition_check()):
        return    
    print_with_log(fault_name+" error state: "+str(fault_dict_new[error_name]))
    

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    chiller_data["chiller_compressor_overload_fault"]=1
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>150):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)    
    print_with_log(fault_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    chiller_data["chiller_compressor_overload_fault"]=0
   

    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(5)
        if(timer()-st_time>200):
            print_with_log("fault deactivation timeout.")
            break
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivated in time: "+str(timer()-st_time))
        sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")

    check_master_error_code_reset()
    
    sleep(2)
    all_ard_state_reset()

########"Chiller Non recoverable faults":"None",

def chiller_non_recoverable_faul_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,chiller_fault_list

    chiller_non_recoverable_fault_list=["chiller_aft_probe_fail",   
                                        "chiller_liquid_line_probe_fail",
                                        "chiller_pump_overload_fault",                    
                                        "chiller_lp_fault"]
    
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Chiller Non recoverable faults"
    print_with_log("Starting Chiller Non recoverable faults test")
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    for k in chiller_data.keys():
        if(k  in chiller_non_recoverable_fault_list):
            print_with_log("Checking fault detection for: "+str(k))
            print_protection_status()
            print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))           

            res=evaluate_protection_state(
                input_power_protection_status=1,
                output_power_protection_status=1,
                fcs_heating_protection_status=1,
                e_plug_protection_status=1,
                bms_protection_status=1,
                charging_algo_protections_status=1,
                fcs_cooling_protection_status=1,
                fcs_int_cooling_prot_status=1
            )
            if(fault_dict_new[error_name]==0 and res):
                print_with_log("Initial condition pass")
            else:
                print_with_log("Initial condition fail")
                
            if(k=="chiller_liquid_line_probe_fail"):
                k="chiller_room_temp_probe_fail"
            chiller_data[k]=1
            st_time=timer()
            fail=0
            while(fault_dict_new[error_name]==0):
                print_with_log("waiting for fault activation")
                sleep(1)
                if(timer()-st_time>20):
                    print_with_log("fault activation timeout. test fail")
                    fail=1
                    break
                    
            if(fail==0):                    
                print_with_log("Fault activated in time: "+str(timer()-st_time))
                sleep(1)
                
                print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
                print_protection_status()

                res=evaluate_protection_state(
                    input_power_protection_status=1,
                    output_power_protection_status=1,
                    fcs_heating_protection_status=1,
                    e_plug_protection_status=1,
                    bms_protection_status=1,
                    charging_algo_protections_status=1,
                    fcs_cooling_protection_status=1,
                    fcs_int_cooling_prot_status=0)
                
                if(fault_dict_new[error_name]==1 and res):
                    print_with_log("Fault activation pass")
                    print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
                else:
                    print_with_log("Fault activation fail")
                
                compare_fault_code_structure()
                check_master_session_code(error_name)
                sleep(1)
                display_check=0
                if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
                        check_display_activity_id(type="protection",name=error_name)
                        display_check=1
      

                    
                chiller_data[k]=0
                print_with_log("Starting deactivation")
                ### if display check happened for charge continue
                if(display_check==1):
                    gun_remove_function(activity_id_check=-1)
                ### if display check has to be done after gun unlock cmd
                else:
                    gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

                st_time=timer()                
                while(fault_dict_new[error_name]==1):
                    sleep(3)
                    print_with_log("waiting for fault deactivation")
                    if(timer()-st_time>30):
                        print_with_log("fault decativation timeout.Test fail")
                        break
                dur=timer()-st_time
               
                print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))                
                
                if(fault_dict_new[error_name]==0):
                    print_with_log("Fault deactivation pass in time."+str(dur))
                else:
                    print_with_log("Fault deactivation fail")
                check_master_error_code_reset() 
                
                master_swt_off()
                sleep(2)
                start_charge_function()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#######"Chiller_LiquidTemp_Inlet_outlet_water temp offset":"None",

def Chiller_LiquidTemp_Inlet_outlet_water_temp_offset():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="Chiller_LiquidTemp_Inlet_outlet_water temp offset"
    error_name="Chiller_LiquidTemp_Inlet_outlet_water temp offset"

    
    can_msg_inlet="water_inlet_temperature"
    can_msg_chiller="chiller_liquid_temp"
    all_relay_states["CON_WATER_INLET"]=1 ## inlet temp relay
    set_temp(10)    
    chiller_data["chiller_liquid_temp"]=10
    start_charge_function()
    sleep(5)    
    chiller_data["chiller_liquid_temp"]=CMS_internal_can_dict[can_msg_inlet]
    sleep(5)
    print_with_log("chiller_temp: "+str(CMS_internal_can_dict[can_msg_chiller])+" inlet_temp: "+str(CMS_internal_can_dict[can_msg_inlet]))
    if(not initial_condition_check()):
        return
    

    print_with_log("Checking "+fault_name)    
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=3):
        print_with_log("waiting for precooling to start")
        sleep(2)
        if(timer()-st_time>100):
            print_with_log("precooling not starting.test fail")
            return
    print_with_log("Precooling started")
    sleep(10)
    print_with_log("Checking no activation with no offset")
    if(fault_dict_new[error_name]==0):
        print_with_log("Non activation pass")
    else:
        print_with_log("Non activation fail")

    print_with_log("Checking non activation with 8 degree diff")
    set_temp(18)
    sleep(2)
    chiller_data["chiller_liquid_temp"]=CMS_internal_can_dict[can_msg_inlet] -8    
    sleep(5)
    print_with_log("chiller_temp: "+str(CMS_internal_can_dict[can_msg_chiller])+" inlet_temp: "+str(CMS_internal_can_dict[can_msg_inlet]))

    if(fault_dict_new[error_name]==0):
        print_with_log("Non activation pass")
    else:
        print_with_log("Non activation fail")

    print_with_log("Checking non activation with negative diff")
    set_temp(10)
    sleep(2)
    chiller_data["chiller_liquid_temp"]= int(CMS_internal_can_dict[can_msg_inlet])+12
    sleep(20)
    print_with_log("chiller_temp: "+str(CMS_internal_can_dict[can_msg_chiller])+" inlet_temp: "+str(CMS_internal_can_dict[can_msg_inlet]))

    if(fault_dict_new[error_name]==0):
        print_with_log("Non activation pass")
    else:
        print_with_log("Non activation fail")
    
    print_with_log("Checking fault activation")
    set_temp(20)
    sleep(2)
    chiller_data["chiller_liquid_temp"]= int(CMS_internal_can_dict[can_msg_inlet])-12    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break            
    print_with_log("chiller_temp: "+str(CMS_internal_can_dict[can_msg_chiller])+" inlet_temp: "+str(CMS_internal_can_dict[can_msg_inlet]))
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault activated in time: "+str(timer()-st_time))    
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("Setting temperature to deactivation limit")
    chiller_data["chiller_liquid_temp"]= int(CMS_internal_can_dict[can_msg_inlet])-8
    sleep(10)    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()
    sleep(10)
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault  non deactivation fail")
    else:
        print_with_log("Fault  non deactivation pass")

    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    
    print_with_log("checking deactivation after gun removal")
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault  deactivation pass")
    else:
        print_with_log("Fault  deactivation fail")
    check_master_error_code_reset()
    all_relay_states["CON_WATER_INLET"]=0
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

#######"Battery_Conditioning_failed_High Liq Temp":"Battery_Conditioning_failed_High_Liq_Temp",

def battery_conditioning_fail_high_chiller_temp_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Battery_Conditioning_failed_High Liq Temp"
    print_with_log("Starting Battery_Conditioning_failed_High_Liq_Temp test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    update_cp_state(6)
    sleep(3)
    
        
    chiller_data["chiller_liquid_temp"]=17
    sleep(2)
    print_with_log("CHiller temp: "+str(CMS_internal_can_dict['chiller_liquid_temp']))
    
    print_protection_status()
    
    print_with_log("Battery_Conditioning_failed_High_Liq_Temp error state: "+str(fault_dict_new[error_name]))
    print_with_log("Charging_Algorithm_Protections_OK "+str(CMS_internal_can_dict["charging_algo_protections_status"]))

    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return    
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=3):
        print_with_log("waiting for pre-cooling to start")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("pre_cooling start timeout")
            return False
        
    print_with_log("Starting pre_cooling")    
    dur=0
    st_time=timer()
    sleep(2)
    
    # chiller_data["chiller_liquid_temp"]=10
    # sleep(2)
    print_with_log("CHiller temp: "+str(CMS_internal_can_dict['chiller_liquid_temp']))
    while(fault_dict_new[error_name]==0):
        dur=timer()-st_time        
        print_with_log("Waiting for fault trigger for time: "+str(dur))
        sleep(5)
        if(timer()-st_time>1000):
            print_with_log("timeout. test fail")
            return

    


    print_protection_status()
    print_with_log("Battery_Conditioning_failed_High_Liq_Temp error state: "+str(fault_dict_new[error_name]))
    print_with_log("Charging_Algorithm_Protections_OK "+str(CMS_internal_can_dict["charging_algo_protections_status"]))

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )


    if(res==True and fault_dict_new[error_name]==1):
        print_with_log("Battery Conditioning failed activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Battery Conditioning failed activation fail")
        

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    if(fault_dict_new[error_name]==0):
        print_with_log("Battery Conditioning failed high temp deactivation pass")        
    else:
        print_with_log("Battery Conditioning failed high temp deactivation fail")   
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    
    chiller_data["chiller_liquid_temp"]=10
    sleep(3)
    all_ard_state_reset()

#########"Battery_Conditioning_cooling_failed":"Battery Conditioning failed",

def battery_conditioning_cooling_fail_test(exp_time=400):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Battery_Conditioning_cooling_failed"
    print_with_log("Starting battery conditining fail fault activation")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=3):
        print_with_log("waiting for pre-cooling to start")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("pre_cooling start timeout.Test fail")
            return False


    print_with_log("Starting pre_cooling")    
    print_protection_status()
    print_with_log("Battery Conditioning failed error state: "+str(fault_dict_new[error_name]))
    print_with_log("Charging_Algorithm_Protections_OK "+str(CMS_internal_can_dict["charging_algo_protections_status"]))
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    dur=0
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        dur=timer()-st_time        
        print_with_log("Waiting for fault trigger for time: "+str(dur))
        sleep(5)
        if(timer()-st_time>1000):
            print_with_log("timeout. test fail")
            return

    print_with_log("Fault trigger timing: "+str(timer()-st_time))
    duration_obs=timer()-st_time
    if(abs(duration_obs-exp_time)<30):
        print_with_log("Timeout in expected time. Test pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Timeout not in expected time. Test fail")


    print_protection_status()
    print_with_log("Battery Conditioning failed error state: "+str(fault_dict_new[error_name]))
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )

    if(res==True):
        print_with_log("No protection activated.test pass")
    else:
        print_with_log("protection activated.test fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    
    sleep(5)
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(2)
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")        
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()   
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(3)
    all_ard_state_reset()

def get_chiller_setting_can_info():
    global CMS_internal_can_dict
    out_dict={
        "chiller_remote_strt_setting_ok":-1,
        "chiller_aft_diff_setting_ok":-1,
        "chiller_aft_set_setting_ok":-1,
        "chiller_lt_alrm_setting_ok":-1,
        "chiller_ht_alrm_setting_ok":-1,
        "chiller_diff_setting_ok":-1,
        "chiller_set_point_setting_ok":-1,
        "chiller_low_set_setting_ok":-1,
        "chiller_high_set_setting_ok":-1,
        "chiller_settings_ok":-1,
        "chiller_comm_status":-1,
        
    }
    for k in out_dict.keys():
        out_dict[k]=CMS_internal_can_dict[k]
    
    return out_dict


#######"Chiller_Settings_Check":"None",
def Chiller_Setting_Error_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Chiller_Setting_Error"
    error_name2="Chiller_Remote_Logic_fault"
    print_with_log("Starting Chiller_Setting_Error fault activation")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    reset_all_chiller_data()
    update_cp_state(6)

    st_time=timer()
    while(CMS_internal_can_dict["chiller_settings_ok"]!=1):
        sleep(1)
        print_with_log("waiting for chiller setting to be ok")
        if(timer()-st_time>15):
            print_with_log("chiller setting not becoming ok.timeout.Test fail")
            return False
    sleep(5)

    chiller_setting_data_can_mapping={
        "chiller_set_high_set":"chiller_high_set_setting_ok",
        "chiller_set_low_set":"chiller_low_set_setting_ok",
        "chiller_set_set_point":"chiller_set_point_setting_ok",
        "chiller_set_differential":"chiller_diff_setting_ok",
        "chiller_set_high_temp_alarm":"chiller_ht_alrm_setting_ok",
        "chiller_set_low_temp_alarm":"chiller_lt_alrm_setting_ok",
        "chiller_set_aft_set_temp":"chiller_aft_set_setting_ok",
        "chiller_set_aft_differential":"chiller_aft_diff_setting_ok",
        "chiller_remote_start":"chiller_remote_strt_setting_ok",

    }

    for k in chiller_setting_data_can_mapping.keys():
        print_with_log("Checking chiller setting fault for: "+str(k))       
        
        print_with_log("Making offset in set chiller data")
        add_chiller_setting_offset(k)

        st_time=timer()
        while(CMS_internal_can_dict[chiller_setting_data_can_mapping[k]] != 0):
            sleep(1)
            print_with_log("waiting for can chiller setting to be not ok")
            if(timer()-st_time>15):
                print_with_log("chiller setting not chnaging.timeout.Test fail")
                break

        sleep(2)
        res_dict=get_chiller_setting_can_info()
        print_with_log(res_dict)

        r=1
        for d in res_dict.keys():
            expected_data=1
            if(d in [chiller_setting_data_can_mapping[k],"chiller_settings_ok"]):
                expected_data=0
            if(res_dict[d] != expected_data):
                r=0
        
        if(r==1):
            print_with_log("Chiller setting ok data in CAN pass")
        else:
            print_with_log("Chiller setting ok data in CAN fail")

        st_time=timer()
        while(fault_dict_new[error_name] != 1):
            sleep(1)
            print_with_log("waiting for fault activation")
            if(timer()-st_time>15):
                print_with_log("fault activation timeout.Test fail")
                break
        sleep(2)
        if(fault_dict_new[error_name] ==1):
            print_with_log("Fault activation pass")
        else:
            print_with_log("Fault activation fail")
        
        if(k == "chiller_remote_start"):
            st_time=timer()
            while(fault_dict_new[error_name2] !=1):
                sleep(1)
                print_with_log("waiting for fault2 activation")
                if(timer()-st_time>15):
                    print_with_log("fault activation2 timeout.Test fail")
                    break
            sleep(2)
            if(fault_dict_new[error_name2] ==1):
                print_with_log("Fault activation pass")
            else:
                print_with_log("Fault activation fail")

        res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
        )
        if(res==True):
            print_with_log("Protection states in activated state pass")
        else:
            print_with_log("Protection states in activated state fail")

        print_with_log("Resetting all chiller data")
        reset_all_chiller_data()

        st_time=timer()
        while(CMS_internal_can_dict["chiller_settings_ok"] != 1):
            sleep(1)
            print_with_log("waiting for chiller setting to be ok")
            if(timer()-st_time>15):
                print_with_log("chiller setting not becoming ok.timeout.Test fail")
                break
        sleep(2)
        

        res_dict=get_chiller_setting_can_info()

        print_with_log(res_dict)

        if(0 in list(res_dict.values())):
            print_with_log("Chiller CAN data reset failed.")
        else:
            print_with_log("Chiller CAN data reset Pass.")

        st_time=timer()
        while(fault_dict_new[error_name] !=0):
            sleep(1)
            print_with_log("waiting for fault deactivation")
            if(timer()-st_time>15):
                print_with_log("fault deactivation timeout.Test fail")
                break
        sleep(2)
        if(fault_dict_new[error_name] ==0):
            print_with_log("Fault deactivation pass")
        else:
            print_with_log("Fault deactivation fail")

        if(k == "chiller_remote_start"):
            st_time=timer()
            while(fault_dict_new[error_name2] !=0):
                sleep(1)
                print_with_log("waiting for fault2 deactivation")
                if(timer()-st_time>15):
                    print_with_log("fault2 deactivation timeout.Test fail")
                    break
            sleep(2)
            if(fault_dict_new[error_name2] ==0):
                print_with_log("Fault deactivation pass")
            else:
                print_with_log("Fault deactivation fail")


        res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
        )
        if(res==True):
            print_with_log("Protection states in deactivated  state pass")
        else:
            print_with_log("Protection states in deactivated  state  fail")

    # for k in chiller_setting_data_can_mapping.keys():
    #     print_with_log("Checking chiller setting fault for: "+str(k))
    #     add_chiller_setting_offset(k)
    #     sleep(30)
    #     reset_all_chiller_data()
    #     sleep(30)



    reset_all_chiller_data()        
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(3)
    all_ard_state_reset()


##TODO

#########"Cold_Tank_Low_Liquid_Warning":"Cold_Tank_Low_Liquid_Warning",

def cold_tank_low_liquid_level_fault_detection():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="Cold_Tank_Low_Liquid_Warning"
    error_name="Cold_Tank_Low_Liquid_Warning"

    
    print_with_log("master on")
    start_charge_function()
    if(not initial_condition_check()):
        return
    
    print_with_log("Checking fault detection for: "+fault_name)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
            " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log("Chiller_fault_detection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    all_relay_states["Cold tank level out"]=1
    
    chiller_data["chiller_liquid_temp"]=10
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

        
    all_relay_states["Cold tank level out"]=0
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(2)
        if(timer()-st_time>30):
            print_with_log("fault deactivation timeout")
            break
    


    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Fault  deactivation pass")
    else:
        print_with_log("Fault  deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


########"Fluid_Inlet_High_Temp_Fault":"Fluid_Inlet_High_Temp_Fault",
def Fluid_Inlet_High_Temp_Fault_high_temp():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="Fluid_Inlet_High_Temp_Fault"
    error_name="Fluid_Inlet_High_Temp_Fault"
    heater_data["heater_tank_temperature"]=50
    heater_data["heater_set_point"]=50    
    can_msg="water_inlet_temperature"
    set_temp(50)
    start_charge_function()
    sleep(5)
    heater_data["heater_set_point"] = int(CMS_internal_can_dict[can_msg])
    if(not initial_condition_check()):
        return
    all_relay_states["CON_WATER_INLET"]=1

    print_with_log("Checking "+fault_name)
    emulate_min_max_temp(min_temp_val=12,max_temp_val=13)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=4):
        print_with_log("waiting for pre-heating to start")
        sleep(3)
        if(timer()-st_time>100):
            print_with_log("Preheating not started.test fail")
            return
    print_with_log("Preheating started")
    print_with_log("Checking fault activation with high inlet temp")

    set_temp(70)
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    print_with_log("Setting temperature to deactivation limit")
    set_temp(45)
    sleep(20)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault  non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(2)
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault  deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    all_relay_states["CON_WATER_INLET"]=0
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()


########"Fluid_Inlet_High_Temp_Fault":"Fluid_Inlet_High_Temp_Fault",
def Fluid_Inlet_High_Temp_Fault_offset():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="Fluid_Inlet_High_Temp_Fault"
    error_name="Fluid_Inlet_High_Temp_Fault"
    heater_data["heater_tank_temperature"]=50
    heater_data["heater_set_point"]=50    
    can_msg="water_inlet_temperature"
    set_temp(50)
    start_charge_function()
    sleep(5)
    heater_data["heater_set_point"] = int(CMS_internal_can_dict[can_msg])
    if(not initial_condition_check()):
        return
    all_relay_states["CON_WATER_INLET"]=1

    print_with_log("Checking "+fault_name)
    emulate_min_max_temp(min_temp_val=12,max_temp_val=13)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=4):
        print_with_log("waiting for pre-heating to start")
        sleep(3)
        if(timer()-st_time>100):
            print_with_log("Preheating not started.test fail")
            return
    print_with_log("Preheating started")
    print_with_log("Checking fault activation with set point offset")
    set_temp(60)
    sleep(1)
    heater_data["heater_set_point"]=CMS_internal_can_dict[can_msg] -8
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    print_with_log("Setting temperature to deactivation limit")
    set_temp(45)
    sleep(2)
    heater_data["heater_set_point"]=CMS_internal_can_dict[can_msg]
    sleep(20)
    
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    print_protection_status()
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault  non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)

    gun_remove_function()
    sleep(2)
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault  deactivation pass")
    else:
        print_with_log("Fault deactivation fail")

    check_master_error_code_reset()

    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    all_relay_states["CON_WATER_INLET"]=0
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

########"Battery_Conditioning_heating failed":"Battery Conditioning failed",

def battery_conditioning_heating_fail_test(exp_time=400):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Battery_Conditioning_heating failed"
    print_with_log("Starting battery conditining fail fault activation")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    emulate_min_max_temp(min_temp_val=12,max_temp_val=13)
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=4):
        print_with_log("waiting for pre-heating to start")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("pre_heating start timeout.Test fail")
            return False


    print_with_log("Starting pre_heating")    
    print_protection_status()
    print_with_log("Battery Conditioning failed error state: "+str(fault_dict_new[error_name]))
    print_with_log("Charging_Algorithm_Protections_OK "+str(CMS_internal_can_dict["charging_algo_protections_status"]))
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    dur=0
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        dur=timer()-st_time        
        print_with_log("Waiting for fault trigger for time: "+str(dur))
        sleep(5)
        if(timer()-st_time>1000):
            print_with_log("timeout. test fail")
            return

    print_with_log("Fault trigger timing: "+str(timer()-st_time))
    duration_obs=timer()-st_time
    if(abs(duration_obs-exp_time)<30):
        print_with_log("Timeout in expected time. Test pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Timeout not in expected time. Test fail")


    print_protection_status()
    print_with_log("Battery Conditioning failed error state: "+str(fault_dict_new[error_name]))
    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )

    if(res==True):
        print_with_log("No protection activated.test pass")
    else:
        print_with_log("protection activated.test fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    sleep(5)
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(2)
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")        
    else:
        print_with_log("Fault deactivation fail") 
    check_master_error_code_reset()  
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(3)
    emulate_min_max_temp(min_temp_val=25,max_temp_val=26)
    all_ard_state_reset()


##########"Hot_Tank_Low_Liquid_Warning":"Hot_Tank_Low_Liquid_Warning",
def hot_tank_low_water_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Heater_Low_Water_Level_Fault  test")
    error_name="Hot_Tank_Low_Liquid_Warning"

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    # heater_data["heater_fault_water_level_low"] =1
    all_relay_states["Hot tank level out"]=1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)    
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    # heater_data["heater_fault_water_level_low"] =0
    all_relay_states["Hot tank level out"]=0
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name] ==1):        
        sleep(5)
        if(timer()-st_time>250):
            print_with_log("fault deactivation timeout")
            break
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#########"CMS_HotTank_Overtemp_protect":"CMS_HotTank_Overtemp_protect",

def CMS_HotTank_Overtemp_protect_cms_sensor_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting CMS_HotTank_Overtemp_protect due to cms thermistor")
    error_name="CMS_HotTank_Overtemp_protect"

    set_temp(25)
    all_relay_states["CON_AMB_TS8"]=1
    heater_data["heater_tank_temperature"]=25
    sleep(2)

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("CMS_HotTank_Overtemp error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    

    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    set_temp(80)
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("CMS_HotTank_Overtemp error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(50)
    print_with_log("Deactivating high temperature")
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(15)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()
    heater_data["heater_tank_temperature"]=25
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

def CMS_HotTank_Overtemp_protect_heater_sensor_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting CMS_HotTank_Overtemp_protect due to heater data")
    error_name="CMS_HotTank_Overtemp_protect"

    set_temp(25)
    all_relay_states["CON_AMB_TS8"]=0
    heater_data["heater_tank_temperature"]=25
    sleep(2)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))

    print_with_log("master on")
    start_charge_function()

    if(not initial_condition_check()):
        return
    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("CMS_HotTank_Overtemp error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    set_temp(25)
    all_relay_states["CON_AMB_TS8"]=0
    heater_data["heater_tank_temperature"]=25
    sleep(2)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    heater_data["heater_tank_temperature"]=67   
    print_with_log("making heater data to 67") 
    sleep(1)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("CMS_HotTank_Overtemp error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    heater_data["heater_tank_temperature"]=40
    sleep(1)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))
    print_with_log("Deactivating high temperature")
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(15)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()
    heater_data["heater_tank_temperature"]=25
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


##########"CMS_HotTank_Overtemp_cutoff":"CMS_HotTank_Overtemp_cutoff",
def CMS_HotTank_Overtemp_cutoff_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data,all_relay_states
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1

    all_relay_states["Heater_contactor_fb_relay"]=0
    print_with_log("Starting CMS_HotTank_Overtemp_cutoff_test")
    error_name="CMS_HotTank_Overtemp_cutoff"

    set_temp(25)
    all_relay_states["CON_AMB_TS8"]=1
    heater_data["heater_tank_temperature"]=25
    sleep(2)

    start_charge_function()
    sleep(5)

    if(not initial_condition_check()):
        return
    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("CMS_HotTank_Overtemp_cutoff error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    set_temp(25)
    all_relay_states["CON_AMB_TS8"]=1
    heater_data["heater_tank_temperature"]=25
    sleep(2)

    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    print_with_log("Checking non activation with only protection")

    set_temp(80)
    heater_data["heater_tank_temperature"]=80

    print_with_log("waiting for 30 sec")
    sleep(30)
    if(fault_dict_new[error_name]==0):
        print_with_log("non activation pass")
    else:
        print_with_log("non activation fail")
    
    print_with_log("activating heater contactor fb")    
    all_relay_states["Heater_contactor_fb_relay"]=1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("CMS_HotTank_Overtemp_cutoff error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    set_temp(40)
    heater_data["heater_tank_temperature"]=40

    print_with_log("Deactivating high temperature")
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("fault deactivation timeout. test pass")
            break
    
    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("CMS_HotTank_Overtemp_cutoff error state: "+str(fault_dict_new[error_name]))

    if(fault_dict_new[error_name]==1):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()
    heater_data["heater_tank_temperature"]=25
    set_temp(25)

    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

########"Heater_Low_Temperature_Fault":"Heater_Low_Temperature_Fault",
def heater_low_temp_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting heater_low_temp_fault test")
    error_name="Heater_Low_Temperature_Fault"

    

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    heater_data["heater_fault_sts_lt"] =1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    heater_data["heater_fault_sts_lt"] =0
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault deactivation timeout. test fail")
            return
    
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

########"Heater_High_Temperature_Fault":"Heater_High_Temperature_Fault",
def heater_high_temp_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting heater_high_temp_fault test")
    error_name="Heater_High_Temperature_Fault"

    

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    heater_data["heater_fault_sts_ht"] =1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    heater_data["heater_fault_sts_ht"] =0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    print_with_log("waiting for 200 sec to check deactivation")
    sleep(200)

    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

##########"CMS_HotTank_open_Offset_Warning":"CMS_HotTank_open_Offset_Warning",

def CMS_HotTank_offset_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data,all_relay_states
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1

    all_relay_states["Heater_contactor_fb_relay"]=0
    print_with_log("Starting CMS_HotTank_open_Offset_Warning test")
    error_name="CMS_HotTank_open_Offset_Warning"

    set_temp(30)
    all_relay_states["CON_AMB_TS8"]=1
    heater_data["heater_tank_temperature"]=25    
    sleep(2)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))

    start_charge_function()
    sleep(20)

    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("CMS_HotTank_open_Offset_Warning error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)   
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    print_with_log("Checking non activation with lower offset")

    set_temp(35)
    heater_data["heater_tank_temperature"]=25
    sleep(1)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))

    print_with_log("waiting for 10 sec")
    sleep(10)
    if(fault_dict_new[error_name]==0):
        print_with_log("non activation pass")
    else:
        print_with_log("non activation fail")
    
    print_with_log("Checking activation with higher offset")
    set_temp(50)
    sleep(1)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("CMS_HotTank_open_Offset_Warning error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    set_temp(25)
    all_relay_states["CON_AMB_TS8"]=0
    heater_data["heater_tank_temperature"]=25
    sleep(1)
    print_with_log("CMS hot temp: "+str(CMS_internal_can_dict["hot_tank_temp"])+" heater temp: "+str(CMS_internal_can_dict["heater_tank_temperature"]))

    print_with_log("Deactivating offset temperature")
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault deactivation timeout. test fail")
            return
        
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("CMS_HotTank_open_Offset_Warning error state: "+str(fault_dict_new[error_name]))

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()
    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


#######"Heater_Low_Water_Level_Fault":"Heater_Low_Water_Level_Fault",

def heater_low_water_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Heater_Low_Water_Level_Fault  test")
    error_name="Heater_Low_Water_Level_Fault"

    

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    heater_data["heater_fault_water_level_low"] =1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    heater_data["heater_fault_water_level_low"] =0
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name] ==1):        
        sleep(5)
        if(timer()-st_time>250):
            print_with_log("fault deactivation timeout")
            break

    

    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


#########"Heater_Probe_Fault":"Heater_Probe_Fault",

def heater_probe_low_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Heater_Probe_Fault due to low fail test")
    error_name="Heater_Probe_Fault"

    

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    heater_data["heater_fault_sts_probe_fail_low"] =1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    heater_data["heater_fault_sts_probe_fail_low"] =0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(200)

    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


def heater_probe_high_fault():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Heater_Probe_Fault due to high fail test")
    error_name="Heater_Probe_Fault"

    

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    heater_data["heater_fault_sts_probe_fail_high"] =1
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"])+ " code_5: "+str(CMS_internal_can_dict["code_5"]))
    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))

    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    heater_data["heater_fault_sts_probe_fail_high"] =0
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(200)

    print_with_log(str(error_name)+" state: "+str(fault_dict_new[error_name]))
    
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()    
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


#######"MBV_Malfuntion":"MBV_Malfuntion",
def mbv_open_fault_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,mbv_open_fault_flag,mbv_close_fault_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    
    fault_name="MBV_open_fault"
    error_name="MBV_Malfuntion"

    print_with_log("Checking "+fault_name)
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return

    print_with_log("starting mbv_open fault")
    mbv_open_fault_flag=1

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=-1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=-1,
        bms_protection_status=-1,
        charging_algo_protections_status=-1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("stopping mbv_open fault")
    mbv_open_fault_flag=0


    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault deactivation timeout. test fail")
            break
            
        
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def mbv_close_fault_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,mbv_open_fault_flag,mbv_close_fault_flag
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    
    fault_name="MBV_close_fault"
    error_name="MBV_Malfuntion"

    print_with_log("Checking "+fault_name)
    print_with_log("master on")
    start_charge_function()
    if(not initial_condition_check()):
        return

    print_with_log("starting mbv_open fault")
    mbv_close_fault_flag=1

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=-1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=-1,
        bms_protection_status=-1,
        charging_algo_protections_status=-1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    print_with_log("stopping mbv_open fault")
    mbv_close_fault_flag=0

    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>20):
            print_with_log("fault deactivation timeout. test fail")
            break
            
        
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    polarity_rev_flag=0
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

##### "Air_Comp_Overheat_Protection":"None",    
def Air_Comp_Overheat_Protection_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Air_Comp_Overheat_Protection test")
    error_name="Air_Comp_Overheat_Protection"

    set_temp(25)
    all_relay_states["CON_AMB_TS9"]=1    
    sleep(2)

    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    

    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log("Air_Comp_Overheat_Protection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    

    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    
    set_temp(75)
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    
    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"])+ " code_4: "+str(CMS_internal_can_dict["code_4"]))
    
    print_with_log("Air_Comp_Overheat_Protection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(50)
    print_with_log("Deactivating high temperature")
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(15)
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    emulate_gun_unlock()
    heater_data["heater_tank_temperature"]=25
    update_cp_state(6)
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#endregion

#region charge algo protection
########"Station Cell over voltage":"Station Cell over voltage",

def station_cell_over_voltage():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    over_voltage_intermediate_value=3.609
    over_voltage_limit=3.61
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting station_cell_over_voltage fault activation")
    print_with_log("master on")
    error_name="Station Cell over voltage"
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=29,max_temp_val=30)
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log("Station Cell over voltage error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    emulate_cell_voltages(over_voltage_intermediate_value)
    sleep(3)

    
    print_with_log("Station Cell over voltage error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Non activation at voltage: "+str(over_voltage_intermediate_value)+" pass")
    else:
        print_with_log("Non activation at voltage: "+str(over_voltage_intermediate_value)+" fail")
        
    
    emulate_cell_voltages(over_voltage_limit)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation. fault val: "+str(fault_dict_new[error_name]))
        sleep(0.1)
        if(timer()-st_time>2):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    sleep(1)    
    print_with_log("Station Cell over voltage error state: "+str(fault_dict_new[error_name]))
    print_protection_status()

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation at voltage: "+str(over_voltage_limit)+" pass")
    else:
        print_with_log("fault activation at voltage: "+str(over_voltage_limit)+" fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1
       
    emulate_cell_voltages(3.3)
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    sleep(2)
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail ")
    check_master_error_code_reset()  
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

###########"CellOverTemperature":"CellOverTemperature",


def station_over_temp():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    over_temp_intermediate_value=49
    over_temp_limit=51

    fault_name="station_over_temp"
    error_name="CellOverTemperature"


    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=25,max_temp_val=26)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    print_with_log("Checking non activation before limit")
    emulate_min_max_temp(min_temp_val=over_temp_intermediate_value-1,max_temp_val=over_temp_intermediate_value)
    
    sleep(7)

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Fault non activation condition pass")
    else:
        print_with_log("Fault non activation condition fail")
        
    
    
    
    print_with_log("Checking  activation before limit")
    
    emulate_min_max_temp(min_temp_val=over_temp_limit-1,max_temp_val=over_temp_limit)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1
  

    print_with_log("Checking non deactivation with only correct temp ")
   
    emulate_min_max_temp(min_temp_val=over_temp_intermediate_value-1,max_temp_val=over_temp_intermediate_value)
    sleep(7)
    

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
   
    if(fault_dict_new[error_name]==1 ):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        return
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=-1,
        bms_protection_status=-1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1
    )
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    gun_remove_function()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

###########"Cell_Under_Temperature_Fault":"Cell_Under_Temperature_Fault",

def station_under_temp():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    under_temp_intermediate_value=6
    under_temp_limit=4

    fault_name="Station_under_temperature"
    error_name="Cell_Under_Temperature_Fault"


    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    print_with_log("Starting pre_cooling")
    sleep(5)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    print_with_log("Checking non activation with only BMS data")

    emulate_min_temp(under_temp_limit)
    emulate_max_temp(under_temp_limit+1)
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,26)
    sleep(7)
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))
    

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation condition pass")
    else:
        print_with_log("Fault non activation condition fail")
        return
        
    
    print_with_log("Checking non activation with two sensors open")
    emulate_min_temp(26)
    emulate_max_temp(26)
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,26)

    emulate_BMS_individual_temp_charge(1,-5)
    emulate_BMS_individual_temp_charge(2,-5)
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    if(fault_dict_new[error_name]==0):
        print_with_log("Fault non activation condition pass")
    else:
        print_with_log("Fault non activation condition fail")
        return
        
    
    print_with_log("Checking non activation before limit")
    emulate_max_temp(under_temp_intermediate_value+1)
    emulate_min_temp(under_temp_intermediate_value)

    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,under_temp_intermediate_value+2)
    emulate_BMS_individual_temp_charge(1,under_temp_intermediate_value+1)
    sleep(7)

    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Fault non activation condition pass")
    else:
        print_with_log("Fault non activation condition fail")
        
    
    
    
    print_with_log("Checking  activation before limit")
    emulate_max_temp(under_temp_limit+1)
    emulate_min_temp(under_temp_limit)
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,under_temp_limit+1)
    emulate_BMS_individual_temp_charge(1,under_temp_limit)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))

    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    print_with_log("Checking non deactivation with only correct temp ")
    emulate_max_temp(under_temp_intermediate_value+1)
    emulate_min_temp(under_temp_intermediate_value)

    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,under_temp_intermediate_value+2)
    emulate_BMS_individual_temp_charge(1,under_temp_intermediate_value+1)

    sleep(7)
    
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    if(fault_dict_new[error_name]==1):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        return
    
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1
    )
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
        
    check_master_error_code_reset()
    
    
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


##########"Incomplete Charge":"Incomplete Charge",
def imcomplete_charge():
    pass
    ###TODO
#########"Pack_Temperature_Imbalance":"Pack_Temperature_Imbalance",

def station_pack_temp_ib():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    temp_ib_intermediate_value=3
    temp_ib_activation_value=12
    temp_ib_deactivation_value=2.5


    fault_name="Pack_Temperature_Imbalance"
    error_name="Pack_Temperature_Imbalance"


    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    print_with_log("Checking non activation before limit")
    emulate_temp_ib(temp_ib_intermediate_value)
    sleep(7)

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Fault non activation condition pass")
    else:
        print_with_log("Fault non activation condition fail")
        
    
    
    
    print_with_log("Checking  activation before limit")
    emulate_temp_ib(temp_ib_activation_value)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    print_with_log("Checking non deactivation with only correct temp ")
    emulate_temp_ib(temp_ib_deactivation_value)
    sleep(7)
    

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    if(fault_dict_new[error_name]==1):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        return
    
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(CMS_internal_can_dict["e_plug_interaction_state"]>=2):
        print_with_log("waiting for eplug interation status to change")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Eplug state not changing")
            break
    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


#########"Pack_Voltage_Imbalance":"Pack_Voltage_Imbalance",

def station_pack_voltage_ib():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   

    voltage_ib_intermediate_value=0.08
    voltage_ib_activation_value=0.1
    voltage_ib_deactivation_value=0.04


    fault_name="Pack_Voltage_Imbalance"
    error_name="Pack_Voltage_Imbalance"


    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    
    
    update_cp_state(6)
    sleep(3)
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    print_with_log("Checking non activation before limit")
    emulate_voltage_IB(voltage_ib_intermediate_value,base_voltage=3.3)
    sleep(3)

    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Fault non activation condition pass")
    else:
        print_with_log("Fault non activation condition fail")
        
    
    
    
    print_with_log("Checking  activation before limit")
    emulate_voltage_IB(voltage_ib_activation_value,base_voltage=3.3)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    print_with_log("Checking non deactivation with only correct voltage ")
    emulate_voltage_IB(voltage_ib_deactivation_value,base_voltage=3.3)
    sleep(7)
    

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        
    
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(CMS_internal_can_dict["e_plug_interaction_state"]>=2):
        print_with_log("waiting for eplug interation status to change")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Eplug state not changing")
            break
    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

   
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


#########"tec_failure":"tec_failure",

def tec_failure():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1

    fault_name="tec_failure"
    error_name="tec_failure"

    print_with_log("Checking: "+str(fault_name) )
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=25,max_temp_val=26)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    print_with_log("Current started")
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            sleep(1)
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor open")
                break
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                break
        sleep(1)
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"]))         
        emulate_voltage_increase(3.3,voltage_cutoff,2)
        emulate_voltage_increase(3.3,3.35,1)
        print_with_log("Voltage increased to : "+str(voltage_cutoff))    
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor open")
            break 

    st_time=timer()   
    ### do convergance when requested
    while(ota_can_dict["fc_convergence_cmd"]!=160): 
        print_with_log("waiting for convergance command")
        sleep(2)
        if(timer()-st_time>200):
            print_with_log("No TEC cmd rec. timeout test fail")
            break
    
    if(ota_can_dict["fc_convergence_cmd"]==160):
        print_with_log("Received convergance command") 
        
    

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>150):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    print_with_log("Emulating TEC")
    emulate_actual_soc(tec_SOC)
    emulate_user_soc(100.4)
    sleep(5)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 ):
        print_with_log("Fault non deactivation pass")
    else:
        print_with_log("Fault non deactivation fail")

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]>70):
        print_with_log("waiting for station to stop pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"]))
    
    
    print_with_log("Checking deactivation with CP")
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1
    )
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    sleep(3)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

#endregion

#region OTC tests

###########"BMS_OTA_Cloud_Display_No_Response":"BMS_OTA_Cloud_Display_No_Response",
def BMS_OTA_Cloud_Display_No_Response():
    check_no_display_response()


def BMS_flasher_error_check():
    check_otc_flasher_err()

def BMS_flasher_error_timeout_check():
    check_otc_flasher_timeout_err()
###########"BMS_OTA_Target_Image_Unavailable":"BMS_OTA_Target_Image_Unavailable",


###########"BMS_OTA_Don't_Do_Cmd":"BMS_OTA_Don't_Do_Cmd",
def BMS_OTA_Dont_Do_Cmd():
    check_direct_charge_latest_fw()

###########"BMS_OTA_Flasher_Error":"BMS_OTA_Flasher_Error",
##########"BMS_OTA_Attempt_Timeout":"BMS_OTA_Attempt_Timeout",
##########"BMS_OTA_Attempts_Exhausted":"BMS_OTA_Attempts_Exhausted",
#########"BMS_OTA_Bootloader_Start_Fail":"BMS_OTA_Bootloader_Start_Fail",
def BMS_OTA_Bootloader_Start_Fail():
    check_bl_hb_timeout()


def BMS_OTA_target_fw_unavailable():
    check_direct_charge_fw_not_available()

#########"Vehicle blacklisted":"Vehicle blacklisted",
def Vehicle_blacklisted():
    check_no_charge_blacklisted_veh()

#########"Fut_Protection":"Fut_Protection",

def fut_protection_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,correct_rectifier_flag,correct_curr_sensor_flag,fut_hb_flag
    voltage_cutoff=3.605   
    correct_current_flag=0
    correct_relay_state_flag=1
    fut_hb_flag=0
    

    fault_name="FUT_protection"
    error_name="Fut_Protection"

    print_with_log("Starting FUT_protection check")
    print_with_log("master on")
    master_swt_on()
    sleep(5)  
    if(not initial_condition_check()):
        return
    fut_hb_flag=1
    print_with_log("FUT heartbeat started.waiting for 80 sec")
    sleep(80)
    if(fault_dict_new[error_name]==1):
        print_with_log("fault activation pass")
    else:
        print_with_log("fault activation fail")

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0
    )
    if(res==True):
        print_with_log("Protection activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Protection activation fail")

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    fut_hb_flag=0
    print_with_log("FUT heartbeat stopped.waiting for 80 sec")
    sleep(80)

    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])


    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(res==True):
        print_with_log("Protection deactivation pass")
    else:
        print_with_log("Protection deactivation fail")
    
    correct_current_flag=0
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()


#endregion

#region BMS protections
############"BMS_ChargeProtection":"BMS_ChargeProtection",

def BMS_charge_protection_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="BMS_ChargeProtection"
    print_with_log("Starting BMS_charge_protection fault activation")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=25,max_temp_val=26)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

   
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(10)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log("BMS_charge_protection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    emulate_charge_protection_trigger()
    sleep(3)

    print_protection_status()
    print_with_log("BMS_charge_protection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    emulate_charge_protection_untrigger()
    sleep(3)

    print_protection_status()
    print_with_log("BMS_charge_protection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
       
        print_with_log("Fault non deactivation without CP pass")
    else:
        print_with_log("Fault non deactivation without CP fail")
        
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    
    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    print_protection_status()
    print_with_log("BMS_charge_protection error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

   
    
    if(fault_dict_new["BMS_ChargeProtection"]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()

    gun_remove_function()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(3)
    all_ard_state_reset()

########"BMS CAN Freeze":"BMS CAN Freeze",

def BMS_can_freeze_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1

    error_name="BMS CAN Freeze"

    print_with_log("Starting BMS_can_freeze fault activation")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    print_with_log("Starting pre_cooling")
    sleep(5)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=29,max_temp_val=30)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(10)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log("BMS CAN Freeze error state: "+str(fault_dict_new["BMS CAN Freeze"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["BMS CAN Freeze"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    bms_send_flag=0
    sleep(5)

    print_protection_status()
    print_with_log("BMS CAN Freeze error state: "+str(fault_dict_new["BMS CAN Freeze"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["BMS CAN Freeze"]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    bms_send_flag=1
    sleep(5)

    print_protection_status()
    print_with_log("BMS CAN Freeze error state: "+str(fault_dict_new["BMS CAN Freeze"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["BMS CAN Freeze"]==1 and res):
       
        print_with_log("Fault non deactivation without CP pass")
    else:
        print_with_log("Fault non deactivation without CP fail")
        
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    
    st_time=timer()
    while(fault_dict_new["BMS CAN Freeze"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    

    print_protection_status()
    print_with_log("BMS CAN Freeze error state: "+str(fault_dict_new["BMS CAN Freeze"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    
    if(fault_dict_new["BMS CAN Freeze"]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()

    gun_remove_function()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()
##########"BMS Not in charging State":"BMS Not in charging State",
def BMS_Wakeup_Fail_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="BMS_Wakeup_Fail"
    print_with_log("Starting BMS_Wakeup_Fail fault activation")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    update_cp_state(6)
    sleep(3)
    print_protection_status()
    print_with_log("error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
    
    update_cp_state(4)
    emulate_gun_lock()

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time >60):
            print_with_log("fault activation timeout. test fail")
            break
    if(fault_dict_new[error_name]==1):
        print_with_log("Fault activated in time: "+str(timer()-st_time))
    else:
        print_with_log("Fault activation fail")
    sleep(1)


    print_protection_status()
    print_with_log("error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    print_with_log("Starting BMS messagew sending")
    bms_send_flag=1
    sleep(20)

    print_protection_status()
    print_with_log("error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)
    
    if(fault_dict_new[error_name]==1):
       
        print_with_log("Fault non deactivation without CP pass")
    else:
        print_with_log("Fault non deactivation without CP fail")
        
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    
    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    print_protection_status()
    print_with_log("error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    if(fault_dict_new[error_name]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()

    gun_remove_function()
    sleep(5)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(3)
    all_ard_state_reset()

#endregion

#region gun lock_unlock faults

###########"UnIntentional_GunUnlock":"UnIntentional_GunUnlock",        

def unintentional_gun_unlock_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    if(CMS_version==4.2):
        print_with_log("unintentional_gun_unlock_test removed form CX P4 FW")
        return 
    

    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="UnIntentional_GunUnlock"

    print_with_log("Starting unintentional_gun_unlock test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    sleep(5)
    print_with_log("Starting pre_cooling")
    sleep(5)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=29,max_temp_val=30)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(10)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    print_protection_status()
    print_with_log("UnIntentional_GunUnlock error state: "+str(fault_dict_new["UnIntentional_GunUnlock"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["UnIntentional_GunUnlock"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    emulate_solenoid_fb(0)

    st_time=timer()
    while(fault_dict_new["UnIntentional_GunUnlock"]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    sleep(1)

    print_protection_status()
    print_with_log("UnIntentional_GunUnlock error state: "+str(fault_dict_new["UnIntentional_GunUnlock"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["UnIntentional_GunUnlock"]==1 and res):
        print_with_log("Fault activation pass")
    else:
        print_with_log("Fault activation fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    emulate_solenoid_fb(1)
    sleep(5)

    print_protection_status()
    print_with_log("UnIntentional_GunUnlock error state: "+str(fault_dict_new["UnIntentional_GunUnlock"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

   
    
    if(fault_dict_new["UnIntentional_GunUnlock"]==1):
       
        print_with_log("Fault non deactivation without CP pass")
    else:
        print_with_log("Fault non deactivation without CP fail")
        return
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    
    st_time=timer()
    while(fault_dict_new["UnIntentional_GunUnlock"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault deactivation fail")
            break
    deact_time=timer()-st_time
    print_with_log("fault deactivation in time: "+str(deact_time))

    

    print_protection_status()
    print_with_log("UnIntentional_GunUnlock error state: "+str(fault_dict_new["UnIntentional_GunUnlock"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=-1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["UnIntentional_GunUnlock"]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
        
    check_master_error_code_reset()
    gun_remove_function()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()
                   
############"GunLockFailed_1st_attempt":"GunLockFailed_1st_attempt",  

def GunLockFailed_1st_attempt():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,tec_SOC
    voltage_cutoff=3.605 
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="GunLockFailed_1st_attempt"
    fault_name_2="GunLockFailed_2nd_attempt"

    #region gun_lock_fail_1st_attempt

    
    print_with_log("Starting Gun lock fail 1 st attemp test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    
    
    print_protection_status()
    print_with_log("Gun lock attempt failed error state: "+str(fault_dict_new[fault_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[fault_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")    
         
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    if(CMS_version==4.0):
        st_time=timer()
        
        while(ota_can_dict["gun_lock_request"]!=1):
            print_with_log("waiting for gun lock request from station")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        emulate_bms_gun_lock_fail()
        st_time=timer()
        while(CMS_internal_can_dict["solenoid_lock_status"]!=2):
            print_with_log("waiting for lock retry to fail")        
            sleep(0.1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        print_with_log("solenoid_lock_status: "+str(CMS_internal_can_dict["solenoid_lock_status"]))
    st_time=timer()
    while(fault_dict_new[fault_name]==0):
        print_with_log("waiting for fault activation")        
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    print_protection_status()
    print_with_log("Gun lock 1 st attempt failed error state: "+str(fault_dict_new[fault_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=-1,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=0,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[fault_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
        
    compare_fault_code_structure()
    check_master_session_code(fault_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=fault_name)
            display_check=1


    print_with_log("Checking non deactivation with proper solenoid feedback")    
    emulate_bms_gun_lock_fail_off()
    sleep(2)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log("Gun lock 1 st attempt failed error state: "+str(fault_dict_new[fault_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=-1,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=0,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[fault_name]==1 and res):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation fail")
        
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[fault_name])


    st_time=timer()
    while(fault_dict_new[fault_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>5):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log("Gun lock 1 st attempt failed error state: "+str(fault_dict_new[fault_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    if(fault_dict_new[fault_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    
    all_ard_state_reset()
 
###########"Unauthorized_GUN_Removal":"Unauthorized_GUN_Removal",

def unautharized_gun_removal():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    error_name="Unauthorized_GUN_Removal"
    print_with_log("Starting Unauthorized_GUN_Removal test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=28,max_temp_val=29)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()
    sleep(5)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("Current start timeout.test fail")
            break
    

    print_protection_status()
    print_with_log("Unauthorized_GUN_Removal error state: "+str(fault_dict_new["Unauthorized_GUN_Removal"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new["Unauthorized_GUN_Removal"]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    
    update_cp_state(6)
    st_time=timer()
    while(fault_dict_new["Unauthorized_GUN_Removal"]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>70):
            print_with_log("fault activation timeout. test fail")
            return
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log("Unauthorized_GUN_Removal error state: "+str(fault_dict_new["Unauthorized_GUN_Removal"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=0,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["Unauthorized_GUN_Removal"]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new["Unauthorized_GUN_Removal"]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>80):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log("Unauthorized_GUN_Removal error state: "+str(fault_dict_new["Unauthorized_GUN_Removal"]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=1,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=-1,
        fcs_int_cooling_prot_status=1)
    
    if(fault_dict_new["Unauthorized_GUN_Removal"]==0):       
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()

#############"Unlock_failure":"Unlock_failure",

def unlock_failure():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="Unlock_failure"
    error_name="Unlock_failure"

    print_with_log("Checking: "+str(fault_name) )
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(5)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("Current start timeout.test fail")
            break

    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            sleep(1)
            if(CMS_internal_can_dict["dc_contactor"] ==0):
                print_with_log("DC contactor open")
                break
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return        
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["set_current"])) 
        emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)        
        print_with_log("Voltage increased to : "+str(voltage_cutoff))    
        
        if(CMS_internal_can_dict["dc_contactor"] ==0):
            print_with_log("DC contactor open")
            break    
        ### do convergance when requested
        if(ota_can_dict["fc_convergence_cmd"]==160):            
            print_with_log("Received convergance command")    
            print_with_log("changing SOC as per convergance")
            emulate_actual_soc(tec_SOC)
            emulate_user_soc(100.4)
            sleep(0.1)
            break
            
    st_time=timer() 
    while(CMS_internal_can_dict["current_read"]>70):
        print_with_log("waiting for station to stop pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"]))
    if(CMS_version==4.2):
        st_time=timer()
        while(CMS_internal_can_dict["cx_actuator_status"]==0):
            print_with_log("waiting for gun unlock request from station")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return   
    if(CMS_version==4.0): 
        st_time=timer()
        while(ota_can_dict["gun_lock_request"]!=0):
            print_with_log("waiting for gun unlock request from station")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
    sleep(3)
    emulate_bms_gun_unlock_fail()
    
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>150):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=0,
        bms_protection_status=0,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")

    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1



    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    sleep(3)
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

##########"GunLockFailed_2nd_attempt":"GunLockFailed_2nd_attempt",
############"SolFB_1_before_gun_lock":"SolFB_1_before_gun_lock",  
 
def gun_lock_fail_with_early_fb():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,tec_SOC
    if(CMS_version==4.2):
        voltage_cutoff=3.605 
        correct_current_flag=1
        correct_relay_state_flag=1
        fault_name="SolFB_1_before_gun_lock"
        print_with_log("Starting SolFB_1_before_gun_lock fault activation")
        print_with_log("master on")
        master_swt_on()
        sleep(5)
        if(not initial_condition_check()):
            return
        emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
        emulate_solenoid_fb(1)
        update_cp_state(6)
        sleep(3)
        print_with_log("Starting BMS data sending")
        bms_send_flag=1
        sleep(3)
        update_cp_state(4)
        emulate_gun_lock()
        st_time=timer()
        while(fault_dict_new[fault_name]==0):
            print_with_log("waiting for fault activation")
            sleep(1)
            if(timer()-st_time>15):
                print_with_log("fault activation timeout. test fail")
                break
        
        print_with_log("Fault activation in time: "+str(timer()-st_time))
        sleep(1)
        print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                    " code_3: "+str(CMS_internal_can_dict["code_3"]))
        print_with_log(str(fault_name)+" error state: "+str(fault_dict_new[fault_name]))
        protection_states=get_protection_states()
        print_with_log(protection_states)

        res=evaluate_protection_state(
            input_power_protection_status=1,
            output_power_protection_status=1,
            fcs_heating_protection_status=1,
            e_plug_protection_status=1,
            bms_protection_status=1,
            charging_algo_protections_status=1,
            fcs_cooling_protection_status=1,
            fcs_int_cooling_prot_status=1
        )
        if(fault_dict_new[fault_name]==1 and res):
            print_with_log("fault activation pass")
            print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
        else:
            print_with_log("fault activation fail")
            

        compare_fault_code_structure()
        check_master_session_code(fault_name)
        sleep(1)
        display_check=0
        if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
                check_display_activity_id(type="protection",name=fault_name)
                display_check=1

        st_time=timer()
        while(CMS_internal_can_dict["fcs_status"]!=3):
            print_with_log("waiting for fluid on start.")
            sleep(1)
            if(timer()-st_time>30):
                print_with_log("Cooling not starting. Test fail")
                break
        if(CMS_internal_can_dict["fcs_status"]==3):
            print_with_log("precooling started with water. Test pass")
        sleep(10)
        emulate_min_max_temp(min_temp_val=29,max_temp_val=30)

        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")    
            sleep(1)        
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        print_with_log("Current started at val: "+str(CMS_internal_can_dict["current_read"])+". Test pass")
        

        while(1):
            st_time=timer()
            while(CMS_internal_can_dict["current_read"]<20):
                print_with_log("waiting for station to start pushing current")
                if(CMS_internal_can_dict["dc_contactor"]==0):
                    print_with_log("DC contactor turned off")
                    break
                sleep(1)
                if(timer()-st_time>300):
                    print_with_log("timeout. test fail")
                    return        
            print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
            
            
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break

            cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)

            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
        
        
        charge_end_function()
        
        chg_compl_start=timer()    
        sent_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("Final AH sent to BMS: "+str(sent_ah))
        # emulate_last_charge_ah(sent_ah)
        st_time=timer()
        while(1):
            if(ota_can_dict["fc_convergence_cmd"]==160):            
                print_with_log("Received convergance command")    
                print_with_log("changing SOC as per convergance")
                emulate_actual_soc(tec_SOC)
                emulate_user_soc(100.4)
                sleep(0.1)
                break
            print_with_log("waiting for TEC commnad")
            sleep(1)
            if(timer()-st_time>60):
                print_with_log("TEC command not received.Test fail")
                break
        st_time=timer()    
        while(CMS_internal_can_dict["cx_actuator_status"]==0):
            print_with_log("waiting for gun unlock request from station")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        gun_unlock_delay=timer()-chg_compl_start
        print_with_log("Gun unlock delay: "+str(gun_unlock_delay))
        sleep(2)
        bms_send_flag=0    
        emulate_gun_unlock()
        sleep(5)    
        ### if display check happened for charge continue
        if(display_check==1):
            gun_remove_function(activity_id_check=-1)
        ### if display check has to be done after gun unlock cmd
        else:
            gun_remove_function(activity_id_check=fault_state_activity_id[fault_name])


        st_time=timer()
        while(fault_dict_new[fault_name]==1):
            print_with_log("waiting for fault deactivation")
            sleep(0.1)
            if(timer()-st_time>5):
                print_with_log("fault deactivation timeout. test fail")
                return
        print_with_log("Fault deactivation in time: "+str(timer()-st_time))
        sleep(1)

        print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                    " code_3: "+str(CMS_internal_can_dict["code_3"]))
        print_with_log(str(fault_name)+" error state: "+str(fault_dict_new[fault_name]))
        protection_states=get_protection_states()
        print_with_log(protection_states)
        if(fault_dict_new[fault_name]==0):
            print_with_log("fault deactivation pass")
        else:
            print_with_log("fault deactivation fail")
        check_master_error_code_reset()
        bms_send_flag=0
        correct_current_flag=0
        correct_relay_state_flag=0
        sleep(5)
        all_ard_state_reset()
    elif(CMS_version==4.0):
        voltage_cutoff=3.605 
        correct_current_flag=1
        correct_relay_state_flag=1
        fault_name="SolFB_1_before_gun_lock"
        print_with_log("Starting SolFB_1_before_gun_lock fault activation")
        print_with_log("master on")
        master_swt_on()
        sleep(5)
        if(not initial_condition_check()):
            return
        emulate_min_max_temp(min_temp_val=37,max_temp_val=38)

        emulate_solenoid_fb(1)
        update_cp_state(6)
        sleep(3)
        print_with_log("Starting BMS data sending")
        bms_send_flag=1
        sleep(3)
        update_cp_state(4)
        sleep(3)
        emulate_solenoid_fb(1)
        
        st_time=timer() 
        while(ota_can_dict["CI_Unique_ID"]==-1):
            print_with_log("waiting for station HB")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        print_with_log(ota_can_dict["CI_Unique_ID"])
        

        print_with_log("solenoid_lock_status: "+str(CMS_internal_can_dict["solenoid_lock_status"]))
        st_time=timer()
        while(fault_dict_new[fault_name]==0):
            print_with_log("waiting for fault activation")        
            sleep(0.1)
            if(timer()-st_time>30):
                print_with_log("fault activation timeout. test fail")
                return
        print_with_log("Fault activation in time: "+str(timer()-st_time))
        sleep(1)
        print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                    " code_3: "+str(CMS_internal_can_dict["code_3"]))
        print_with_log(str(fault_name)+" error state: "+str(fault_dict_new[fault_name]))
        protection_states=get_protection_states()
        print_with_log(protection_states)

        res=evaluate_protection_state(
            input_power_protection_status=1,
            output_power_protection_status=1,
            fcs_heating_protection_status=0,
            e_plug_protection_status=1,
            bms_protection_status=1,
            charging_algo_protections_status=1,
            fcs_cooling_protection_status=0,
            fcs_int_cooling_prot_status=1
        )
        if(fault_dict_new[fault_name]==1 and res):
            print_with_log("fault activation pass")
            print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
        else:
            print_with_log("fault activation fail")
            

        compare_fault_code_structure()
        check_master_session_code(fault_name)
        sleep(1)
        display_check=0
        if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
                check_display_activity_id(type="protection",name=fault_name)
                display_check=1

        st_time=timer()
        while(CMS_internal_can_dict["fcs_status"]!=3):
            print_with_log("waiting for fluid on start.")
            sleep(1)
            if(timer()-st_time>30):
                print_with_log("Cooling not starting. Test pass")
                break
        if(CMS_internal_can_dict["fcs_status"]==3):
            print_with_log("precooling started with water. Test fail")

        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")    
            sleep(1)        
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        print_with_log("Current started at val: "+str(CMS_internal_can_dict["current_read"])+". Test pass")
        if(CMS_internal_can_dict["current_read"] >400):
            print_with_log("Non derated current started. test fail")
        else:        
            print_with_log("Derated current started. test pass")

        while(1):
            st_time=timer()
            while(CMS_internal_can_dict["current_read"]<20):
                print_with_log("waiting for station to start pushing current")
                if(CMS_internal_can_dict["dc_contactor"]==0):
                    print_with_log("DC contactor turned off")
                    break
                sleep(1)
                if(timer()-st_time>300):
                    print_with_log("timeout. test fail")
                    return        
            print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
            
            
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break

            cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)

            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
        
        
        charge_end_function()
        
        chg_compl_start=timer()    
        sent_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("Final AH sent to BMS: "+str(sent_ah))
        # emulate_last_charge_ah(sent_ah)
        st_time=timer()
        while(1):
            if(ota_can_dict["fc_convergence_cmd"]==160):            
                print_with_log("Received convergance command")    
                print_with_log("changing SOC as per convergance")
                emulate_actual_soc(tec_SOC)
                emulate_user_soc(100.4)
                sleep(0.1)
                break
            print_with_log("waiting for TEC commnad")
            sleep(1)
            if(timer()-st_time>60):
                print_with_log("TEC command not received.Test fail")
                break
        st_time=timer()    
        while(ota_can_dict["gun_lock_request"]!=0):
            print_with_log("waiting for gun unlock request from station")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        gun_unlock_delay=timer()-chg_compl_start
        print_with_log("Gun unlock delay: "+str(gun_unlock_delay))
        sleep(2)
        bms_send_flag=0    
        emulate_gun_unlock()
        sleep(5)    
        update_cp_state(6)
        st_time=timer()
        while(CMS_internal_can_dict["e_plug_interaction_state"]>=2):
            print_with_log("waiting for eplug interation status to change")
            sleep(0.1)
            if(timer()-st_time>10):
                print_with_log("Eplug state not changing")
                break

        st_time=timer()
        while(fault_dict_new[fault_name]==1):
            print_with_log("waiting for fault deactivation")
            sleep(0.1)
            if(timer()-st_time>5):
                print_with_log("fault deactivation timeout. test fail")
                return
        print_with_log("Fault deactivation in time: "+str(timer()-st_time))
        sleep(1)

        print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                    " code_3: "+str(CMS_internal_can_dict["code_3"]))
        print_with_log(str(fault_name)+" error state: "+str(fault_dict_new[fault_name]))
        protection_states=get_protection_states()
        print_with_log(protection_states)
        if(fault_dict_new[fault_name]==0):
            print_with_log("fault deactivation pass")
        else:
            print_with_log("fault deactivation fail")
        check_master_error_code_reset()
        bms_send_flag=0
        correct_current_flag=0
        correct_relay_state_flag=0
        sleep(5)
        all_ard_state_reset()
        


###############"Gun_theft":"Gun_theft", 

def gun_theft_fault_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,chiller_data,correct_polarity_response,battrty_polarity_state
    global dc_contactor_open_flag,polarity_rev_flag,BMS_contactor_weld_forward,BMS_contactor_open_flag 
    

    fault_name="Gun_theft"
    error_name="Gun_theft"

    print_with_log("Checking "+fault_name)
    start_charge_function()
    sleep(5)    
    if(not initial_condition_check()):
        return
    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
            " code_3: "+str(CMS_internal_can_dict["code_3"])+" code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log(fault_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    update_cp_state(12)
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]
    for r in gun_relay_names_list:
        all_relay_states[r]=1
    set_temp(150)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>150):
            print_with_log("fault activation timeout. test fail")
            break
            
        
    print_with_log("Fault activated in time: "+str(timer()-st_time))
    sleep(1)
    sleep(1)
    print_with_log("Initial error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
            " code_3: "+str(CMS_internal_can_dict["code_3"])+" code_4: "+str(CMS_internal_can_dict["code_4"]))
    print_with_log(fault_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=0)
    
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("Fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("Fault activation fail")
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1


    update_cp_state(6)
    set_temp(25)
    for r in gun_relay_names_list:
        all_relay_states[r]=0

    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("fault deactivation timeout. test fail")
            break
    
    print_with_log("Fault deactivated in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1)
    
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Fault deactivation pass")
    else:
        print_with_log("Fault deactivation fail")
    check_master_error_code_reset()
    
    sleep(2)
    all_ard_state_reset()

def gun_lock_in_air_partial_unlock_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,tec_SOC
    if(CMS_version!=4.2):
        print_with_log("Gun_Locked_In_Air test not supported in this version")
        return
    voltage_cutoff=3.605 
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="Gun_Locked_In_Air"
    print_with_log("Starting Gun_Locked_In_Air partial unlock test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return

    emulate_gun_lock_in_air()

    st_time=timer()
    while(fault_dict_new[fault_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>15):
            print_with_log("fault activation timeout. test fail")
            break
    
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(str(fault_name)+" error state: "+str(fault_dict_new[fault_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=0,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[fault_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
    
    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")

    if(CMS_internal_can_dict["cx_actuator_status"]==1):
        update_cp_state(12)
    
    sleep(30)
    print_with_log("STarting next session by making ulock to zero")
    update_ulock_status(0)

    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==1):
        print_with_log("waiting for cx_actuator_status to be removed from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    
    if(CMS_internal_can_dict["cx_actuator_status"]==0):
        update_cp_state(6)
    print_with_log("partial unlock done")
    
    st_time=timer()
    while(fault_dict_new[fault_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>15):
            print_with_log("fault deactivation timeout. test fail")
            break
    if(fault_dict_new[fault_name]==0):
        print_with_log("Fault deactivation in time: "+str(timer()-st_time))
        print_with_log("Fault deactivation pass")
        sleep(1)
    else:
        print_with_log("Fault deactivation fail")


    print_with_log("Connecting vehicle")
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    sleep(3)
    update_cp_state(4)
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    if(CMS_internal_can_dict["current_read"]>20):
        print_with_log("Charge started after partial unlock.Test pass")
    else:
        print_with_log("Charge not started after partial unlock.Test fail")
    
    print_with_log("STopping charge")
    gun_remove_function()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


def gun_lock_in_air_full_unlock_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,tec_SOC
    if(CMS_version!=4.2):
        print_with_log("Gun_Locked_In_Air test not supported in this version")
        return
    voltage_cutoff=3.605 
    correct_current_flag=1
    correct_relay_state_flag=1
    fault_name="Gun_Locked_In_Air"
    print_with_log("Starting Gun_Locked_In_Air full unlock test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return

    emulate_gun_lock_in_air()

    st_time=timer()
    while(fault_dict_new[fault_name]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>15):
            print_with_log("fault activation timeout. test fail")
            break
    
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(str(fault_name)+" error state: "+str(fault_dict_new[fault_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=0,
        output_power_protection_status=0,
        fcs_heating_protection_status=0,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=0,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[fault_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation fail")
    
    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")

    if(CMS_internal_can_dict["cx_actuator_status"]==1):
        update_cp_state(12)
    
    sleep(30)
    print_with_log("STarting next session by making pull limit to 1")
    update_gun_limit_state(1)
    sleep(0.2)
    update_gun_limit_state(0)
    update_ulock_status(0)


    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==1):
        print_with_log("waiting for cx_actuator_status to be removed from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    
    if(CMS_internal_can_dict["cx_actuator_status"]==0):
        update_cp_state(6)
        update_ulock_status(0)

    print_with_log("Full unlock done")
    
    st_time=timer()
    while(fault_dict_new[fault_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(1)
        if(timer()-st_time>15):
            print_with_log("fault deactivation timeout. test fail")
            break
    if(fault_dict_new[fault_name]==0):
        print_with_log("Fault deactivation in time: "+str(timer()-st_time))
        print_with_log("Fault deactivation pass")
        sleep(1)
    else:
        print_with_log("Fault deactivation fail")


    print_with_log("Connecting vehicle")
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    sleep(3)
    update_cp_state(4)
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    if(CMS_internal_can_dict["current_read"]>20):
        print_with_log("Charge started after full unlock.Test pass")
    else:
        print_with_log("Charge not started after full unlock.Test fail")
    
    print_with_log("STopping charge")
    gun_remove_function()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(5)
    all_ard_state_reset()


#endregion

#region gun temp faults

##########"GunTempImbalanceFault":"GunTempImbalanceFault",

def gun_temp_ib_fault(num1,num2,activation_val=22,deactivation_val=12,use_b3=0):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_ib_detect_activation=activation_val
    gun_temp_ib_detect_deactivation=deactivation_val

    if(use_b3==1):
        load_charge_profile_table(pack_varient=0,matlab_b3=1)

    fault_name="GunTempImbalanceFault"
    error_name="GunTempImbalanceFault"    
    
    gun_temp_can_list=["gun_temp_p_1","gun_temp_p_2","gun_temp_n_1","gun_temp_n_2"]
    temp_can_msg1=gun_temp_can_list[num1-1]
    temp_can_msg2=gun_temp_can_list[num2-1]

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name+" for sensor: "+str(num1) +" and "+str(num2))
    start_charge_function()
    sleep(5)
    # if(not initial_condition_check()):
    #     return

    print_with_log("Checking fault non activation at intermediate value")
    activate_gun_temp_ib(num1,num2,gun_temp_ib_detect_activation-6)
    sleep(5)
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg1])+" and "+str(CMS_internal_can_dict[temp_can_msg2]))
    sleep(1)
    if(fault_dict_new[error_name]==0):
        print_with_log("fault non activation pass")
    else:
        print_with_log("fault non activation  fail")

    activate_gun_temp_ib(num1,num2,gun_temp_ib_detect_activation)  
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>30):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg1])+" and "+str(CMS_internal_can_dict[temp_can_msg2]))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    activate_gun_temp_ib(num1,num2,gun_temp_ib_detect_deactivation)  
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg1])+" and "+str(CMS_internal_can_dict[temp_can_msg2]))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=0,
        bms_protection_status=-1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset()
    
    set_temp(25)    
    emulate_gun_unlock()
    sleep(3)
    update_cp_state(6)    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)
    load_charge_profile_table(pack_varient=1,matlab_b3=0)

###########"Gun_over_temperature":"Gun_over_temperature",

def gun_over_temp_cutoff_all():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_warning_activation=97
    gun_temp_warning_deactivation=93

    fault_name="Gun Overheat cutoff"
    error_name="Gun_over_temperature"
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]
    
    set_temp(25)
    sleep(2)

    master_swt_on()
    sleep(10)

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name+" for all sensors. ")    
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()

    print_with_log("Starting pre_cooling")
    sleep(5)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return

    set_temp(25)
    for i in gun_relay_names_list:
        all_relay_states[i]=1
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    set_temp(gun_temp_warning_activation)

    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=0,
        fcs_heating_protection_status=1,
        e_plug_protection_status=0,
        bms_protection_status=1,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    set_temp(25)    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

###############"Gun_over_temp_warning":"Gun_over_temp_warning",

def gun_over_temp_warning_all():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_warning_activation=92
    gun_temp_warning_deactivation=88

    fault_name="Gun Overheat Warning"
    error_name="Gun_over_temp_warning"
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]
    
    
    master_swt_on()
    sleep(10)
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name+" for all sensors")
    
    if(not initial_condition_check()):
        return
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    print_with_log("Starting pre_cooling")
    sleep(5)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=33,max_temp_val=32)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return

    set_temp(25)
    for i in gun_relay_names_list:
        all_relay_states[i]=1
    sleep(5)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    print_protection_status()
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==0 and res):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    set_temp(gun_temp_warning_activation)
    st_time=timer()
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    
    set_temp(gun_temp_warning_deactivation)
    sleep(7)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1
    )
    if(fault_dict_new[error_name]==1):
        print_with_log("fault non deactivation pass")
    else:
        print_with_log("fault non deactivation  fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1
    )
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
    check_master_error_code_reset() 
    set_temp(25)    
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

############"GunTempImbalanceDetect":"GunTempImbalanceDetect",    
# 
def gun_temp_ib_detect(num1,num2,activation_val=12,deactivation_val=0):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,correct_curr_sensor_flag,correct_rectifier_flag
    voltage_cutoff=3.605   
    gun_temp_ib_detect_activation=activation_val
    gun_temp_ib_detect_deactivation=deactivation_val

    fault_name="GunTempImbalanceDetect"
    error_name="GunTempImbalanceDetect"    
    
    gun_temp_can_list=["gun_temp_p_1","gun_temp_p_2","gun_temp_n_1","gun_temp_n_2"]
    temp_can_msg1=gun_temp_can_list[num1-1]
    temp_can_msg2=gun_temp_can_list[num2-1]

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("checking "+fault_name+" for sensor: "+str(num1) +" and "+str(num2))
    start_charge_function()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("Checking fault non activation at intermediate value")
    activate_gun_temp_ib(num1,num2,gun_temp_ib_detect_activation-6)
    sleep(5)
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg1])+" and "+str(CMS_internal_can_dict[temp_can_msg2]))
    sleep(1)
    if(fault_dict_new[error_name]==0):
        print_with_log("fault non activation pass")
    else:
        print_with_log("fault non activation  fail")
          

    activate_gun_temp_ib(num1,num2,gun_temp_ib_detect_activation)  
    st_time=timer()
    
    while(fault_dict_new[error_name]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault activation timeout. test fail")
            return
    print_with_log("Fault activation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg1])+" and "+str(CMS_internal_can_dict[temp_can_msg2]))
    sleep(1)
    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=1,
        output_power_protection_status=1,
        fcs_heating_protection_status=1,
        e_plug_protection_status=1,
        bms_protection_status=1,
        charging_algo_protections_status=1,
        fcs_cooling_protection_status=1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==1 and res):
        print_with_log("fault activation pass")
        print_with_log("Master error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    else:
        print_with_log("fault activation  fail")
        
    compare_fault_code_structure()
    check_master_session_code(error_name)
    sleep(1)
    display_check=0
    if(CMS_internal_can_dict["charging_algo_protections_status"]==1):
            check_display_activity_id(type="protection",name=error_name)
            display_check=1

    
    
    activate_gun_temp_ib(num1,num2,gun_temp_ib_detect_deactivation)  
    
    
    ### if display check happened for charge continue
    if(display_check==1):
        gun_remove_function(activity_id_check=-1)
    ### if display check has to be done after gun unlock cmd
    else:
        gun_remove_function(activity_id_check=fault_state_activity_id[error_name])

    st_time=timer()
    while(fault_dict_new[error_name]==1):
        print_with_log("waiting for fault deactivation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("fault deactivation timeout. test fail")
            return
    print_with_log("Fault deactivation in time: "+str(timer()-st_time))
    print_with_log("Temperature set to: "+str(CMS_internal_can_dict[temp_can_msg1])+" and "+str(CMS_internal_can_dict[temp_can_msg2]))
    sleep(1)

    print_with_log("error state. code_1: "+str(CMS_internal_can_dict["code_1"])+" code_2: "+str(CMS_internal_can_dict["code_2"])+
                   " code_3: "+str(CMS_internal_can_dict["code_3"]))
    print_with_log(error_name+" error state: "+str(fault_dict_new[error_name]))
    protection_states=get_protection_states()
    print_with_log(protection_states)

    res=evaluate_protection_state(
        input_power_protection_status=-1,
        output_power_protection_status=0,
        fcs_heating_protection_status=-1,
        e_plug_protection_status=-1,
        bms_protection_status=0,
        charging_algo_protections_status=0,
        fcs_cooling_protection_status=-1,
        fcs_int_cooling_prot_status=1
    )
    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation fail")
        
    check_master_error_code_reset()
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)
   

#endregion
                              


#endregion

#region protection action mapping tests

def input_power_protection_action_standby_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting input_power_protection_action_standby_test")
    
    ac_con_state=CMS_internal_can_dict["ac_contactor"]
    print_with_log("AC contactor state: "+str(ac_con_state))
    if(ac_con_state == 1):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["input_power_protection_status"]))

    print_with_log("Activating ELR fault")
    all_relay_states["MCU_ELR_CB"]=0
    sleep(5)
    print_with_log("protection state: "+str(CMS_internal_can_dict["input_power_protection_status"]))

    ac_con_state=CMS_internal_can_dict["ac_contactor"]
    print_with_log("AC contactor state: "+str(ac_con_state))
    if(ac_con_state == 0):
        print_with_log("AC contactor off.Test pass")
    else:
        print_with_log("AC contactor not off.Test fail")
    
    all_relay_states["MCU_ELR_CB"]=1

    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def input_power_protection_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting input_power_protection_action_charge_test")

    normal_charge(thermal_emulation_flag=0,exit_after_start=1,drain_check=0,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0)
    
    ac_con_state=CMS_internal_can_dict["ac_contactor"]
    print_with_log("AC contactor state: "+str(ac_con_state))
    if(ac_con_state == 1):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["input_power_protection_status"]))

    print_with_log("Activating ELR fault")
    all_relay_states["MCU_ELR_CB"]=0
    sleep(5)

    print_with_log("protection state: "+str(CMS_internal_can_dict["input_power_protection_status"]))

    ac_con_state=CMS_internal_can_dict["ac_contactor"]
    print_with_log("AC contactor state: "+str(ac_con_state))
    if(ac_con_state == 0):
        print_with_log("AC contactor off.Test pass")
    else:
        print_with_log("AC contactor not off.Test fail")
    
    all_relay_states["MCU_ELR_CB"]=1

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def bms_protection_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting bms_protection_action_charge_test")

    normal_charge(thermal_emulation_flag=0,exit_after_start=1)

    print_with_log("Current set before protection: "+str(CMS_internal_can_dict["set_current"]))
    if(CMS_internal_can_dict["set_current"] >20):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["bms_protection_status"]))

    emulate_charge_protection_trigger()
    sleep(3)
    print_with_log("protection state: "+str(CMS_internal_can_dict["bms_protection_status"]))

    print_with_log("Current set after protection: "+str(CMS_internal_can_dict["set_current"]))
    if(CMS_internal_can_dict["set_current"] <20):
        print_with_log("Charge termination pass")
    else:
        print_with_log("Charge termination fail")
        
    
    emulate_charge_protection_untrigger()
    sleep(2)

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def e_plug_protection_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting e_plug_protection_action_charge_test")

    normal_charge(thermal_emulation_flag=0,exit_after_start=1,drain_check=0,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0)
    print_with_log("Current set before protection: "+str(CMS_internal_can_dict["set_current"]))
    if(CMS_internal_can_dict["set_current"] >20):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["e_plug_protection_status"]))

    print_with_log("Activating gun temp sensor open fault")
    set_temp(-25)
    all_relay_states["CON_P_TS1"]=1
    all_relay_states["CON_P_TS2"]=1
    sleep(5)
    print_with_log("protection state: "+str(CMS_internal_can_dict["e_plug_protection_status"]))

    print_with_log("Current set after protection: "+str(CMS_internal_can_dict["set_current"]))
    if(CMS_internal_can_dict["set_current"] <20):
        print_with_log("Charge termination pass")
    else:
        print_with_log("Charge termination fail")
        
    
    set_temp(25)
    all_relay_states["CON_P_TS1"]=0
    all_relay_states["CON_P_TS2"]=0
    sleep(3)
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def ota_protection_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting ota_protection_action_charge_test")

    normal_charge(thermal_emulation_flag=0,exit_after_start=1,drain_check=0,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0)
    print_with_log("Current set before protection: "+str(CMS_internal_can_dict["set_current"]))
    if(CMS_internal_can_dict["set_current"] >20):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    bms_int_state=CMS_internal_can_dict["bms_interaction_status"]
    print_with_log("BMS interaction state val: "+str(bms_int_state))
    if(bms_int_state > 0):
        print_with_log("initial state pass")
    else:
        print_with_log("initial state fail")

    print_with_log("protection state: "+str(CMS_internal_can_dict["ota_protection_status"]))

    
    emulate_bms_state(3)
    print_with_log("waiting for 100 sec in BMS state for fault activation")
    sleep(100)

    bms_int_state=CMS_internal_can_dict["bms_interaction_status"]
    print_with_log("BMS interaction state val: "+str(bms_int_state))
    if(bms_int_state == 0):
        print_with_log("Interaction state change pass")
    else:
        print_with_log("Interaction state change fail")
    
    print_with_log("protection state: "+str(CMS_internal_can_dict["ota_protection_status"]))

    print_with_log("Current set after protection: "+str(CMS_internal_can_dict["set_current"]))
    if(CMS_internal_can_dict["set_current"] <20):
        print_with_log("Charge termination pass")
    else:
        print_with_log("Charge termination fail")
        
    
    emulate_bms_state(1)
    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def output_power_protection_action_standby_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting output_power_protection_action_standby_test")
    
    set_v_state=CMS_internal_can_dict["set_voltage"]
    print_with_log("Set_voltage: "+str(set_v_state))
    if(set_v_state != 0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["output_power_protection_status"]))

    print_with_log("Activating EM fault")
    all_relay_states["MCU_EM_SW_CB"]=0
    sleep(5)
    print_with_log("protection state: "+str(CMS_internal_can_dict["output_power_protection_status"]))

    set_v_state=CMS_internal_can_dict["set_voltage"]
    print_with_log("Set_voltage: "+str(set_v_state))
    if(set_v_state == 0):
        print_with_log("Rectifier off pass")
    else:
        print_with_log("Rectifier off fail")
    
    all_relay_states["MCU_EM_SW_CB"]=1

    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def output_power_protection_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting output_power_protection_action_charge_test")
    
    normal_charge(thermal_emulation_flag=0,exit_after_start=1,drain_check=0,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0)

    set_v_state=CMS_internal_can_dict["set_voltage"]
    print_with_log("Set_voltage: "+str(set_v_state))
    if(set_v_state != 0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["output_power_protection_status"]))

    print_with_log("Activating EM fault")
    all_relay_states["MCU_EM_SW_CB"]=0
    sleep(5)
    print_with_log("protection state: "+str(CMS_internal_can_dict["output_power_protection_status"]))

    set_v_state=CMS_internal_can_dict["set_voltage"]
    print_with_log("Set_voltage: "+str(set_v_state))
    if(set_v_state == 0):
        print_with_log("Rectifier off pass")
    else:
        print_with_log("Rectifier off fail")
    
    all_relay_states["MCU_EM_SW_CB"]=1

    
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def fcs_battery_heating_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting fcs_battery_heating_action_charge_test")

    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=12,max_cell_t=13,chiller_temp=10,heater_temp=50,
                  base_soc=65,rect_off=0,thermal_emulation_flag=0,drain_check=0,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                  voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
                  low_temp_chtz_step_em=0,chiller_fault=0,heater_fault=0,do_cms_reset=1,matlab_b3=0,check_only_start=0,
                  exit_after_start=0,exit_after_precondition=1)


    
    fcs_state=CMS_internal_can_dict["fcs_status"]
    print_with_log("FCS state: "+str(fcs_state))
    if(fcs_state == 4):
        print_with_log("Initial condition pass. preheating started")
    else:
        print_with_log("Initial condition fail.preheating not started")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["fcs_heating_protection_status"]))

    print_with_log("Activating fault")
    all_relay_states["CON_WATER_INLET"]=1
    set_temp(80)
    sleep(5)

    print_with_log("protection state: "+str(CMS_internal_can_dict["fcs_heating_protection_status"]))

    fcs_state=CMS_internal_can_dict["fcs_status"]
    print_with_log("FCS state: "+str(fcs_state))
    if(fcs_state != 4):
        print_with_log("preheating stopped. test pass")
    else:
        print_with_log("preheating not stopped. test fail")
        
    
    all_relay_states["CON_WATER_INLET"]=0
    set_temp(25)

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()

def fcs_internal_cooling_action_standby_test():
    global CMS_internal_can_dict,fault_dict_new,mbv_open_fault_flag
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting fcs_internal_cooling_action_standby_test")
    st_time=timer()
    while(CMS_internal_can_dict["chiller_reset"]==0):
        print_with_log("waiting for chiller reset to be off")
        sleep(1)
        if(timer()-st_time >300):
            print_with_log("chiller reset not deactivating.timeout.test fail")
            break
    print_with_log("Chiller reset deactivated.")
    print_with_log("making mbv fault")
    mbv_open_fault_flag=1
    sleep(60)
    print_with_log("protection state: "+str(CMS_internal_can_dict["fcs_int_cool_protection_status"]))

    if(CMS_internal_can_dict["fcs_int_cool_protection_status"] == 0):
        print_with_log("protection activation pass")
    else:
        print_with_log("protection activation fail")
    
    print_with_log("CHiller reset state: "+str(CMS_internal_can_dict["chiller_reset"]))

    if(CMS_internal_can_dict["chiller_reset"] == 0):
        print_with_log("protection activation action pass")
    else:
        print_with_log("protection activation action fail")


    mbv_open_fault_flag=0


    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()


def fcs_internal_cooling_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new,mbv_open_fault_flag
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting fcs_internal_cooling_action_charge_test")

    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=37,max_cell_t=38,chiller_temp=10,heater_temp=50,
                  base_soc=65,rect_off=0,thermal_emulation_flag=0,drain_check=0,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                  voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
                  low_temp_chtz_step_em=0,chiller_fault=0,heater_fault=0,do_cms_reset=1,matlab_b3=0,check_only_start=0,
                  exit_after_start=0,exit_after_precondition=1)


    
    fcs_state=CMS_internal_can_dict["fcs_status"]
    print_with_log("FCS state: "+str(fcs_state))
    if(fcs_state == 3):
        print_with_log("Initial condition pass. precooling started")
    else:
        print_with_log("Initial condition fail.precooling not started")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["fcs_int_cool_protection_status"]))

    print_with_log("Activating fault")
    mbv_open_fault_flag=1
    sleep(20)

    print_with_log("protection state: "+str(CMS_internal_can_dict["fcs_int_cool_protection_status"]))

    fcs_state=CMS_internal_can_dict["fcs_status"]
    print_with_log("FCS state: "+str(fcs_state))
    if(fcs_state != 3):
        print_with_log("precooling stopped. test pass")
    else:
        print_with_log("precooling not stopped. test fail")
        
    
    mbv_open_fault_flag=0

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()


def fcs_battery_cooling_action_charge_test():
    global CMS_internal_can_dict,fault_dict_new,mbv_open_fault_flag
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    voltage_cutoff=3.61   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)    
    print_with_log("Starting fcs_battery_cooling_action_charge_test")

    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=37,max_cell_t=38,chiller_temp=10,heater_temp=50,
                  base_soc=65,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                  voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
                  low_temp_chtz_step_em=0,chiller_fault=0,heater_fault=0,do_cms_reset=1,matlab_b3=0,check_only_start=0,
                  exit_after_start=0,exit_after_precondition=1)


    
    fcs_state=CMS_internal_can_dict["fcs_status"]
    print_with_log("FCS state: "+str(fcs_state))
    if(fcs_state == 3):
        print_with_log("Initial condition pass. precooling started")
    else:
        print_with_log("Initial condition fail.precooling not started")
        
    print_with_log("protection state: "+str(CMS_internal_can_dict["fcs_bat_cool_protection_status"]))

    print_with_log("Activating fault")
    emulate_solenoid_fb(0)
    print_with_log("waiting for 200 sec to start internal cooling")
    sleep(200)    
    

    print_with_log("protection state: "+str(CMS_internal_can_dict["fcs_bat_cool_protection_status"]))

    fcs_state=CMS_internal_can_dict["fcs_status"]
    print_with_log("FCS state: "+str(fcs_state))
    if(fcs_state != 3):
        print_with_log("precooling stopped. test pass")
    else:
        print_with_log("precooling not stopped. test fail")
        
    sleep(5)

    if(fcs_state == 2):
        print_with_log("Internal cooling started. test pass")
    else:
        print_with_log("Internal cooling not started. test fail")
        
    

    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    sleep(2)
    all_ard_state_reset()





#endregion

#endregion

#region normal charge functions


def charge_end_function():
    global CMS_internal_can_dict
    st_time=timer()     
    while(CMS_internal_can_dict["algo_charge_complete"]==0):
        print_with_log("Waiting for charge complete signal")
        sleep(1)
        if(timer()-st_time>10):
            print_with_log("charge complete signal timeout")
            break

    if(CMS_internal_can_dict["algo_charge_complete"]==1):
        print_with_log("Received charge complete signal.Test pass")
    else:
        print_with_log("Did not Receive charge complete signal.Test fail")

    st_time=timer()    
    while(CMS_internal_can_dict["drain_required"]==0):
        print_with_log("waiting for drain to start")
        sleep(1)
        if(timer()-st_time>5):
            print_with_log("drain start timeout.")
            break

    if(CMS_internal_can_dict["drain_required"]==1):
        print_with_log("Drain started")
        st_time=timer()    
        while(1):
            print_with_log("waiting for drain to complete")
            if(CMS_internal_can_dict["drain_required"] ==0):
                print_with_log("drain completed")
                break
            if(timer()-st_time>300):
                print_with_log("drain timeout.")
                break
            sleep(1)
        
        if(CMS_internal_can_dict["drain_required"] ==0):
            dur=timer()-st_time
            print_with_log("drain completed in time: "+str(dur))
        else:
            print_with_log("Drain not stopping after 300 sec. Test fail")
    else:
        print_with_log("Drain not started")

def start_charge_function():
    global bms_send_flag, CMS_internal_can_dict
    global correct_current_flag,correct_relay_state_flag
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("In charge start function")
    bms_send_flag=0
    emulate_actual_soc(50)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    emulate_user_soc(50)
    master_swt_on()
    sleep(5)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1    
    sleep(3)
    update_cp_state(4)    
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):        
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return     
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["set_current"])) 

def gun_remove_function(activity_id_check=-1):
    global CMS_internal_can_dict,bms_send_flag,BMS_sent_CAN_msg 
    if(CMS_version == 4.0):  
        st_time=timer()
        while(ota_can_dict["gun_lock_request"]==1):
            print_with_log("waiting for gun unlock request from station")
            sleep(1)
            if(timer()-st_time>180):
                print_with_log("timeout. test fail")
                break
        print_with_log("gun unlock request received")
        emulate_solenoid_fb(0)
        while(get_display_activity_id() == 87):
            pass
        display_id=get_display_activity_id()
        if(activity_id_check != -1):
            if(display_id != activity_id_check):    
                print_with_log("Display activity id not matching. Test fail. Expected: "+str(activity_id_check)+" Received: "+str(display_id))
            else:
                print_with_log("Display activity id matching. Test pass. Expected: "+str(activity_id_check))
                sleep(2)
                if(CMS_internal_can_dict["cms_ui_activity_id"] == activity_id_check):
                    print_with_log("Display activity id persistance after 2 sec. pass")
                else:
                    print_with_log("Display activity id persistance after 2 sec. fail")

        
        sleep(3)
        emulate_gun_unlock()
        sleep(2)
        bms_send_flag=0
        update_cp_state(6)
        st_time=timer()
        while(CMS_internal_can_dict["e_plug_interaction_state"]>=2):
            print_with_log("waiting for eplug interation status to change")
            sleep(1)
            if(timer()-st_time>10):
                print_with_log("Eplug state not changing")
                break
    if(CMS_version==4.2):
        st_time=timer()    
        while(CMS_internal_can_dict["cx_actuator_status"]!=1):
            print_with_log("waiting for cx unlock actuactor to activate")
            sleep(0.1)
            if(timer()-st_time>10):
                print_with_log("cx unlock actuactor not received.Test fail")
                break
        sleep(2)
        update_cp_state(6)  

        st_time=timer()    
        while(CMS_internal_can_dict["e_plug_interaction_state"]==3):
            print_with_log("waiting for e_plug_interaction_state to chnage")
            sleep(0.1)
            if(timer()-st_time>10):
                print_with_log("e_plug_interaction_state not changed .Test fail")
                break
        print_with_log("e_plug_interaction_state changed to: "+str(CMS_internal_can_dict["e_plug_interaction_state"]))
        print_with_log("gun unlock request received")
        while(get_display_activity_id() == 87):
            pass

        display_id=get_display_activity_id()
        if(activity_id_check != -1):
            if(display_id != activity_id_check):    
                print_with_log("Display activity id not matching. Test fail. Expected: "+str(activity_id_check)+" Received: "+str(display_id))
            else:
                print_with_log("Display activity id matching. Test pass. Expected: "+str(activity_id_check))
        update_ulock_status(0)
        sleep(1)    
        print_with_log("Making cp to 12 V to indicate that user has removed form vehicle")
        update_cp_state(12)
        bms_send_flag=0

        st_time=timer()
        while(CMS_internal_can_dict["cx_actuator_status"]!=0):
            print_with_log("waiting for cx unlock actuactor to stop")
            sleep(0.1)
            if(timer()-st_time>10):
                print_with_log("cx unlock actuactor not stopping.Test fail")
                break
        
        update_cp_state(6)       
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_req"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["solenoid_feedback"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_lock_status"]=0
        BMS_sent_CAN_msg["Stateflow_Status"]["gun_unlock_status"]=1
    
    
    

def normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,heater_temp=50,
                  base_soc=65,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                  voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
                  low_temp_chtz_step_em=0,chiller_fault=0,heater_fault=0,do_cms_reset=1,matlab_b3=0,check_only_start=0,
                  exit_after_start=0,exit_after_precondition=0,gun_temp_rise_during_c_rate=-1):
    
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,deactivate_rectifiers_num,battery_thermal_emulation
    global parallel_drain_check,tec_SOC,capacity_deration_check,battery_conditioning_request_check,c_rate_check
    global battery_capacity,chtz_scaling_ah,start_C_rate
    

    print_with_log("Starting normal charge with pack varient: "+str(set_pack_varient)+" chtz cycle: "+str(chtz_flag)
                   +" min_cell_t: "+str(min_cell_t)+" max_cell_t: "+str(max_cell_t)+
                   " rect_off: "+str(rect_off)+" SOC: "+str(base_soc)+" chiller_temp: "+str(chiller_temp)+" heater_temp: "+str(heater_temp))
    
    
    chiller_data["chiller_liquid_temp"]=chiller_temp
    heater_data["heater_tank_temperature"]=heater_temp

    if(chiller_fault==1):
        chiller_data["chiller_aft_probe_fail"]=1
    if(heater_fault==1):
        heater_data["heater_fault_sts_lt"]=1
    emulate_actual_soc(50)

    capacity_deration_check=0
    battery_conditioning_request_check =0
    c_rate_check=0
    parallel_drain_check=0
    sleep(2)    
    
    load_charge_profile_table(pack_varient=set_pack_varient,start_min_temp=min_cell_t,matlab_b3=matlab_b3)

    capacity_deration_check=capacity_deration_check_flag
    battery_conditioning_request_check =fluid_check_flag
    c_rate_check=c_rate_check_flag
    parallel_drain_check=drain_check
    
    battery_thermal_emulation=thermal_emulation_flag
    correct_current_flag=1
    correct_relay_state_flag=1

    if(chtz_flag==0):
        base_chtz_count=60.8
        c_count=67
    elif(chtz_flag==1):
        base_chtz_count=51
        c_count=60.8

    if(c_count >=2 and ((c_count >=2 and c_count <=5) or (c_count>=50 and c_count<51.5) or 
                         (c_count %60 <= 1.5) or (abs(base_chtz_count-c_count)>100))):
        exp_chtz_cycle_flag=1
    else:
        exp_chtz_cycle_flag=0

    
    
    emulate_BMS_cycle_count(c_count)        
    emulate_chtz_cycle_count(base_chtz_count)    
    emulate_min_max_temp(min_temp_val=min_cell_t,max_temp_val=max_cell_t)
    emulate_user_soc(base_soc)

    deactivate_rectifiers_num=rect_off
    master_swt_on()
    sleep(5)

    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1    
    sleep(3)
    update_cp_state(4)    
    emulate_gun_lock()

    chtz_cmd=ota_can_dict["characterization_cmd"]

    chtz_flag=0
    if(chtz_cmd!=0):
        chtz_flag=1
    if(exp_chtz_cycle_flag==chtz_flag):
        print_with_log("CHTZ status as expected. test pass. state: "+str(chtz_flag))
    else:
        print_with_log("CHTZ status not as expected. test fail. state: "+str(chtz_flag)+" exp state: "+str(exp_chtz_cycle_flag))

    st_time=timer()
    while(CMS_internal_can_dict["algo_charge_completion_status"]==0):
        print_with_log("waiting for charge start. charge status: "+str(CMS_internal_can_dict["algo_charge_completion_status"]))
        sleep(5)
        if(timer()-st_time>30):
            print_with_log("charge start timeout. test fail")
            return
        
    print_with_log("in charge start state")

    #### chnage charge start temperature only if specifically asked for
    if(start_charge_min_t!=-1):
        emulate_min_max_temp(min_temp_val=start_charge_min_t,max_temp_val=start_charge_max_t)
    # sleep(5)

    if(exit_after_precondition==1):
        st_time=timer()
        while(CMS_internal_can_dict["fcs_status"] not in [3,4]):
            print_with_log("waiting for precondition to start")
            sleep(2)
            if(timer()-st_time> 100):
                print_with_log("Precondition start timeout")
                break
        print_with_log("FCS state: "+str(CMS_internal_can_dict["fcs_status"]))
        return


    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):        
        # print_with_log("waiting for station to start pushing current")    
        # sleep(0.1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return     
        
    
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

    st_time=timer()  
    while(CMS_internal_can_dict["set_current"]<500):
            ### to check for no tec with termination with chtz step during ramp up
            if(set_pack_varient==1):
                check_curr = 0.26 *battery_capacity
            else:
                check_curr = 0.3 *battery_capacity

            if(abs(CMS_internal_can_dict["set_current"]-check_curr) < 10): 
                if(low_temp_chtz_step_voltage_ib == 1):
                    thermal_emulation_flag=0
                    print_with_log("In CHTZ current step during ramp up")
                    print_with_log("Doing voltage ib cutoff in CHTZ curr during ramp up")
                    ### do voltage ib based cutoff
                    cib = emulate_voltage_ib_cutoff(start_vol=3.3,max_limit=220)
                    thermal_emulation_flag=1

                elif(low_temp_chtz_step_em==1):
                    print_with_log("In CHTZ current step during ramp up")                    
                    print_with_log("Doing EM charge termination in CHTZ curr during ramp up")
                    all_relay_states["MCU_EM_SW_CB"] = 1
                    sleep(3)
                    all_relay_states["MCU_EM_SW_CB"] = 0
            
            # print_with_log("waiting for station to start pushing 3C current. curr now: "+str(CMS_internal_can_dict["set_current"])
            #                +" min temp: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
            sleep(0.1)
            if(CMS_internal_can_dict["dc_contactor"]==0):                
                print_with_log("DC contactor turned off")
                break
            
            if(timer()-st_time>500):
                print_with_log("timeout. test fail")
                return  
    
    print_with_log("Full Current started")

    exp_C_rate=start_C_rate
    act_C_rate=CMS_internal_can_dict["algo_tab_3_c_rate"]
    if(exp_C_rate == act_C_rate):
        print_with_log("Current started with correct C rate: "+str(exp_C_rate))
    else:
        print_with_log("Wrong start C rate. exp val: "+str(exp_C_rate)+" start_c_rate: "+str(act_C_rate)+" .Test fail")
    
    if(exit_after_start==1):
        return
    
    if(check_only_start==1):
        ###activating EM switch
        all_relay_states["MCU_EM_SW_CB"]=0
        sleep(3)
        ###deactivating EM switch
        all_relay_states["MCU_EM_SW_CB"]=1
        
        gun_remove_function()
        bms_send_flag=0          
        sleep(5)        
        chiller_data["chiller_aft_probe_fail"]=0
        heater_data["heater_fault_sts_lt"]=0
        sleep(5)
        
        if(do_cms_reset == 1):
            all_ard_state_reset()
        return


    first_step_flag = 1
    last_set_curr=CMS_internal_can_dict["set_current"]
    same_curr_count=0
    while(1):   
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break     
        
        ### check ah scaling in first current step
        if(first_step_flag ==1):
            first_step_flag=0
            print_with_log("Starting ah calculation")
            start_ah_can = CMS_internal_can_dict["ah"]
            start_scaled_ah_can = ota_can_dict["fast_charger_ah"]
            cal_ah_total=0
            for i in range(300):
                cal_ah_total=cal_ah_total+CMS_internal_can_dict["current_read"]
                sleep(0.2)
            cal_ah = (cal_ah_total/150.0) * (30.0/3600.0)
            end_ah_can= CMS_internal_can_dict["ah"]
            end_scaled_ah_can = ota_can_dict["fast_charger_ah"]

            can_ah_change = end_ah_can - start_ah_can
            FC_sent_ah_change= end_scaled_ah_can - start_scaled_ah_can
            exp_ah_chnage = cal_ah
            percent_err= (abs(exp_ah_chnage-can_ah_change)/can_ah_change) *100.0
            
            print_with_log(" CAN_ah_chnage: "+str(can_ah_change)+" ,Exp_ah_change: "+str(exp_ah_chnage)
                           + " percent err: "+str(percent_err))

            if(percent_err < 2):
                print_with_log("AH calculation as expected.Test pass.")
            else:
                print_with_log("AH calculation not as expected.Test fail")

            if(chtz_flag == 0):
                ## use non scaled ah for non_chtz cycle
                exp_scaled_ah_chnage = cal_ah
            else:
                exp_scaled_ah_chnage = cal_ah * (battery_capacity/(battery_capacity+chtz_scaling_ah))

            percent_err= (abs(exp_scaled_ah_chnage-FC_sent_ah_change)/FC_sent_ah_change) *100.0
            print_with_log("CHTZ cycle: "+str(chtz_flag)+" FC_sent_ah: "+str(FC_sent_ah_change)+" ,Exp_scaled_ah_change: "+str(exp_scaled_ah_chnage)
                           + " percent err: "+str(percent_err))
            
            if(percent_err < 2):
                print_with_log("AH scaling as expected.Test pass.")
            else:
                print_with_log("AH scaling not as expected.Test fail")

        if(gun_temp_rise_during_c_rate != -1 and 
            abs((CMS_internal_can_dict["set_current"]/battery_capacity) - gun_temp_rise_during_c_rate) <0.1):
            print_with_log("Increasing gun temperature for to check for current deartion")
            emulate_all_gun_temp(93)
            sleep(3)
            print_with_log("Decreasing gun temperature for to check for current deartion restoration")
            emulate_all_gun_temp(90)
            sleep(3)




        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
        last_set_curr=CMS_internal_can_dict["set_current"]

        if(voltage_ib_cutoff_check == 0 
           or(voltage_ib_cutoff_check == 1 and voltage_ib_in_chtz_step==1 and CMS_internal_can_dict["set_current"] > 80)):
            ### normal cutoff after ramp up delay
            if(same_curr_count <3):
                ### do max voltage based cutoff
                sleep(10)
                cv=emulate_voltage_increase_till_cutoff(3.3)
                sleep(2)
                emulate_cell_voltages(3.3)
            ### cutoff without delay before ramp up time
            else:
                cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
                sleep(2)
                emulate_cell_voltages(3.3)

        else:
            if(same_curr_count <3):
                sleep(10)
                ### do voltage ib based cutoff
                cib = emulate_voltage_ib_cutoff(start_vol=3.3,max_limit=220,step_ib=0.005)
                sleep(2)
                emulate_cell_voltages(3.3)
                emulate_voltage_IB(0,3.3)
            else:
                ### do voltage ib based cutoff
                cib = emulate_voltage_ib_cutoff(start_vol=3.3,max_limit=220,step_ib=0.02)
                sleep(2)
                emulate_cell_voltages(3.3)
                emulate_voltage_IB(0,3.3)


        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):        
            print_with_log("waiting for station to start pushing current")    
            sleep(1)        
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return     
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break  
        
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

        if(CMS_internal_can_dict["set_current"] == last_set_curr):
            print_with_log("Same current after cutoff")
            same_curr_count+=1
        else:
            same_curr_count=0


        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
    
    
    charge_end_function()
    
    chg_compl_start=timer()    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    # emulate_last_charge_ah(sent_ah)
    
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):  
            if(rect_off<=2 or exp_chtz_cycle_flag==1):          
                print_with_log("Received convergance command")    
                if(ota_can_dict["fc_convergence_soc"] == tec_SOC):
                    print_with_log("Correct TEC SOC received.Test pass. val: "+str(tec_SOC))
                else:
                    print_with_log("TEC SOC rec: "+str(ota_can_dict["fc_convergence_soc"]) +" Exp SOC: "+str(tec_SOC)+" TEC SOC fail.")
            else:
                print_with_log("Received convergance command.test fail")  
                break
            emulate_actual_soc(ota_can_dict["fc_convergence_soc"])
            emulate_user_soc(100.4)
            emulate_tec_ack(v=1)
            sleep(0.1)
            break
        
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            if(rect_off<=2 or exp_chtz_cycle_flag==1):  
                print_with_log("TEC command not received.Test fail")
            else:
                print_with_log("TEC command not received.Test pass")
            break
    
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    chiller_data["chiller_aft_probe_fail"]=0
    heater_data["heater_fault_sts_lt"]=0
    sleep(5)
    if(do_cms_reset == 1):
        all_ard_state_reset()


#endregion

#region algo test functions

def persisting_epump_id():
    global CMS_internal_can_dict
    master_swt_on()
    sleep(3)
    base_val=CMS_internal_can_dict["cms_epump_id"]
    i=1
    for _ in range(10):
        master_swt_off()
        sleep(2)
        master_swt_on()
        sleep(3)
        new_val=CMS_internal_can_dict["cms_epump_id"]
        if(new_val == base_val):
            print_with_log("Epump id persising afer reset no: "+str(i)+" Test pass")
        else:
            print_with_log("Epump id not persising afer reset no: "+str(i)+" Test fail")
        i=i+1
    master_swt_off()
    sleep(2)

def session_conter_increment():
    global CMS_internal_can_dict,bms_send_flag
    master_swt_on()
    sleep(3)
    print_with_log("Starting Session counter increment test")
    base_val=CMS_internal_can_dict["cms_session_count"]
    print_with_log("base_counter_val: "+str(base_val))
    i=0

    for _ in range(10):
        update_cp_state(6)
        sleep(3)
        ### not sending BMS data because the session counter shou,d not be based on BMS data
        # print_with_log("Starting BMS data sending")
        # bms_send_flag=1
        i=i+1
        update_cp_state(4)        
        emulate_gun_lock()
        sleep(5)
        gun_remove_function()
        sleep(2)
        bms_send_flag=0
        sleep(3)

        new_val=CMS_internal_can_dict["cms_session_count"]
        if(new_val==base_val+i):
            print_with_log("Session counter increment correct to: "+str(new_val)+" test pass.")
        else:
            print_with_log("Session counter increment wrong to: "+str(new_val)+ " test fail.")

        
    
    master_swt_off()

def min_cell_temp_computed_verification():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    print_with_log("Starting Min cell temp computation test")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)    
    emulate_gun_lock()
    emulate_min_temp(10)
    emulate_max_temp(10)
    print_with_log("Send 10 from BMS min temp")

    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,30)
    
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    print_with_log("Checking min temp computation in natural conditions")

    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,13)
    emulate_BMS_individual_temp_charge(1,12)
    sleep(1)
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    if(CMS_internal_can_dict["min_cell_temp_computed"]==12):
        print_with_log("min temp detection at 12 pass")
    else:
        print_with_log("min temp detection at 12 fail. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    print_with_log("Checking discounting of 1 low temp val")    
    emulate_BMS_individual_temp_charge(1,-2)
    sleep(1)

    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    if(CMS_internal_can_dict["min_cell_temp_computed"]!=-2):
        print_with_log("min temp -2 discounted pass. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    else:
        print_with_log("min temp -2 dicounting fail. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    print_with_log("Checking Use of BMS data for older BMS FW")
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,13)
    emulate_BMS_FW_version(816)
    emulate_BMS_individual_temp_charge(1,12)
    sleep(1)
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    if(CMS_internal_can_dict["min_cell_temp_computed"]==10):
        print_with_log("min temp from BMS for old BMS pass")
    else:
        print_with_log("min temp from BMS for old BMS fail. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    
    emulate_BMS_FW_version(839)

    print_with_log("Checking use of 2 nd value in case of offset for lowest value")
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,20)

    emulate_BMS_individual_temp_charge(1,12)
    emulate_BMS_individual_temp_charge(2,19)
    sleep(1)
    if(CMS_internal_can_dict["min_cell_temp_computed"]==19):
        print_with_log("min temp with 2nd value pass")
    else:
        print_with_log("min temp with 2nd value fail. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    
    print_with_log("Checking use of 3 rd value in case of offset for lowest value")
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,27)

    emulate_BMS_individual_temp_charge(1,12)
    emulate_BMS_individual_temp_charge(2,19)
    emulate_BMS_individual_temp_charge(3,26)
    sleep(1)
    if(CMS_internal_can_dict["min_cell_temp_computed"]==26):
        print_with_log("min temp with 3rd value pass")
    else:
        print_with_log("min temp with 3rd value fail. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    print_with_log("Checking for CMS computed value less than BMS min temp")
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,8)

    sleep(1)
    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    if(CMS_internal_can_dict["min_cell_temp_computed"]==10):
        print_with_log("min temp from BMS in case of lower pump value pass")
    else:
        print_with_log("min temp from BMS in case of lower pump value  fail. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    print_with_log("Checking for high CMS temperature values")
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,52)
    sleep(1)

    print_with_log("min cell temp BMS: "+str(CMS_internal_can_dict["min_cell_temp"]))
    print_with_log("min cell temp computed: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))

    if(CMS_internal_can_dict["min_cell_temp_computed"]==10):
        print_with_log("min temp from BMS in case of too high pump value pass")
    else:
        print_with_log("min temp from BMS in case of too high pump value  fail. val: "+str(CMS_internal_can_dict["min_cell_temp_computed"]))
    
    for i in range(1,13):
        emulate_BMS_individual_temp_charge(i,26)

    set_temp(25)    
    gun_remove_function() 
    bms_send_flag=0
    correct_current_flag=0
    correct_relay_state_flag=0
    all_ard_state_reset()
    sleep(5)

def bms_reset_ah():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    total_ah=0

    print_with_log("Starting AH reset with BMS reset test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")
    
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
                
        sleep(2)
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
        
        str_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("Start charge ah: "+str(str_ah))        
        print_with_log("waiting for 30 sec")
        sleep(30)
        end_ah=ota_can_dict["fast_charger_ah"]
        total_ah=total_ah+end_ah
        print_with_log("New charge ah: "+str(end_ah))   
        # print_with_log("Doing BMS reset")  
        # emulate_bms_state(0)
        # sleep(1)
        # emulate_bms_state(3)
        # sleep(0.5)
        # emulate_bms_state(1)
        # sleep(1)
        print_with_log("Doing BMS CAN reset")
        bms_send_flag=0
        sleep(1)
        bms_send_flag=1
        sleep(2)


        fin_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("After BMS reset charge ah: "+str(fin_ah))   
        if(fin_ah<0.5):
            print_with_log("AH reset with BMS reset pass")
            gun_remove_function()
            return
        else:
            print_with_log("AH reset with BMS reset fail")
            gun_remove_function()
            return

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break    

        cv=emulate_voltage_increase_till_cutoff(3.3)     

        print_with_log("Voltage increased to : "+str(cv))    
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break    
        
    charge_end_function()
    
    chg_compl_start=timer()
    
    
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()

def bms_state_change_ah_non():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting AH non reset with BMS state change test")    
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)

    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    battrty_polarity_state=0
    update_cp_state(4)    
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")
            
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        sleep(10)
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
        
        str_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("Start charge ah: "+str(str_ah))        
        print_with_log("waiting for 30 sec")
        sleep(30)
        end_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("New charge ah: "+str(end_ah))   
        print_with_log("Doing BMS state change due to charge protection trigger")          
        emulate_charge_protection_trigger()
        sleep(3)
        fin_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("After BMS statte change charge ah: "+str(fin_ah))   
        if(fin_ah<0.5):
            print_with_log("AH non reset with BMS state change fail")
            gun_remove_function()
            return
        else:
            print_with_log("AH non reset with BMS state change pass")
            gun_remove_function()
            return

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break   
        cv=emulate_voltage_increase_till_cutoff(3.3)        
        print_with_log("Voltage increased to : "+str(cv))    
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break    
      

    charge_end_function()
    
    chg_compl_start=timer()
    

    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def user_soc_lock():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    soc_lock=0

    print_with_log("Starting 99 user SOC lock")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)    
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")
    
    while(1):
        
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        sleep(5)
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
        sleep(2)
        

        str_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("Start charge ah: "+str(str_ah))        
        print_with_log("waiting for 15 sec")
        sleep(15)
        end_ah=ota_can_dict["fast_charger_ah"]
        print_with_log("New charge ah: "+str(end_ah))   
        if(soc_lock==0):
            if(end_ah<=str_ah):
                print_with_log("AH increase fail. AH: "+str(end_ah))
            else:
                print_with_log("AH increase pass. AH: "+str(end_ah))
        else:
            if(end_ah<=str_ah):
                print_with_log("AH lock Pass. AH: "+str(end_ah))
            else:
                print_with_log("AH lock fail. AH: "+str(end_ah))


        emulate_user_soc(99.1)
        soc_lock=1
        print_with_log("Usewr SOC to 99.waiting for 15 sec")
        sleep(15)
        new_ah=ota_can_dict["fast_charger_ah"]
        if(new_ah>end_ah):
            print_with_log("AH lock at 99 SOC fail.AH : "+str(new_ah))
            gun_remove_function()
            return
        else:
            print_with_log("AH lock at 99 SOC pass.AH: "+str(new_ah))
            gun_remove_function()
            return

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

        cv=emulate_voltage_increase_till_cutoff(3.3)

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

    charge_end_function()
    
    chg_compl_start=timer()
    

    
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()            
   


def check_max_rect_voltage():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Rectifier max voltage test")

    emulate_pack_voltage(59.4)


        
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    sleep(20)
    v=CMS_internal_can_dict["set_voltage"]
    if(v>59.5):
        print_with_log("Rectifier voltage request going more than limit.Test fail. v= "+str(v))
    else:
        print_with_log("Rectifier voltage request going less than limit.Test pass. v= "+str(v))

    gun_remove_function()
    all_ard_state_reset()

def fake_bms_current(b3_pack=0):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    
    
    if(b3_pack==1):
        emulate_BMS_HW_version(2)
        print_with_log("Starting fake fast charge current test for B3 pack")
    else:
        emulate_BMS_HW_version(21)
        print_with_log("Starting fake fast charge current test for TG pack")

        
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)    
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")
    
    while(1):
        emulate_min_max_temp(min_temp_val=31,max_temp_val=33)
        
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")            
            sleep(1)
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
        
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
        
        
        cms_curr=CMS_internal_can_dict["current_read"]        
        ci_current=ota_can_dict["fast_charger_current"]

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

        cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]>20):
            print_with_log("waiting for current to go to zero.")
            if(timer()-st_time>10):
                print_with_log("current not going to zero")
                break
        if(CMS_internal_can_dict["current_read"]<20):
            print_with_log("Zero sensor current")
            if(abs(ota_can_dict["fast_charger_current"]-40.7)<1):
                if(b3_pack==0):
                    print_with_log("Fake current pass")
                    return
                
                else:
                    print_with_log("No Fake current fail for B3")
                    return
            else:
                if(b3_pack==0):
                    print_with_log("Fake current fail")
                    return
                else:
                    print_with_log("No Fake current pass for B3")
                    return


        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
    
    charge_end_function()
    chg_compl_start=timer()    

    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()
   

def check_chtz(base_c_count=0,base_chtz_count=0,HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting normal charge with HW: "+str(HW_v)+" cycle: "+str(base_c_count)+" base_chtz_cycle: "+str(base_chtz_count))
    emulate_BMS_cycle_count(base_c_count)
    emulate_chtz_cycle_count(base_chtz_count)
    if(base_c_count >=2 and ((base_c_count >=2 and base_c_count <=5) or (base_c_count>=50 and base_c_count<51.5) or  (base_c_count%60 <= 1.5) or (abs(base_chtz_count-base_c_count)>100))):
        exp_chtz_cycle_flag=1
    else:
        exp_chtz_cycle_flag=0
    emulate_BMS_HW_version(HW_v)

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
      
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    sleep(2)
    chtz_cmd=ota_can_dict["characterization_cmd"]
    chtz_flag=0
    if(chtz_cmd!=0):
        chtz_flag=1
    if(exp_chtz_cycle_flag==chtz_flag):
        print_with_log("CHTZ status as expected. test pass. state: "+str(chtz_flag))
        gun_remove_function()
        return
    else:
        print_with_log("CHTZ status not as expected. test fail. state: "+str(chtz_flag)+" exp state: "+str(exp_chtz_cycle_flag))
        gun_remove_function()
        return

    
    emulate_gun_unlock()
    sleep(2)    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()

def check_voltage_ib_non_chtz_high_vol(HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict
    intermediate_value=0.08
    activation_val=0.11
    base_voltage=3.3

    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting voltage ib test with no CHTZ at higher cell voltages")    
    
    emulate_BMS_HW_version(HW_v)
    emulate_BMS_cycle_count(67)
    emulate_cell_voltages(base_voltage)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")    
    sleep(10)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    sleep(2)
    print_with_log("Checking non activation of voltage ib with intermediate value")
    emulate_voltage_IB(val=intermediate_value,base_voltage=base_voltage)
    sleep(3)
    if(fault_dict_new["Pack_Voltage_Imbalance"]==0 and CMS_internal_can_dict["current_read"]>20):
        print_with_log("Non activation of ib pass at value: "+str(intermediate_value))
    else:
        print_with_log("Non activation of ib fail at value: "+str(intermediate_value))
        

    emulate_voltage_IB(val=activation_val,base_voltage=base_voltage)
    st_time=timer()
    while(fault_dict_new["Pack_Voltage_Imbalance"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault activation fail")
            break
    act_time=timer()-st_time
    print_with_log("fault activation in time: "+str(act_time))
    sleep(1)
    if(CMS_internal_can_dict["dc_contactor"]==0):
        print_with_log("DC contactor turned off after activation. Test pass")
        gun_remove_function()
        return
    else:
        print_with_log("DC contactor not turned off after activation. Test fail")
        gun_remove_function()
        return
    
    st_time=timer()
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        
        
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    
    emulate_gun_unlock()
    sleep(2)
    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()

def check_voltage_ib_non_chtz_low_vol(HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict

    intermediate_value=0.14
    activation_val=0.18
    base_voltage=3

    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting voltage ib test with no CHTZ at lower cell voltages")    
    
    emulate_BMS_HW_version(HW_v)
    emulate_BMS_cycle_count(67)
    emulate_cell_voltages(base_voltage)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")   
    sleep(10)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    sleep(2)
    print_with_log("Checking non activation of voltage ib with intermediate value")
    emulate_voltage_IB(val=intermediate_value,base_voltage=base_voltage)
    sleep(3)
    if(fault_dict_new["Pack_Voltage_Imbalance"]==0 and CMS_internal_can_dict["current_read"]>20):
        print_with_log("Non activation of ib pass at value: "+str(intermediate_value))
    else:
        print_with_log("Non activation of ib fail at value: "+str(intermediate_value))
        

    emulate_voltage_IB(val=activation_val,base_voltage=base_voltage)
    st_time=timer()
    while(fault_dict_new["Pack_Voltage_Imbalance"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault activation fail")
            break
    act_time=timer()-st_time
    print_with_log("fault activation in time: "+str(act_time))
    sleep(1)
    if(CMS_internal_can_dict["dc_contactor"]==0):
        print_with_log("DC contactor turned off after activation. Test pass")
        gun_remove_function()
        return
    else:
        print_with_log("DC contactor not turned off after activation. Test fail")
        gun_remove_function()
        return
    
    st_time=timer()
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        
        
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    
    emulate_gun_unlock()
    sleep(2)
    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def check_voltage_ib_chtz_higher_voltage(HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict
    
    intermediate_value=0.19
    activation_val=0.21
    base_voltage=3.3

    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting voltage ib test with  CHTZ at higher voltage")    
    
    emulate_BMS_HW_version(HW_v)
    emulate_BMS_cycle_count(3)
    emulate_cell_voltages(base_voltage)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")   
    
    sleep(10)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    sleep(2)
    print_with_log("Checking non activation of voltage ib with intermediate value")
    emulate_voltage_IB(val=intermediate_value,base_voltage=base_voltage)
    sleep(3)
    if(fault_dict_new["Pack_Voltage_Imbalance"]==0 and CMS_internal_can_dict["current_read"]>20):
        print_with_log("Non activation of ib pass at value: "+str(intermediate_value))
    else:
        print_with_log("Non activation of ib fail at value: "+str(intermediate_value))
        

    emulate_voltage_IB(val=activation_val,base_voltage=base_voltage)
    st_time=timer()
    while(fault_dict_new["Pack_Voltage_Imbalance"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault activation fail")
            break
    act_time=timer()-st_time
    print_with_log("fault activation in time: "+str(act_time))
    sleep(1)
    if(CMS_internal_can_dict["dc_contactor"]==0):
        print_with_log("DC contactor turned off after activation. Test pass")
        gun_remove_function()
        return
    else:
        print_with_log("DC contactor not turned off after activation. Test fail")
        gun_remove_function()
        return
    
    st_time=timer()
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        
        
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    
    emulate_gun_unlock()
    sleep(2)
    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def check_voltage_ib_chtz_lower_voltage(HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict
    
    intermediate_value=0.19
    activation_val=0.21
    base_voltage=3

    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting voltage ib test with  CHTZ at lower voltage")    
    
    emulate_BMS_HW_version(HW_v)
    emulate_BMS_cycle_count(3)
    emulate_cell_voltages(base_voltage)
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started") 
    sleep(10)
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    sleep(2)
    print_with_log("Checking non activation of voltage ib with intermediate value")
    emulate_voltage_IB(val=intermediate_value,base_voltage=base_voltage)
    sleep(3)
    if(fault_dict_new["Pack_Voltage_Imbalance"]==0 and CMS_internal_can_dict["current_read"]>20):
        print_with_log("Non activation of ib pass at value: "+str(intermediate_value))
    else:
        print_with_log("Non activation of ib fail at value: "+str(intermediate_value))
        

    emulate_voltage_IB(val=activation_val,base_voltage=base_voltage)
    st_time=timer()
    while(fault_dict_new["Pack_Voltage_Imbalance"]==0):
        print_with_log("waiting for fault activation")
        sleep(0.1)
        if(timer()-st_time>10):
            print_with_log("Fault activation fail")
            break
    act_time=timer()-st_time
    print_with_log("fault activation in time: "+str(act_time))
    sleep(1)
    if(CMS_internal_can_dict["dc_contactor"]==0):
        print_with_log("DC contactor turned off after activation. Test pass")
        gun_remove_function()
        return
    else:
        print_with_log("DC contactor not turned off after activation. Test fail")
        gun_remove_function()
        return
    
    st_time=timer()
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        
        
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    
    emulate_gun_unlock()
    sleep(2)
    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def TEC_failure_wrong_ah(c_count=102,HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,wrong_last_charge_ah_flag,tec_SOC
    wrong_last_charge_ah_flag=1
    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting TEC_failure_wrong_ah ")
    emulate_BMS_cycle_count(c_count)
    
    emulate_BMS_HW_version(HW_v)
    
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")

    last_current=0
    same_current_count=0            
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        
        if(CMS_internal_can_dict["set_current"] == last_current):
            same_current_count+=1
        else:
            same_current_count=0

        last_current=CMS_internal_can_dict["set_current"]
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"]))        
        
        
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
        if(same_current_count<2):
            sleep(10)
            cv=emulate_voltage_increase_till_cutoff(3.3)
            sleep(2)
        else:
            cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
            sleep(2)


        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

    
    charge_end_function()
    chg_compl_start=timer()
    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    emulate_last_charge_ah(sent_ah+5)

    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):            
            print_with_log("TEC command received.Test fail")
            emulate_actual_soc(tec_SOC)
            emulate_user_soc(100.4)
            sleep(0.1)
            break
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test pass")
            break
    
    if(fault_dict_new["tec_failure"]==1):
        print_with_log("TEC failure fault activated.Test pass")
        wrong_last_charge_ah_flag=0
        gun_remove_function()
        return
    else:
        print_with_log("TEC failure fault not activated.Test fail")
        wrong_last_charge_ah_flag=0
        gun_remove_function()
        return

    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    gun_unlock_delay=timer()-chg_compl_start
    print_with_log("Gun unlock delay: "+str(gun_unlock_delay))
    sleep(2)
    emulate_gun_unlock()
    sleep(2)    
    bms_send_flag=0    
    sleep(5)
    wrong_last_charge_ah_flag=0
    all_ard_state_reset()

def TEC_failure_wrong_soc(c_count=102,HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting TEC_failure_wrong_soc")
    emulate_BMS_cycle_count(c_count)
    
    emulate_BMS_HW_version(HW_v)
    
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
      
    
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")

    last_current=0
    same_current_count=0            
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        
        if(CMS_internal_can_dict["set_current"] == last_current):
            same_current_count+=1
        else:
            same_current_count=0

        last_current=CMS_internal_can_dict["set_current"]
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"]))        
        
        
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
        if(same_current_count<2):
            # sleep(10)
            cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
            # sleep(2)
        else:
            cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
            # sleep(2)


        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

    
    # charge_end_function()
    chg_compl_start=timer()
    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    # emulate_last_charge_ah(sent_ah)
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):            
            print_with_log("Received convergance command : "+str(ota_can_dict["fc_convergence_soc"]))
            print_with_log("changing wrong SOC")
            emulate_actual_soc(ota_can_dict["fc_convergence_soc"]-1)
            emulate_tec_ack(v=1)
            emulate_user_soc(90)
            sleep(1)
            print_with_log("SOC set: "+str(CMS_internal_can_dict["soc_actual"]))
            sleep(10)
            break
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test fail")
            break
    
    if(fault_dict_new["tec_failure"]==1):
        print_with_log("TEC failure fault activated.Test pass")
        gun_remove_function()
        return
    else:
        print_with_log("TEC failure fault not activated.Test fail")
        gun_remove_function()
        return

    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    gun_unlock_delay=timer()-chg_compl_start
    print_with_log("Gun unlock delay: "+str(gun_unlock_delay))
    sleep(2)
    emulate_gun_unlock()
    sleep(2)    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def TEC_failure_wrong_soc_tollerance(c_count=102,HW_v=21):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    if(HW_v>2):
        voltage_cutoff=3.595
    else:
        voltage_cutoff=3.615

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting TEC_failure_wrong_soc_tollerance")
    emulate_BMS_cycle_count(c_count)
    
    emulate_BMS_HW_version(HW_v)
    
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
      
    
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")

    last_current=0
    same_current_count=0            
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            print_with_log("waiting for station to start pushing current")
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        
        if(CMS_internal_can_dict["set_current"] == last_current):
            same_current_count+=1
        else:
            same_current_count=0

        last_current=CMS_internal_can_dict["set_current"]
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"]))        
        
        
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break
        if(same_current_count<2):
            # sleep(10)
            cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
            # sleep(2)
        else:
            cv=emulate_voltage_increase_till_cutoff(3.3,step_v=0.1)
            # sleep(2)


        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

    
    # charge_end_function()
    chg_compl_start=timer()
    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    # emulate_last_charge_ah(sent_ah)
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):            
            print_with_log("Received convergance command: "+str(ota_can_dict["fc_convergence_soc"]))    
            print_with_log("changing wrong SOC within tollerance")
            emulate_actual_soc(ota_can_dict["fc_convergence_soc"]-0.02)
            emulate_tec_ack(v=1)
            emulate_user_soc(90)
            sleep(1)
            print_with_log("SOC set: "+str(CMS_internal_can_dict["soc_actual"]))
            sleep(10)
            break
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test fail")
            break
    
    if(fault_dict_new["tec_failure"]==1):
        print_with_log("TEC failure fault activated.Test fail")
        gun_remove_function()
        return
    else:
        print_with_log("TEC failure fault not activated.Test pass")
        gun_remove_function()
        return

    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    gun_unlock_delay=timer()-chg_compl_start
    print_with_log("Gun unlock delay: "+str(gun_unlock_delay))
    sleep(2)
    emulate_gun_unlock()
    sleep(2)    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def master_error_code_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new
    

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting master_error_code_test")    
    
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=3):
        print_with_log("waiting for fluid on start.")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("Cooling not starting. Test fail")
            return False
    print_with_log("precooling started")
    sleep(30)
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    print_with_log("precooling stopped")
    start_seq=0
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
        
    while(1):
        st_time=timer()
        while(CMS_internal_can_dict["current_read"]<20):
            
            print_with_log("waiting for station to start pushing current")
            if(CMS_internal_can_dict["dc_contactor"]==0):
                print_with_log("DC contactor turned off")
                break
            sleep(1)
            if(timer()-st_time>300):
                print_with_log("timeout. test fail")
                return
        sleep(10)
        print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
        sleep(2)

        if(start_seq==0):
            correct_current_flag=0            
            rectifier_readback_values["current"]=0
            set_curr(0)

            sleep(0.5)
            print_with_log("Dropping current to zero")
            print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 

            st_time=timer()
            while(fault_dict_new["No Current Fault"]==0):
                print_with_log("waiting for fault activation")
                sleep(1)
                if(timer()-st_time>30):
                    print_with_log("Activation timeout.test fail")
                    break
            dur=timer()-st_time
            if(fault_dict_new["No Current Fault"]==1):
                print_with_log("No Current Fault activation pass. duration: "+str(dur))
            else:
                print_with_log("No Current Fault activation fail")
            sleep(2)

            sub_id=CMS_internal_can_dict["cms_mec_subsystem_id"]
            cat_id=CMS_internal_can_dict["cms_mec_category_id"]
            err_id=CMS_internal_can_dict["cms_mec_error_id"]
            print_with_log("MEC subsystem: "+str(sub_id)+" MEC category: "+str(cat_id)+" MEC error: "+str(err_id))
            if(sub_id == 1 and cat_id == 4 and err_id == 7):
                print_with_log("Session master error code as expected. Test pass")
            else:
                print_with_log("Session master error code not as expected. Test fail.")

            
            n_curr=CMS_internal_can_dict["current_read"]
            print_with_log("New current: "+str(n_curr))
            if(n_curr>100):
                print_with_log("charge stop with No Current Fault test fail")
            else:
                print_with_log("charge stop with No Current Fault test pass")
            start_seq=1

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

        cv=emulate_voltage_increase_till_cutoff(3.3)

        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break

    chg_compl_start=timer()
    print_with_log("Activating BMS charge protection")
    emulate_charge_protection_trigger()
    st_time=timer()
    while(fault_dict_new["BMS_ChargeProtection"]==0):
        print_with_log("waiting for fault activation")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("Activation timeout.test fail")
            break
    dur=timer()-st_time
    if(fault_dict_new["BMS_ChargeProtection"]==1):
        print_with_log("BMS_ChargeProtection activation pass. duration: "+str(dur))
    else:
        print_with_log("BMS_ChargeProtection activation fail")
    sleep(2)

    sub_id=CMS_internal_can_dict["cms_mec_subsystem_id"]
    cat_id=CMS_internal_can_dict["cms_mec_category_id"]
    err_id=CMS_internal_can_dict["cms_mec_error_id"]
    print_with_log("MEC subsystem: "+str(sub_id)+" MEC category: "+str(cat_id)+" MEC error: "+str(err_id))
    print_with_log("Master session error code: "+str(CMS_internal_can_dict["session_master_error_index"]))
    if(sub_id == 1 and cat_id == 4 and err_id == 7):
        print_with_log("Session master error code persistance Test pass")
    else:
        print_with_log("Session master error code not persisting. Test fail.")    

    charge_end_function()
    chg_compl_start=timer()
    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    # emulate_last_charge_ah(sent_ah)
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):            
            print_with_log("Received convergance command.Test fail")    
            break
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test pass")
            break
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def chiller_remote_off_before_aft():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,chiller_data
    correct_current_flag=1
    correct_relay_state_flag=1

    print_with_log("Chiller remote off check before aft fault")
    emulate_BMS_cycle_count(67)   
    print_with_log("master on")
    master_swt_on()
    sleep(10)

    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    update_cp_state(6)
    sleep(3)
    chiller_data["chiller_aft_temp"]=12
    sleep(5)
    # while(CMS_internal_can_dict["fcs_status"]!=2):
    #     print_with_log("waiting for CMS to enter internal cooling state")
    #     sleep(1)
    # print_with_log("CMS in internal cooling state")

    st_time=timer()
    while(CMS_internal_can_dict["chiller_reset"]==0):
        print_with_log("waiting for initial chiller state")
        sleep(1)
        if(timer()-st_time>200):
            print_with_log("initial chiller state timeout.Test fail")
            break
    

    if(CMS_internal_can_dict["chiller_reset"]==1):
        print_with_log("Chiller reset in deactivated state")
    else:
        print_with_log("Chiller reset in not in deactivated state.Test fail")
        return

    aft_prevention_flag_state=CMS_internal_can_dict["aft_prevention_flag"]
    print_with_log("aft_prevention_flag_state: "+str(aft_prevention_flag_state))

    if(aft_prevention_flag_state==0):
        print_with_log("AFT prevention flag state in deactivated state.Pass")
    else:
        print_with_log("AFT prevention flag state in activated state.Fail")  
    
    print_with_log("Setting chiller compressor on")
    chiller_data["chiller_compressor_on"]=1
    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=2):
        print_with_log("waiting for internal cooling to start")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("internal cooling not becoming on.timeout.Test fail")
            break
    if(CMS_internal_can_dict["fcs_status"]==2):
        print_with_log("internal cooling start pass")    
    else:
        print_with_log("internal cooling start fail")
    
    print_with_log("Emulating AFT temp fault")
    chiller_data["chiller_aft_temp"]=7

    st_time= timer()
    while(CMS_internal_can_dict["chiller_reset"]==1):
        print_with_log("waiting for chiller_reset to trigger at aft temp: "+str(CMS_internal_can_dict["chiller_aft_temp"]))
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("reset not triggering after 30 sec. timeout.test fail")
            break
    dur=timer()-st_time
    if(CMS_internal_can_dict["chiller_reset"]==0):
        print_with_log("Chiller reset activated after time: "+str(dur)+". Test pass")
        aft_prevention_flag_state=CMS_internal_can_dict["aft_prevention_flag"]
        print_with_log("aft_prevention_flag_state: "+str(aft_prevention_flag_state))

        if(aft_prevention_flag_state==1):
            print_with_log("AFT prevention flag state in activated state.Pass")
        else:
            print_with_log("AFT prevention flag state in deactivated state.Fail") 
        
    else:
        print_with_log("chiller reset not activated after time: "+str(dur)+", test fail")

    chiller_data["chiller_aft_temp"]=10
    print_with_log("Starting deactivation check")
    st_time= timer()
    while(CMS_internal_can_dict["chiller_reset"]==0):
        print_with_log("waiting for chiller reset to untrigger at aft temp: "+str(CMS_internal_can_dict["chiller_aft_temp"]))
        sleep(1)
        if(timer()-st_time>200):
            print_with_log("chiller reset not untriggering after 200 sec. timeout.test fail")
            break
    dur=timer()-st_time
    if(CMS_internal_can_dict["chiller_reset"]==1):
        print_with_log("chiller reset deactivated after time: "+str(dur)+". Test pass")
        aft_prevention_flag_state=CMS_internal_can_dict["aft_prevention_flag"]
        print_with_log("aft_prevention_flag_state: "+str(aft_prevention_flag_state))

        if(aft_prevention_flag_state==0):
            print_with_log("AFT prevention flag state in deactivated state.Pass")
        else:
            print_with_log("AFT prevention flag state in activated state.Fail") 
        
    else:
        print_with_log("chiller reset not untriggering after time: "+str(dur)+", test fail")
    chiller_data["chiller_aft_temp"]=12
    gun_remove_function()
    sleep(5)
    all_ard_state_reset()


def chiller_remote_off_before_aft_during_precooling():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,chiller_data
    correct_current_flag=1
    correct_relay_state_flag=1

    print_with_log("Chiller remote off check before aft fault during precooling")
    emulate_BMS_cycle_count(67)   
    print_with_log("master on")
    master_swt_on()
    sleep(10)

    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    correct_current_flag=1
    correct_relay_state_flag=1    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    st_time=timer()

    while(CMS_internal_can_dict["fcs_status"]!= 3):
        print_with_log("waiting for cooling to start")
        sleep(3)
        if(timer()-st_time>300):
            print_with_log("No cooling start.timeout. test fail")
            return
    chiller_data["chiller_aft_temp"]=12
    sleep(5)
    

    st_time=timer()
    while(CMS_internal_can_dict["chiller_reset"]==0):
        print_with_log("waiting for initial chiller state")
        sleep(1)
        if(timer()-st_time>200):
            print_with_log("initial chiller state timeout.Test fail")
            break
    

    if(CMS_internal_can_dict["chiller_reset"]==1):
        print_with_log("Chiller reset in deactivated state")
    else:
        print_with_log("Chiller reset in not in deactivated state.Test fail")
        return

    aft_prevention_flag_state=CMS_internal_can_dict["aft_prevention_flag"]
    print_with_log("aft_prevention_flag_state: "+str(aft_prevention_flag_state))

    if(aft_prevention_flag_state==0):
        print_with_log("AFT prevention flag state in deactivated state.Pass")
    else:
        print_with_log("AFT prevention flag state in activated state.Fail")  
    
    print_with_log("Emulating AFT temp fault")
    chiller_data["chiller_aft_temp"]=7

    st_time= timer()
    while(CMS_internal_can_dict["chiller_reset"]==1):
        print_with_log("waiting for chiller_reset to trigger at aft temp: "+str(CMS_internal_can_dict["chiller_aft_temp"]))
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("reset not triggering after 30 sec. timeout.test fail")
            break
    dur=timer()-st_time
    if(CMS_internal_can_dict["chiller_reset"]==0):
        print_with_log("Chiller reset activated after time: "+str(dur)+". Test pass")
        aft_prevention_flag_state=CMS_internal_can_dict["aft_prevention_flag"]
        print_with_log("aft_prevention_flag_state: "+str(aft_prevention_flag_state))

        if(aft_prevention_flag_state==1):
            print_with_log("AFT prevention flag state in activated state.Pass")
        else:
            print_with_log("AFT prevention flag state in deactivated state.Fail") 
        
    else:
        print_with_log("chiller reset not activated after time: "+str(dur)+", test fail")

    chiller_data["chiller_aft_temp"]=10
    print_with_log("Starting deactivation check")
    st_time= timer()
    while(CMS_internal_can_dict["chiller_reset"]==0):
        print_with_log("waiting for chiller reset to untrigger at aft temp: "+str(CMS_internal_can_dict["chiller_aft_temp"]))
        sleep(1)
        if(timer()-st_time>200):
            print_with_log("chiller reset not untriggering after 200 sec. timeout.test fail")
            break
    dur=timer()-st_time
    if(CMS_internal_can_dict["chiller_reset"]==1):
        print_with_log("chiller reset deactivated after time: "+str(dur)+". Test pass")
        aft_prevention_flag_state=CMS_internal_can_dict["aft_prevention_flag"]
        print_with_log("aft_prevention_flag_state: "+str(aft_prevention_flag_state))

        if(aft_prevention_flag_state==0):
            print_with_log("AFT prevention flag state in deactivated state.Pass")
        else:
            print_with_log("AFT prevention flag state in activated state.Fail") 
        
    else:
        print_with_log("chiller reset not untriggering after time: "+str(dur)+", test fail")
    chiller_data["chiller_aft_temp"]=12
    sleep(5)
    
    gun_remove_function()
    all_ard_state_reset()

def calage_sending_check():
    global CMS_internal_can_dict
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,wrong_last_charge_ah_flag,tec_SOC
    wrong_last_charge_ah_flag=1


    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting Calage sequence")

    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    emulate_pack_id(400000809)
    
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    
    
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)

    st_time=timer()
    while(ota_can_dict["cms_calage_cmd"] != 0X0A):
        print_with_log("waiting for CMS to send calage cmd")
        sleep(1)
        if(timer()-st_time>200):
            print_with_log("CMS not sending calage cmd.test fail")
            break
    if(ota_can_dict["cms_calage_cmd"] == 0X0A):
        print_with_log("received calage cmd from CMS")
        emulate_bms_calage_cmd_ack(0X0A)
        emulate_bms_calage_ack(0XAA)
        st_time=timer()
        while(ota_can_dict["cms_calage_cmd"] != 0XA0):
            print_with_log("waiting for CMS to send calage cmd A0")
            sleep(1)
            if(timer()-st_time>200):
                print_with_log("CMS not sending calage data.test fail")
                break
        
        if(ota_can_dict["cms_calage_cmd"] == 0XA0):
            print_with_log("CMS cmd ack: "+str(ota_can_dict["cms_calage_cmd"])+" calage value: "+str(ota_can_dict["cms_calage_value"]))
            print_with_log("test pass")
            emulate_bms_calage_cmd_ack(0XA0)
            emulate_bms_calage_ack(0XAA)
            sleep(2)
            emulate_bms_calage_cmd_ack(0)
            emulate_bms_calage_ack(0)

    emulate_gun_lock()
    gun_remove_function()
    sleep(5)
    all_ard_state_reset()
 

def CP4V_debounce_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,tec_SOC
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting CP4V debounce test")
    base_chtz_count=BMS_sent_CAN_msg["Min_Max_IB_Temp"]["characterization_cycle_count"]
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=37,max_temp_val=38)
    
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["fcs_status"]!=3):
        print_with_log("waiting for fluid on start.")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("Cooling not starting. Test fail")
            return False
    print_with_log("precooling started")

    print_with_log("Doing pre-cooling for 30 seconds")
    sleep(30)
    print_with_log("Stopping pre-cooling by reducing max temp to 30")
    emulate_min_max_temp(min_temp_val=32,max_temp_val=33)
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started")
    print_with_log("Toggling CP4V at 0.5 sec interval to check non termination of charge")
    for _ in range(5):
        update_cp_state(6)
        sleep(0.5)
        update_cp_state(4)
        sleep(0.5)
    
    if(CMS_internal_can_dict["current_read"]<20):
        print_with_log("Current stopping due to CP4V toggle.Test fail")
        gun_remove_function()
        return
    else:
        print_with_log("Current not stopping due to CP4V toggle.Test pass")
        gun_remove_function()
        return

    emulate_gun_unlock()
    sleep(2)    
    bms_send_flag=0    
    sleep(5)
    all_ard_state_reset()


def min_cell_temp_C_rate_test(min_cell_t=25,soc_base=40,exp_c_rate=0,heating_req=1):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,battery_thermal_emulation,battery_capacity
    global tec_SOC

    battery_thermal_emulation=1

    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting heater_temp_recovery_durin_cold_charge_test")
    

    print_with_log("making heater comm fault")
    set_slave_states(EM_state_in=True,heater_state_in=False,chiller_state_in=True)
    sleep(10)

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    
    correct_current_flag=1
    correct_relay_state_flag=1
    emulate_user_soc(soc_base)

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    print_with_log("Starting low temperature charge")
    emulate_min_max_temp(min_temp_val=min_cell_t,max_temp_val=min_cell_t+1)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    if(heating_req==1):
        st_time=timer()
        while(CMS_internal_can_dict["fcs_status"]!=4):
            print_with_log("waiting for pre-heating to start")
            sleep(1)
            if(timer()-st_time>30):
                print_with_log("pre-heating not starting. Test pass")
                break
        if(CMS_internal_can_dict["fcs_status"]==4):
            print_with_log("preheating started with heater fault.Test fail")
    else:
        print_with_log("no preheating required")
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started at value: "+str(CMS_internal_can_dict["set_current"]))
    if(abs((CMS_internal_can_dict["set_current"]/battery_capacity)-exp_c_rate)>0.1):
        print_with_log("Start C rate not as expected.test fail")
    else:
        print_with_log("Start C rate  as expected.test pass")

    sleep(10)
    print_with_log("deactivating heater comm fault")
    set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=True)
    sleep(10)
    if(heating_req==1):    
        st_time=timer()
        while(CMS_internal_can_dict["fcs_status"]!=4):
            print_with_log("waiting for heating to start")
            sleep(1)
            if(timer()-st_time>30):
                print_with_log("heating not starting. Test fail")
                break
        if(CMS_internal_can_dict["fcs_status"]==4):
            print_with_log("heating started after hot tank temp recovery.Test pass")
    else:
        print_with_log("no heating required")

    
    gun_remove_function()
    sleep(5)
    all_ard_state_reset()


def max_cell_temp_C_rate_test(max_cell_t=25,soc_base=40,exp_c_rate=0,cold_tank_temp=15,cooling_req=1):
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,fault_dict_new,all_relay_states,heater_data
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,battery_thermal_emulation,chiller_data,battery_capacity
    global tec_SOC

    battery_thermal_emulation=1

    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("Starting max_cell_temp_C_rate_test")
    
    
    chiller_data["chiller_liquid_temp"]=cold_tank_temp
    
   

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    if(not initial_condition_check()):
        return
    
    print_with_log("making chiller comm fault")
    set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=False)
    sleep(10)
    print_with_log(" fcs_cooling_protection_status: "+str(CMS_internal_can_dict["fcs_bat_cool_protection_status"]))
    correct_current_flag=1
    correct_relay_state_flag=1
    emulate_user_soc(soc_base)

    print_with_log("Starting charge")
    emulate_min_max_temp(min_temp_val=max_cell_t-1,max_temp_val=max_cell_t)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)    
    emulate_gun_lock()

    if(cooling_req==1):
        st_time=timer()
        while(CMS_internal_can_dict["fcs_status"]!=3):
            print_with_log("waiting for pre-cooling to start")
            sleep(1)
            if(timer()-st_time>30):
                print_with_log("pre-cooling not starting. Test pass")
                break
        if(CMS_internal_can_dict["fcs_status"]==3):
            print_with_log("precooling started for fcs_cooling fault.Test fail")
    else:
        print_with_log("precooling not needed")
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started at value: "+str(CMS_internal_can_dict["set_current"]))
    if(abs((CMS_internal_can_dict["set_current"]/battery_capacity)-exp_c_rate)>0.1):
        print_with_log("Start C rate not as expected.test fail")
    else:
        print_with_log("Start C rate  as expected.test pass")    
    sleep(5)
    set_slave_states(EM_state_in=True,heater_state_in=True,chiller_state_in=True)
    sleep(20)
    print_with_log("making comm fail recovery ")
    print_with_log(" fcs_cooling_protection_status: "+str(CMS_internal_can_dict["fcs_bat_cool_protection_status"]))
    
    if(cooling_req==1):
        st_time=timer()
        while(CMS_internal_can_dict["fcs_status"]!=3):
            print_with_log("waiting for cooling to start")
            sleep(1)
            if(timer()-st_time>30):
                print_with_log("cooling not starting. Test fail")
                break
        if(CMS_internal_can_dict["fcs_status"]==3):
            print_with_log("cooling started after fcs fault recovery.Test pass")
    else:
        print_with_log("Cooling not required")

    
    gun_remove_function()    
    sleep(5)    
    all_ard_state_reset()


####
#### function to check two consecutive changes without CMS reset
### 0: B3 matlab, 1: B3 C code , 2: TG matlab, 3: TG C code, 4: Tgmax
def consecutive_charge_session_check(start_pack=0,second_pack=1):

    first_session_name=""
    if(start_pack == 0):
        first_session_name="B3 matlab"
    elif(start_pack == 1):
        first_session_name="B3 C code"
    elif(start_pack == 2):
        first_session_name="TG matlab"
    elif(start_pack == 3):
        first_session_name="TG C code"
    elif(start_pack == 4):
        first_session_name="Tgmax C code"
    elif(start_pack == 5):
        first_session_name="Tg 430 C code"
    
    second_session_name=""
    if(second_pack == 0):
        second_session_name="B3 matlab"
    elif(second_pack == 1):
        second_session_name="B3 C code"
    elif(second_pack == 2):
        second_session_name="TG matlab"
    elif(second_pack == 3):
        second_session_name="TG C code"
    elif(second_pack == 4):
        second_session_name="Tgmax C code"
    elif(start_pack == 5):
        second_session_name="Tg 430 C code"
    
    print_with_log("Startig consecutive charge session test: first session: "+str(first_session_name)+" Second session: "+str(second_session_name))

    ### first session
    ### B3 matlab
    if(start_pack ==0):
        normal_charge(chtz_flag=0,set_pack_varient=0,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=0,matlab_b3=1,check_only_start=1)
    ### B3 C code
    elif(start_pack ==1):
        normal_charge(chtz_flag=0,set_pack_varient=0,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=0,matlab_b3=0,check_only_start=1)
    ### TG matlab
    elif(start_pack ==2):
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=0,matlab_b3=1,check_only_start=1)
    ### TG C code
    elif(start_pack ==3):
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=0,matlab_b3=0,check_only_start=1)
    ### TGmax C code
    elif(start_pack ==4):
        normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=0,matlab_b3=0,check_only_start=1)
    elif(start_pack ==5):
        normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=0,matlab_b3=0,check_only_start=1)

    sleep(5)

    ### second session
    ### B3 matlab
    if(second_pack ==0):
        normal_charge(chtz_flag=0,set_pack_varient=0,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=1,matlab_b3=1,check_only_start=1)
    ### B3 C code
    elif(second_pack ==1):
        normal_charge(chtz_flag=0,set_pack_varient=0,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=1,matlab_b3=0,check_only_start=1)
    ### TG matlab
    elif(second_pack ==2):
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=1,matlab_b3=1,check_only_start=1)
    ### TG C code
    elif(second_pack ==3):
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=1,matlab_b3=0,check_only_start=1)
    ### TGmax C code
    elif(second_pack ==4):
        normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=1,matlab_b3=0,check_only_start=1)
    elif(second_pack ==5):
        normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=1,matlab_b3=0,check_only_start=1)
    sleep(5)

def charge_algo_latching_check():
    global CMS_internal_can_dict,bms_send_flag
    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,do_cms_reset=0,matlab_b3=0,check_only_start=1,exit_after_start=1)
    print_with_log("Chnaging to TGmax pack varient")
    emulate_bms_pack_varient(v=2)
    sleep(3)
    pack_v=CMS_internal_can_dict["bms_pack_variant"]
    set_curr=CMS_internal_can_dict["set_current"]
    print_with_log("Pack varient: "+str(pack_v)+" Set_current: "+str(set_curr))
    if(pack_v == 2):
        print_with_log("Pack varient change pass")
        if(set_curr==590): ##TGmax current
            print_with_log("Algo chnaged to TGmax during charge.Test fail")
        else:
            print_with_log("Algo not chnaged to TGmax during charge.Test pass")
    else:
        print_with_log("Pack varient change fail")
    
    all_relay_states["MCU_EM_SW_CB"]=0
    sleep(3)
    ###deactivating EM switch
    all_relay_states["MCU_EM_SW_CB"]=1
    sleep(3)
    gun_remove_function()    
    sleep(5)        
    chiller_data["chiller_aft_probe_fail"]=0
    heater_data["heater_fault_sts_lt"]=0
    sleep(5) 
    all_ard_state_reset()

#endregion

#region new algo_tests

def bms_wakeup_test():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    total_ah=0

    print_with_log("Starting bms_wakeup_test test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=29,max_temp_val=30)
    update_cp_state(6)
    sleep(3)    
    update_cp_state(4)    
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["dc_contactor"] == 0):
        print_with_log("waiting for DC contactor to close")
        sleep(1)
        if(timer()-st_time> 20):
            print_with_log("DC contactor not closing for BMS wakeup.timeout.test fail")
            break
    
    if(CMS_internal_can_dict["dc_contactor"] == 1):
        print_with_log("DC contctor closed for BMS wakeup.test pass")

    print_with_log("starting BSM signals")
    bms_send_flag=1
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started.Test pass")
       
    print_with_log("Activating EM_sw fault")
    all_relay_states["MCU_EM_SW_CB"]=0

    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    
    gun_remove_function()
    sleep(5)
    all_ard_state_reset()

def current_calibration_algo_test():
    global CMS_internal_can_dict,fault_dict_new, calib_state
    
    print("calib_state:" + str(calib_state))
    print_with_log("Starting current_calibration_algo_test")
    print_with_log("master on")
    master_swt_on()
    update_cp_state(6)
    
    sleep(5)   
    g1,g2,off1,off2 = get_curr_calibartion_values()
    g,off,temp =get_current_parameters()
    print_with_log("Checking gain and offset values at start without any eerom value")
    print_with_log("G1: "+str(g1)+" G2: "+str(g2)+" off1: "+str(off1)+" off2: "+str(off2)+" gain: "+str(g)+
                    " offset: "+str(off)+" current_body_temp: "+str(temp))

    if(g1 == 300 and g2 == 300 and g == 300 and off1 == 2.5 and off2 == 2.5 and off== 2.5):
        print_with_log("Base default values pass")
    else:
        print_with_log("Base default values fail")
        return False
    
    
    set_curr(100)
    sleep(5)
    can_v= CMS_internal_can_dict["current_read"]
    print_with_log("Setting current to val: 100A. CAN val: "+str(can_v))
    if(can_v>80 and can_v <120):
        print_with_log("CAN value setting default pass")
    else:
        print_with_log("CAN value setting default fail")
        return False
    
    for t in range(-20,120,20):
        set_current_sensor_body_temp(t)
        can_v_new= CMS_internal_can_dict["current_read"]
        temp = CMS_internal_can_dict["dc_current_sensor_body_temp"]
        print_with_log("CAN val temp: "+str(temp)+" current: "+str(can_v_new))
        if(abs(can_v_new - can_v)<2):
            print_with_log("Current value constant with temp chnage.Pass")
        else:
            print_with_log("Current value not constant with temp chnage.fail")
            return False
    reset_currrent_sensor_body_temp()

    print_with_log("Checking persistance of default values with 2 wrong calibration values")
    send_curr_calibration_values(gain1= 270,gain2=340, offset1=2.3,offset2=2.6)

    g1,g2,off1,off2 = get_curr_calibartion_values()
    g,off,temp =get_current_parameters()
    print_with_log("Checking gain and offset values at start without any eerom value")
    print_with_log("G1: "+str(g1)+" G2: "+str(g2)+" off1: "+str(off1)+" off2: "+str(off2)+" gain: "+str(g)+
                    " offset: "+str(off)+" current_body_temp: "+str(temp))

    if(g1 == 300 and g2 == 300 and g == 300 and off1 == 2.5 and off2 == 2.5 and off== 2.5):
        print_with_log("persistance of default values with 2 wrong calibration values pass")
    else:
        print_with_log("persistance of default values with 2 wrong calibration values fail")
        return False

    print_with_log("Checking persistance of default values with 1st wrong calibration values")
    send_curr_calibration_values(gain1= 270,gain2=320, offset1=2.3,offset2=2.5)

    g1,g2,off1,off2 = get_curr_calibartion_values()
    g,off,temp =get_current_parameters()
    print_with_log("Checking gain and offset values at start without any eerom value")
    print_with_log("G1: "+str(g1)+" G2: "+str(g2)+" off1: "+str(off1)+" off2: "+str(off2)+" gain: "+str(g)+
                    " offset: "+str(off)+" current_body_temp: "+str(temp))

    if(g1 == 300 and g2 == 300 and g == 300 and off1 == 2.5 and off2 == 2.5 and off== 2.5):
        print_with_log("persistance of default values with 1st wrong calibration values pass")
    else:
        print_with_log("persistance of default values with 1st wrong calibration values fail")
        return False
    
    print_with_log("Checking persistance of default values with 2nd wrong calibration values")
    send_curr_calibration_values(gain1= 340,gain2=320, offset1=2.6,offset2=2.5)

    g1,g2,off1,off2 = get_curr_calibartion_values()
    g,off,temp =get_current_parameters()
    print_with_log("Checking gain and offset values at start without any eerom value")
    print_with_log("G1: "+str(g1)+" G2: "+str(g2)+" off1: "+str(off1)+" off2: "+str(off2)+" gain: "+str(g)+
                    " offset: "+str(off)+" current_body_temp: "+str(temp))

    if(g1 == 300 and g2 == 300 and g == 300 and off1 == 2.5 and off2 == 2.5 and off== 2.5):
        print_with_log("persistance of default values with 2nd wrong calibration values pass")
    else:
        print_with_log("persistance of default values with 2nd wrong calibration values fail")
        return False

    print_with_log("Checking calibartion values update")
    send_curr_calibration_values(gain1= 290,gain2=320, offset1=2.48,offset2=2.52)

    g1,g2,off1,off2 = get_curr_calibartion_values()
    g,off,temp =get_current_parameters()
    print_with_log("Checking gain and offset values after calibartion")
    print_with_log("G1: "+str(g1)+" G2: "+str(g2)+" off1: "+str(off1)+" off2: "+str(off2)+" gain: "+str(g)+
                    " offset: "+str(off)+" current_body_temp: "+str(temp))

    if(abs(g1-290)<2 and abs(g2-320)<2 and abs(off1-2.48)<0.05 and abs(off2 - 2.52)<0.05):
        print_with_log("calibartion values update pass")
    else:
        print_with_log("calibartion values update fail")
        return False
    
    calib_state=0
    print("calib_state:" + str(calib_state))
    set_curr(100)

    for t in range(-20,120,10):
        set_current_sensor_body_temp(t)
        sleep(5)
        print_with_log("Low temp fault: "+str(fault_dict_new["current_sensor_Low_Temp_fault"])
                    +" High temp fault: "+str(fault_dict_new["current_sensor_high_Temp_fault"]))
        can_v_new= CMS_internal_can_dict["current_read"]
        g,off,temp =get_current_parameters()
        print_with_log("CAN val temp: "+str(temp)+" current: "+str(can_v_new)+ " gain: "+str(g)+" offset: "+str(off))
        cal_gain,cal_offset = get_expected_gain_offset_val()
        print_with_log("Expected gain: "+str(cal_gain)+" Expected offset: "+str(cal_offset))   

        if(abs(g-cal_gain)< 1.0 and abs(off-cal_offset)<0.05):
            print_with_log("calibartion values update as expected. pass")
        else:
            print_with_log("calibartion values not update as expected. fail")            

        if(abs(can_v_new - can_v)<1):
            print_with_log("Current value constant with temp chnage.Fail")
        else:
            print_with_log("Current value not constant with temp chnage.Pass")           

    reset_currrent_sensor_body_temp()

    print_with_log("Checking persistance of original values with 2nd wrong calibration values")
    send_curr_calibration_values(gain1= 340,gain2=320, offset1=2.6,offset2=2.5)

    g1,g2,off1,off2 = get_curr_calibartion_values()
    g,off,temp =get_current_parameters()
    print_with_log("Checking gain and offset values at start without any eerom value")
    print_with_log("G1: "+str(g1)+" G2: "+str(g2)+" off1: "+str(off1)+" off2: "+str(off2)+" gain: "+str(g)+
                    " offset: "+str(off)+" current_body_temp: "+str(temp))

    if(abs(g1-290)<2 and abs(g2-320)<2 and abs(off1-2.48)<0.05 and abs(off2 - 2.52)<0.05):
        print_with_log("calibartion values Persistnce with wrong update pass")
    else:
        print_with_log("calibartion values Persistnce with wrong update fail")
        return False

    gun_remove_function()
    sleep(5)
    all_ard_state_reset()
    calib_state = 0

def dc_contactor_weld_check_skip_after_EM():
    global dc_contactor_forward_weld_flag

    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,tec_SOC
    voltage_cutoff=3.605   
    correct_current_flag=1
    correct_relay_state_flag=1
    total_ah=0

    
    print_with_log("Starting dc_contactor_weld_check_skip_after_EM test")
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=29,max_temp_val=30)
    update_cp_state(6)
    sleep(3)  
    print_with_log("Activating EM switch")
    all_relay_states["MCU_EM_SW_CB"] = 0
    sleep(5)

    dc_contactor_forward_weld_flag = 1
    print_with_log("Deactivating EM switch with welded DC contactor")
    all_relay_states["MCU_EM_SW_CB"] = 1 
    sleep(2)


    bms_send_flag=1   
    update_cp_state(4)    
    emulate_gun_lock()

    
    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break

    if(CMS_internal_can_dict["current_read"]>20):
        print_with_log("Current started even with DC contactor weld.Test pass")
    else:
        print_with_log("Current not started with DC contactor weld.Test fail")

       
    print_with_log("Activating EM_sw fault")
    all_relay_states["MCU_EM_SW_CB"]=0

    gun_remove_function()
    sleep(5)
    all_ard_state_reset()

def gun_temp_current_deration_during_charge_false_TEC():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,deactivate_rectifiers_num,battery_thermal_emulation
    global parallel_drain_check,tec_SOC,capacity_deration_check,battery_conditioning_request_check,c_rate_check
    global battery_capacity,chtz_scaling_ah,start_C_rate
    

    print_with_log("Starting tec due to gun  temp deration test")
    emulate_actual_soc(50)
    capacity_deration_check=0
    battery_conditioning_request_check =0
    c_rate_check=0
    parallel_drain_check=0
    sleep(2)        
    load_charge_profile_table(pack_varient=1,start_min_temp=27,matlab_b3=0)

    
    
    battery_thermal_emulation=0
    correct_current_flag=1
    correct_relay_state_flag=1

    

    
    
    emulate_BMS_cycle_count(67)        
    emulate_chtz_cycle_count(60)    
    emulate_min_max_temp(min_temp_val=27,max_temp_val=28)
    emulate_user_soc(50)

    
    master_swt_on()
    sleep(5)

    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1    
    sleep(3)
    update_cp_state(4)    
    emulate_gun_lock()

    

    st_time=timer()
    while(CMS_internal_can_dict["algo_charge_completion_status"]==0):
        print_with_log("waiting for charge start. charge status: "+str(CMS_internal_can_dict["algo_charge_completion_status"]))
        sleep(5)
        if(timer()-st_time>1000):
            print_with_log("charge start timeout. test fail")
            return
        
    print_with_log("in charge start state")

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):        
        # print_with_log("waiting for station to start pushing current")    
        # sleep(0.1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return     
        
    sleep(20)
    
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    emulate_cell_voltages(cv= 3.57)
    sleep(3)

    emulate_all_gun_temp(94.2)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"]>200):
        print_with_log("waiting for current to derate")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break    
    if(CMS_internal_can_dict["set_current"] ==0):   
        print_with_log("Current derated to zero Test pass")
    else:
        print_with_log("Current not derated to zero Test fail")
    sleep(1)
    emulate_cell_voltages(cv= 3.40)   
    
    st_time=timer()
    while(CMS_internal_can_dict["set_current"]<200):
        print_with_log("waiting for derated current to start")
        sleep(1)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] <200 and CMS_internal_can_dict["set_current"] >100):
        print_with_log("Current started after deration Test pass")
    else:
        print_with_log("Current not started after deration Test fail")
    sleep(5)
    emulate_all_gun_temp(108)

    while(1):   
        if(CMS_internal_can_dict["dc_contactor"]==0):
            print_with_log("DC contactor turned off")
            break 
    
    charge_end_function()

    
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):                        
            print_with_log("Received convergance command.Test fail")    
            emulate_actual_soc(ota_can_dict["fc_convergence_soc"])
            emulate_user_soc(100.4)
            emulate_tec_ack(v=1)
            sleep(0.1)
            break
        
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test pass")
            break
    
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()

def false_tec_with_fast_gun_connection():
    global CMS_internal_can_dict,bms_send_flag,ota_can_dict
    normal_charge(check_only_start=1,do_cms_reset=0)

    print_with_log("Starting next session")    
    print_with_log("Starting BMS data sending")
    bms_send_flag=1    
    sleep(1)
    update_cp_state(4)    
    emulate_gun_lock()
    st_time=timer()
    while(timer()-st_time<10):
        if(ota_can_dict["fc_convergence_cmd"] == 160):
            print_with_log("CMS sending TEC command at charge start.Test fail")
            break
        sleep(0.1)
    if(ota_can_dict["fc_convergence_cmd"] == 0):
        print_with_log("CMS not sending TEC command at charge start.Test pass")
    
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()

def reverse_cx_gun_lock():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,deactivate_rectifiers_num,battery_thermal_emulation
    global parallel_drain_check,tec_SOC,capacity_deration_check,battery_conditioning_request_check,c_rate_check
    global battery_capacity,chtz_scaling_ah,start_C_rate
    if(CMS_version != 4.2):
        print_with_log("reverse cx gun lock testnot available for this version")
        return

    print_with_log("Starting ulock lock before cp during cx lock test")    
    emulate_actual_soc(50)
    correct_current_flag=1
    correct_relay_state_flag=1
    
    emulate_BMS_cycle_count(67)        
    emulate_chtz_cycle_count(60)    
    emulate_min_max_temp(min_temp_val=27,max_temp_val=28)
    
    master_swt_on()
    sleep(5)

    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1    
    sleep(3)
    update_ulock_status(s=1)
    sleep(0.5)
    update_cp_state(4)    
    emulate_gun_lock()

    st_time=timer()
    while(CMS_internal_can_dict["algo_charge_completion_status"]==0):
        print_with_log("waiting for charge start. charge status: "+str(CMS_internal_can_dict["algo_charge_completion_status"]))
        sleep(5)
        if(timer()-st_time>1000):
            print_with_log("charge start timeout. test fail")
            return
        
    print_with_log("in charge start state")

    

    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):        
        print_with_log("waiting for station to start pushing current")    
        sleep(0.1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return     
        
    
    print_with_log("Charging at Current: "+str(CMS_internal_can_dict["current_read"])) 
    if(CMS_internal_can_dict["current_read"] > 20):
        print_with_log("Current started with ulock before cp. test pass")
    else:
        print_with_log("Current not started with ulock before cp. test fail")

    
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    chiller_data["chiller_aft_probe_fail"]=0
    heater_data["heater_fault_sts_lt"]=0
    sleep(5)
    all_ard_state_reset()

def gun_temp_sensor_open_rejection_test():
    global CMS_internal_can_dict,all_relay_states,fault_dict_new,bms_send_flag
    print_with_log("Starting gun temp sensor open rejection test for gun over temp warning")
    fault1="Gun_over_temperature"
    fault2="Gun_over_temp_warning"
    relay_name="CON_P_TS1"
    can_signal="gun_temp_p_1"

    master_swt_on()
    sleep(5)
    update_cp_state(6)
    sleep(3)
    set_temp(25)
    all_relay_states[relay_name] =1
    print_with_log("Gun temp values: "+str(CMS_internal_can_dict[can_signal]))
    fault_state1=fault_dict_new[fault1]
    fault_state2=fault_dict_new[fault2]
    print_with_log("Gun over temp fault: "+str(fault_state1)+" Gun over temp warning: "+str(fault_state2))
    if(fault_state1 == 0 and fault_state2 == 0):
        print_with_log("Gun over temp fault and warning not set.initial condition pass")   
    print_with_log("Setting gun temp sensor open fault")
    set_temp(140)
    sleep(3)
    print_with_log("Gun temp values: "+str(CMS_internal_can_dict[can_signal]))

    fault_state1=fault_dict_new[fault1]
    fault_state2=fault_dict_new[fault2]
    print_with_log("Gun over temp fault: "+str(fault_state1)+" Gun over temp warning: "+str(fault_state2))
    if(fault_state1 == 0 and fault_state2 == 0):
        print_with_log("Gun over temp fault and warning not set with temperature in open limit.Test pass")

    set_temp(25)
    all_relay_states[relay_name] =0
    sleep(3)
    all_ard_state_reset()
    sleep(2)
    print_with_log("Starting gun temp sensor open rejection test during charge")
    normal_charge(exit_after_start=1)
    print_with_log("Starting gun temp fluctuations")
    set_temp(25)
    all_relay_states[relay_name] =1

    for _ in range(10):
        set_temp(140)
        sleep(2)
        set_temp(-50)
        sleep(2)

    set_temp(25)
    sleep(2)

    if(CMS_internal_can_dict["set_current"]>50):
        print_with_log("Charge not stopping with one gun temp fluctuations. test pass")
    else:
        print_with_log("Charge stopping with one gun temp fluctuations. test fail")

    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    chiller_data["chiller_aft_probe_fail"]=0
    heater_data["heater_fault_sts_lt"]=0
    sleep(5)
    all_ard_state_reset()
    
def gun_temp_current_deration_no_previos_cutoff():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,battery_capacity
    correct_current_flag=1
    correct_relay_state_flag=1

    if(battery_capacity < 175):
        c_rate_list=[3.43,2.9,2.0,1.0,0]
    else:
        c_rate_list=[2.95,2.5,2.0,1.0,0]

    print_with_log("Starting current deration due to gun temperature test for no previos cutoff")

    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)

    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started at val: "+str(CMS_internal_can_dict["current_read"]))

    emulate_all_gun_temp(87)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[0])<50):
        print_with_log("No current deration. Test pass")
    else:
        print_with_log("current deration observed. Test fail")
    
    emulate_all_gun_temp(91)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[1])<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(93)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[2])<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(94.5)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[3])<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(106)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[4])<50):
        print_with_log("Charge terminated as expected. Test pass")
        gun_remove_function()
        emulate_all_gun_temp(25)
        all_ard_state_reset()
        return
    else:
        print_with_log("Charge not terminated. Test fail")
        gun_remove_function()
        emulate_all_gun_temp(25)
        all_ard_state_reset()
        return

    st_time=timer()    
    while(CMS_internal_can_dict["cx_actuator_status"]==0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    
    
    emulate_gun_unlock()
    sleep(2)    
    bms_send_flag=0    
    sleep(5)
    emulate_all_gun_temp(25)
    all_ard_state_reset()

def gun_temp_current_deration_after_cutoff():
    global CMS_internal_can_dict,correct_current_flag,correct_relay_state_flag,cp_state,bms_send_flag,voltage_cutoff
    global battrty_polarity_state,ota_can_dict,BMS_sent_CAN_msg,battery_capacity

    if(battery_capacity<180):
        c_rate_list=[3.43,2.9,2.0,1.0,0]
    else:
        c_rate_list=[2.95,2.5,2.0,1.0,0]


    correct_current_flag=1
    correct_relay_state_flag=1

    print_with_log("Starting current deration due to gun temperature test after cutoff")

   
    voltage_cutoff=3.605   
    gun_temp_warning_activation=97
    

    fault_name="Gun Overheat cutoff"
    error_name="Gun_over_temperature"
    gun_relay_names_list=["CON_P_TS1","CON_P_TS2","CON_P_TS3","CON_P_TS4"]

    correct_current_flag=1
    correct_relay_state_flag=1
    print_with_log("master on")
    master_swt_on()
    sleep(5)
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    
    emulate_gun_lock()
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started at val: "+str(CMS_internal_can_dict["current_read"]))

    if(not initial_condition_check()):
        return
    emulate_all_gun_temp(25)    
    
    if(fault_dict_new[error_name]==0):
        print_with_log("Initial condition pass")
    else:
        print_with_log("Initial condition fail")
        return
    emulate_all_gun_temp(gun_temp_warning_activation)
    sleep(10)
    
    if(fault_dict_new[error_name]==1):
        print_with_log("fault activation pass")
    else:
        print_with_log("fault activation  fail")
        return
    
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(curr<50):
        print_with_log("CHarge terminated.Test pass")
    else:
        print_with_log("CHarge not terminated.Test fail")    
    set_temp(25)    
    gun_remove_function()
    sleep(10)

    if(fault_dict_new[error_name]==0):
        print_with_log("fault deactivation pass")
    else:
        print_with_log("fault deactivation  fail")
        

    print_with_log("Starting second charge after deactivation of over temperature cutoff")
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1
    update_cp_state(4)
    emulate_gun_lock()

    
    st_time=timer()
    while(CMS_internal_can_dict["current_read"]<20):
        print_with_log("waiting for station to start pushing current")    
        sleep(1)        
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            return
    print_with_log("Current started at val: "+str(CMS_internal_can_dict["current_read"]))

    emulate_all_gun_temp(87)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[0])<50):
        print_with_log("No current deration. Test pass")
    else:
        print_with_log("current deration observed. Test fail")
    
    emulate_all_gun_temp(91)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[1])<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(93)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[2])<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(94.5)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[3])<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(96)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-battery_capacity*c_rate_list[4])<50):
        print_with_log("Charge terminated as expected. Test pass")
        gun_remove_function()
        emulate_all_gun_temp(25)
        all_ard_state_reset()
        return
    else:
        print_with_log("Charge not terminated. Test fail")
        gun_remove_function()
        emulate_all_gun_temp(25)
        all_ard_state_reset()
        return

###### 0 : B3, 1: TG 352, 2: tgmax, 3: tg 430
def gun_temp_deration_table_test(pack_type=1):
    global CMS_internal_can_dict,battery_capacity,all_relay_states,bms_send_flag    
    print_with_log("Checking gun temp deration table for pack type: "+str(pack_type))
    load_charge_profile_table(pack_varient=pack_type,start_min_temp=27,matlab_b3=0)
    c_rate_list=[]
    if(pack_type ==0):
        c_rate_list=[3.71,3.0,2.0,1.0,0]
    elif(pack_type ==1 or pack_type ==3):
        c_rate_list=[3.43,2.9,2.0,1.0,0]
    elif(pack_type ==2):
        c_rate_list=[2.95,2.5,2.0,1.0,0]
    
    normal_charge(set_pack_varient= pack_type,exit_after_start=1,do_cms_reset=0)
    
    print_with_log("Current started at val: "+str(CMS_internal_can_dict["current_read"]))

    emulate_all_gun_temp(87)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-c_rate_list[0]*battery_capacity)<50):
        print_with_log("No current deration. Test pass")
    else:
        print_with_log("current deration observed. Test fail")
    
    emulate_all_gun_temp(91)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-c_rate_list[1]*battery_capacity)<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(87)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-c_rate_list[1]*battery_capacity)<50):
        print_with_log("current deration non recovery Test pass")
    else:
        print_with_log("current deration non recovery Test fail")
    
    emulate_all_gun_temp(93)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-c_rate_list[2]*battery_capacity)<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(94.5)
    sleep(8)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-c_rate_list[3]*battery_capacity)<50):
        print_with_log("current deration as expected. Test pass")
    else:
        print_with_log("current deration not as expected. Test fail")
    
    emulate_all_gun_temp(96)
    sleep(8)
    emulate_all_gun_temp(25)
    curr=CMS_internal_can_dict["current_read"]
    print_with_log("Charging at current: "+str(curr))
    if(abs(curr-0)>50):
        print_with_log("Charge not terminated. Test fail")
        gun_remove_function()
        return

    charge_end_function()
    
    chg_compl_start=timer()    
    sent_ah=ota_can_dict["fast_charger_ah"]
    print_with_log("Final AH sent to BMS: "+str(sent_ah))
    # emulate_last_charge_ah(sent_ah)
    
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):  
            print_with_log("Received convergance command.Test fail")  
            break 
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test pass")
            break
    
    gun_remove_function()
    bms_send_flag=0    
    all_ard_state_reset()


def current_deration_due_to_high_temp():
    global CMS_internal_can_dict,fault_dict_new,battery_capacity,bms_send_flag
    print_with_log("Starting current deration due to high temp test")
    normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                  base_soc=65,rect_off=0,thermal_emulation_flag=0,drain_check=0,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                  voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
                  low_temp_chtz_step_em=0,exit_after_start=1,check_only_start=0)
    
    emulate_min_max_temp(min_temp_val=41,max_temp_val=41)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))

    emulate_min_max_temp(min_temp_val=44,max_temp_val=44)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))

    emulate_min_max_temp(min_temp_val=48,max_temp_val=48)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))

    emulate_min_max_temp(min_temp_val=52,max_temp_val=52)
    charge_end_function()
    
    
    
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):                      
            print_with_log("Received convergance command.Test fail")                
            emulate_actual_soc(ota_can_dict["fc_convergence_soc"])
            emulate_user_soc(100.4)
            emulate_tec_ack(v=1)
            sleep(0.1)
            break        
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test pass")
            break    
    st_time=timer()    
    while(ota_can_dict["gun_lock_request"]!=0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    
    sleep(2)
    emulate_gun_unlock()
    sleep(2) 
    bms_send_flag=0    
    all_ard_state_reset() 

def current_deration_due_to_low_temp():
    global CMS_internal_can_dict,fault_dict_new,battery_capacity,bms_send_flag
    print_with_log("Starting current deration due to low temp test")
    normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                  base_soc=65,rect_off=0,thermal_emulation_flag=0,drain_check=0,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                  voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
                  low_temp_chtz_step_em=0,exit_after_start=1,check_only_start=0)
    
    emulate_min_max_temp(min_temp_val=23,max_temp_val=23)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))

    emulate_min_max_temp(min_temp_val=20,max_temp_val=20)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))

    emulate_min_max_temp(min_temp_val=17,max_temp_val=17)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))
    
    emulate_min_max_temp(min_temp_val=12,max_temp_val=12)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))

    emulate_min_max_temp(min_temp_val=6,max_temp_val=6)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] != 0):
        print_with_log("waiting for current deration")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current deration to 0 as expected.Test pass")
    else:
        print_with_log("current deration not to 0 as expected.Test fail")
    st_time=timer()
    while(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("waiting for current step to chnage")
        sleep(0.5)
        if(timer()-st_time>30):
            print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"] == 0):
        print_with_log("current step not changed.Test fail")
    else:
        print_with_log("current step changed.Test pass")
        c_rate=CMS_internal_can_dict["set_current"]/battery_capacity
        print_with_log("current deration: "+str(c_rate))

    emulate_min_max_temp(min_temp_val=4,max_temp_val=4)
    charge_end_function()
    
   
    
    
    st_time=timer()
    while(1):
        if(ota_can_dict["fc_convergence_cmd"]==160):                      
            print_with_log("Received convergance command.Test fail")                
            emulate_actual_soc(ota_can_dict["fc_convergence_soc"])
            emulate_user_soc(100.4)
            emulate_tec_ack(v=1)
            sleep(0.1)
            break        
        print_with_log("waiting for TEC commnad")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("TEC command not received.Test pass")
            break    
    st_time=timer()    
    while(ota_can_dict["gun_lock_request"]!=0):
        print_with_log("waiting for gun unlock request from station")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break
    
    sleep(2)
    emulate_gun_unlock()
    sleep(2) 
    bms_send_flag=0    
    all_ard_state_reset() 


def pump_interlock_test():
    global CMS_internal_can_dict,chiller_data
    master_swt_on()
    update_cp_state(6)
    sleep(5)
    st_time=timer()
    while(CMS_internal_can_dict["chiller_settings_ok"]!=1):
        sleep(1)
        print_with_log("waiting for chiller setting to be ok")
        if(timer()-st_time>60):
            print_with_log("chiller setting not becoming ok.timeout.Test fail")
            return False
    sleep(5)
    print_with_log("Chiller settings ok")
    print_with_log("Starting chiller pump interlock test")
    print_with_log("Setting chiller compressor on")
    chiller_data["chiller_compressor_on"]=1
    st_time=timer()
    while(CMS_internal_can_dict["coolent_motor"]!=1):
        print_with_log("waiting for chiller pump to be on")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("chiller pump not becoming on.timeout.Test fail")
            break
    if(CMS_internal_can_dict["coolent_motor"]==1):
        print_with_log("Chiller pump on pass")    
    else:
        print_with_log("Chiller pump on fail")

    print_with_log("Setting chiller compressor off")
    chiller_data["chiller_compressor_on"]=0
    st_time=timer()
    while(CMS_internal_can_dict["coolent_motor"]!=0):
        print_with_log("waiting for chiller pump to be off")
        sleep(1)
        if(timer()-st_time>60):
            print_with_log("chiller pump not becoming off.timeout.Test fail")
            break
    if(CMS_internal_can_dict["coolent_motor"]==0):
        print_with_log("Chiller pump off pass")    
    else:
        print_with_log("Chiller pump off fail")
    
    all_ard_state_reset()

def can_fast_toggle_test():
    global CMS_internal_can_dict,bms_send_flag,ota_can_dict
    print_with_log("Starting CAN fast toggle test")
    normal_charge(exit_after_start=1,do_cms_reset=0,thermal_emulation_flag=0)
    print_with_log("Charging started.")
    sleep(20)

    base_id=get_display_activity_id()
    sleep(5)
    bms_send_flag =0
    print_with_log("Disabling BMS send")
    sleep(1)
    bms_send_flag =1
    print_with_log("Enabling BMS send")
    sleep(10)
    if(CMS_internal_can_dict["set_current"]>50):
        print_with_log("Current flow continues after CAN fast toggle. Test pass")
    else:
        print_with_log("Current flow stops after CAN fast toggle. Test fail")
    
    new_id=get_display_activity_id()
    if(new_id==base_id):
        print_with_log("CAN fast toggle not changing screen.test pass")
    else:
        print_with_log("CAN fast toggle changing screen.test fail")
    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()
 
def can_slow_toggle_test():
    global CMS_internal_can_dict,bms_send_flag,ota_can_dict,fault_dict_new
    print_with_log("Starting CAN slow toggle test")
    normal_charge(exit_after_start=1,do_cms_reset=0,thermal_emulation_flag=0)
    print_with_log("Charging started.")
    sleep(20)
    base_id=get_display_activity_id()
    sleep(5)
    bms_send_flag =0
    print_with_log("Disabling BMS send")
    sleep(3)
    bms_send_flag =1
    print_with_log("Enabling BMS send")
    sleep(10)
    if(CMS_internal_can_dict["set_current"]>50):
        print_with_log("Current flow continues after CAN slow toggle. Test fail")
    else:
        print_with_log("Current flow stops after CAN slow toggle. Test pass")
    
    new_id=get_display_activity_id()
    if(new_id==base_id):
        print_with_log("CAN slow toggle not changing screen.test fail")
    else:
        print_with_log("CAN slow toggle changing screen.test pass")

    if(fault_dict_new["BMS CAN Freeze"]==1):
        print_with_log("BMS CAN freeze fault set.Test pass")
    else:   
        print_with_log("BMS CAN freeze fault not set.Test fail")

    # charge_end_function()

    gun_remove_function(activity_id_check=100)
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()

def fast_gun_toggle_test():
    global CMS_internal_can_dict,bms_send_flag,ota_can_dict,fault_dict_new
    print_with_log("Starting fast gun toggle test")    
    normal_charge(exit_after_start=1,do_cms_reset=0,thermal_emulation_flag=0)
    print_with_log("Charging started.")
    sleep(20)
    base_id=get_display_activity_id()
    sleep(5)
    emulate_unauthorized_gun_removal()
    sleep(1)
    emulate_unauthorized_gun_reconnection(sol_fb=1)
    sleep(10)
    if(CMS_internal_can_dict["set_current"]>50):
        print_with_log("Current flow continues after gun connection fast toggle. Test pass")
    else:
        print_with_log("Current flow stops after gun connection fast toggle. Test fail")
    
    new_id=get_display_activity_id()
    if(new_id==base_id):
        print_with_log("gun connection fast toggle not changing screen.test pass")
    else:
        print_with_log("gun connection fast toggle changing screen.test fail")

    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()

def slow_gun_toggle_test(): 
    global CMS_internal_can_dict,bms_send_flag,ota_can_dict,fault_dict_new
    print_with_log("Starting Gun connection slow toggle test")
    normal_charge(exit_after_start=1,do_cms_reset=0,thermal_emulation_flag=0)
    print_with_log("Charging started.")
    sleep(20)
    base_id=get_display_activity_id()
    sleep(5)
    emulate_unauthorized_gun_removal()
    sleep(3)
    emulate_unauthorized_gun_reconnection(sol_fb=0)
    sleep(10)
    if(CMS_internal_can_dict["set_current"]>50):
        print_with_log("Current flow continues after gun connection slow toggle. Test fail")
    else:
        print_with_log("Current flow stops after gun connection slow toggle. Test pass")
    
    new_id=get_display_activity_id()
    if(new_id==base_id):
        print_with_log("gun connection slow toggle not changing screen.test fail")
    else:
        print_with_log("gun connection slow toggle changing screen.test pass")

    if(fault_dict_new["Unauthorized_GUN_Removal"]==1):
        print_with_log("Unauthorized_GUN_Removal fault set.Test pass")
    else:   
        print_with_log("Unauthorized_GUN_Removal fault not set.Test fail")

    # charge_end_function()

    gun_remove_function(activity_id_check=99)
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()


def fast_gun_toggle_before_charge_test():
    global CMS_internal_can_dict,bms_send_flag,ota_can_dict,fault_dict_new
    print_with_log("Starting fast gun toggle before charge test")    
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    master_swt_on()
    sleep(5)

    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1    
    sleep(3)
    update_cp_state(4)    
    emulate_gun_lock()    
    emulate_unauthorized_gun_removal()
    sleep(0.8)
    emulate_unauthorized_gun_reconnection(sol_fb=1)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"]<50):
        print_with_log("waiting for current to start")
        sleep(1)
        if(timer()-st_time>300):
            print_with_log("timeout. test fail")
            break

    if(CMS_internal_can_dict["set_current"]>50):
        print_with_log("Current start after gun connection fast toggle. Test pass")
    else:
        print_with_log("Current not starting after gun connection fast toggle. Test fail")
    
    new_id=get_display_activity_id()
    if(new_id==83):
        print_with_log("Charging screen shown.test pass")
    else:
        print_with_log("Charging screen not shown.test fail.activity id: "+str(new_id))

    gun_remove_function()
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()

def slow_gun_toggle_before_charge_test(): 
    global CMS_internal_can_dict,bms_send_flag,ota_can_dict,fault_dict_new
    print_with_log("Starting slow gun toggle before charge test")    
    emulate_min_max_temp(min_temp_val=26,max_temp_val=27)
    master_swt_on()
    sleep(5)

    update_cp_state(6)
    sleep(3)
    print_with_log("Starting BMS data sending")
    bms_send_flag=1    
    sleep(3)
    update_cp_state(4)    
    emulate_gun_lock()    
    emulate_unauthorized_gun_removal()
    sleep(3)
    emulate_unauthorized_gun_reconnection(sol_fb=1)
    st_time=timer()
    while(CMS_internal_can_dict["set_current"]<50):
        print_with_log("waiting for current to start")
        sleep(1)
        if(timer()-st_time>100):
            # print_with_log("timeout. test fail")
            break
    if(CMS_internal_can_dict["set_current"]>50):
        print_with_log("Current start after gun connection slow toggle. Test fail")
    else:
        print_with_log("Current not starting after gun connection fast toggle. Test pass")
    
    if(fault_dict_new["Unauthorized_GUN_Removal"]==1):
        print_with_log("Unauthorized_GUN_Removal fault set.Test pass")
    else:   
        print_with_log("Unauthorized_GUN_Removal fault not set.Test fail")

    # charge_end_function()

    gun_remove_function(activity_id_check=99)
    bms_send_flag=0    
    sleep(5)
    emulate_cell_voltages(cv= 3.3)
    emulate_all_gun_temp(25)
    all_ard_state_reset()



#endregion    


#region combined_test_functions


def check_all_inputs_mapping(HW_v=21,FW_v=839,c_count=102):
    global change_chiller_flag,cb_vars
    if(cb_vars["input_mapping_thermistor_mapping"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking thermistor mapping")    
        check_thermistor_mapping()
    if(cb_vars["input_mapping_temperature_range"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking temperature range")
        check_temperature_range()
    
    if(cb_vars["input_mapping_current_sensor"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking current sensor inputs")
        check_current_sensor()
    if(cb_vars["input_mapping_pressure_sensor"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking pressure sensor inputs")
        check_pressure_sensor()
    if(cb_vars["input_mapping_gpio_mapping"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking input GPIO mapping")
        check_gpio_mapping()
    if(cb_vars["input_mapping_cp_activation"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking CP inputs")
        check_cp_activation()
    if(cb_vars["input_mapping_battery_polarity_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking polarity detection")
        check_battery_polarity_detection()
    if(cb_vars["input_mapping_rectifier_readback"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking rectifier readback")
        check_rectifier_readback()    
    if(cb_vars["input_mapping_chiller_readback"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking chiller readback")
        check_chiller_readback()
    if(cb_vars["input_mapping_heater_readback"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
        print_with_log("Checking heater readback")    
        check_heater_readback()
    if(cb_vars["input_mapping_EM_readback"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking EM readback")    
        check_EM_readback()    
    if(cb_vars["input_mapping_BMS_can_datarate"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        print_with_log("Checking BMS data update")    
        check_BMS_can_datarate()

def check_protections_input_grid(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_input_grid_spd_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        spd_fault_protection_test()
    if(cb_vars["protections_input_grid_elr_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        elr_fault_protection_test()
    if(cb_vars["protections_input_grid_VR_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        VR_fault_protection_test()
    if(cb_vars["protections_input_grid_em_sw"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        em_sw_fault_protection_test()
    if(cb_vars["protections_input_grid_grid_power_cut"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        grid_power_cut_protection_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    
def check_protections_output_power(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_output_power_rectifier_ref_curr_offset_positive"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        rectifier_ref_curr_offset_positive()
    if(cb_vars["protections_output_power_rectifier_ref_curr_offset_negative"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        rectifier_ref_curr_offset_negative()
    if(cb_vars["protections_output_power_Reference_sensor_Current_offset_Positive"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Reference_sensor_Current_offset_Positive()
    if(cb_vars["protections_output_power_Reference_sensor_Current_offset_Negative"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Reference_sensor_Current_offset_Negative()
    if(cb_vars["protections_output_power_Rectifier_derated"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Rectifier_derated()
    if(cb_vars["protections_output_power_Over_current"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Over_current()
    if(cb_vars["protections_output_power_No_Current_Fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        No_Current_Fault()
    if(cb_vars["protections_output_power_precharge_fail_protection_before_relay"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        precharge_fail_protection_before_relay()
    # if(cb_vars["protections_output_power_precharge_fail_protection_after_relay"]==1):
    #     system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    #     precharge_fail_protection_after_relay()
    #     system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    
def check_protections_sensor_failure_1(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_sensor_failure_1_current_sensor_open_protection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        current_sensor_open_protection()
    if(cb_vars["protections_sensor_failure_1_Current_sensor_fail_faulty_offset"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Current_sensor_fail_faulty_offset()
    if(cb_vars["protections_sensor_failure_1_gun_temp_sensor_open_low_protection_1_2"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_sensor_open_low_protection_1_2()
    if(cb_vars["protections_sensor_failure_1_gun_temp_sensor_open_high_protection_1_2"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_sensor_open_high_protection_1_2()
    if(cb_vars["protections_sensor_failure_1_gun_temp_sensor_open_low_protection_3_4"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_sensor_open_low_protection_3_4()
    if(cb_vars["protections_sensor_failure_1_gun_temp_sensor_open_high_protection_3_4"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_sensor_open_high_protection_3_4()
    if(cb_vars["protections_sensor_failure_1_Positive_GunTempSense_lowside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Positive_GunTempSense_lowside_fault()
    if(cb_vars["protections_sensor_failure_1_Positive_GunTempSense_highside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Positive_GunTempSense_highside_fault()
    if(cb_vars["protections_sensor_failure_1_Negative_GunTempSense_lowside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Negative_GunTempSense_lowside_fault()
    if(cb_vars["protections_sensor_failure_1_Negative_GunTempSense_highside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Negative_GunTempSense_highside_fault()
    if(cb_vars["protections_sensor_failure_1_Hot_tank_Watertemp_sense_lowside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Hot_tank_Watertemp_sense_lowside_fault()
    if(cb_vars["protections_sensor_failure_1_Hot_tank_Watertemp_sense_highside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Hot_tank_Watertemp_sense_highside_fault()
    if(cb_vars["protections_sensor_failure_1_Cold_tank_Watertemp_sense_lowside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Cold_tank_Watertemp_sense_lowside_fault()
    if(cb_vars["protections_sensor_failure_1_Cold_tank_Watertemp_sense_highside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Cold_tank_Watertemp_sense_highside_fault()
    if(cb_vars["protections_sensor_failure_1_Inlet_Watertemp_sense_lowside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Inlet_Watertemp_sense_lowside_fault()
    if(cb_vars["protections_sensor_failure_1_Inlet_Watertemp_sense_highside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Inlet_Watertemp_sense_highside_fault()
    if(cb_vars["protections_sensor_failure_1_Outlet_Watertemp_sense_lowside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Outlet_Watertemp_sense_lowside_fault()
    if(cb_vars["protections_sensor_failure_1_Outlet_Watertemp_sense_highside_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Outlet_Watertemp_sense_highside_fault()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

def check_protections_sensor_failure_2(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_sensor_failure_2_charge_DC_contcator_open_protection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        charge_DC_contcator_open_protection()
    if(cb_vars["protections_sensor_failure_2_Charger_DC_polarity_reverse"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Charger_DC_polarity_reverse()
    if(cb_vars["protections_sensor_failure_2_CMS_48V_detection_circuit_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        CMS_48V_detection_circuit_fault()
    if(cb_vars["protections_sensor_failure_2_check_dc_contactor_weld_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        check_dc_contactor_weld_detection()
    if(cb_vars["protections_sensor_failure_2_check_dc_contactor_rev_weld_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        check_dc_contactor_rev_weld_detection()
    if(cb_vars["protections_sensor_failure_2_polarity_reverse_protection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        polarity_reverse_protection()
    if(cb_vars["protections_sensor_failure_2_BMS_contactor_weld_forward_protection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_contactor_weld_forward_protection()
    if(cb_vars["protections_sensor_failure_2_BMS_contactor_weld_rev_protection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_contactor_weld_rev_protection()
    if(cb_vars["protections_sensor_failure_2_BMS_contactor_open_protection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_contactor_open_protection()
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_1"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_low(num=1)
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_2"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_low(num=2)
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_3"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_low(num=3)
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_low_4"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_low(num=4)
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_1"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_high(num=1)
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_2"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_high(num=2)
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_3"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_high(num=3)
    if(cb_vars["protections_sensor_failure_2_GunTemp_Sense_Open_Warning_high_4"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunTemp_Sense_Open_Warning_high(num=4)
    if(cb_vars["protections_sensor_failure_2_Heater_Comm_Fail_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Heater_Comm_Fail_test()
    if(cb_vars["protections_sensor_failure_2_Chiller_Comm_Fail_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Chiller_Comm_Fail_test()
    if(cb_vars["protections_sensor_failure_2_EM_Comm_Fail_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        EM_Comm_Fail_test()
    if(cb_vars["protections_sensor_failure_2_smoke_sensor_detect_protection_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        smoke_sensor_detect_protection_test()
    if(cb_vars["protections_sensor_failure_2_phase_reversal_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        phase_reversal_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    if(cb_vars["protections_sensor_failure_2_current_sensor_Low_Temp"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        current_sensor_Low_Temp_fault_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    if(cb_vars["protections_sensor_failure_2_current_sensor_High_Temp"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        current_sensor_High_Temp_fault_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

def check_protections_mechanical(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_mechanical_chiller_faul_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_faul_detection() 
    if(cb_vars["protections_mechanical_chiller_aft_fault_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_aft_fault_detection() 
    if(cb_vars["protections_mechanical_AFT_fault_cms_computed_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        AFT_fault_cms_computed_fault() 
    if(cb_vars["protections_mechanical_chiller_hp_fault_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_hp_fault_detection() 
    if(cb_vars["protections_mechanical_chiller_low_liquid_level_fault_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_low_liquid_level_fault_detection() 
    if(cb_vars["protections_mechanical_chiller_recoverable_faul_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_recoverable_faul_detection() 
    if(cb_vars["protections_mechanical_chiller_LP_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_LP_fault() 
    if(cb_vars["protections_mechanical_chiller_compressor_overload_fault_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_compressor_overload_fault_test()    
    if(cb_vars["protections_mechanical_pump_overload_fault_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        pump_overload_fault_test() 
    if(cb_vars["protections_mechanical_chiller_non_recoverable_faul_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        chiller_non_recoverable_faul_detection() 
    if(cb_vars["protections_mechanical_Chiller_LiquidTemp_Inlet_outlet_water_temp_offset"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Chiller_LiquidTemp_Inlet_outlet_water_temp_offset() 
    if(cb_vars["protections_mechanical_battery_conditioning_fail_high_chiller_temp_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        battery_conditioning_fail_high_chiller_temp_test() 
    if(cb_vars["protections_mechanical_battery_conditioning_cooling_fail_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        battery_conditioning_cooling_fail_test()
    if(cb_vars["protections_mechanical_battery_conditioning_heating_fail_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        battery_conditioning_heating_fail_test()

    
    
    if(cb_vars["protections_mechanical_cold_tank_low_liquid_level_fault_detection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        cold_tank_low_liquid_level_fault_detection() 
    if(cb_vars["protections_mechanical_Fluid_Inlet_High_Temp_Fault_high_temp"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Fluid_Inlet_High_Temp_Fault_high_temp() 
    if(cb_vars["protections_mechanical_Fluid_Inlet_High_Temp_Fault_offset"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Fluid_Inlet_High_Temp_Fault_offset() 
    if(cb_vars["protections_mechanical_Chiller_Settings_Check"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Chiller_Setting_Error_test()    
       
    if(cb_vars["protections_mechanical_hot_tank_low_water_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        hot_tank_low_water_fault() 
    if(cb_vars["protections_mechanical_CMS_HotTank_Overtemp_protect_cms_sensor_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        CMS_HotTank_Overtemp_protect_cms_sensor_test() 
    if(cb_vars["protections_mechanical_CMS_HotTank_Overtemp_protect_heater_sensor_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        CMS_HotTank_Overtemp_protect_heater_sensor_test() 
    if(cb_vars["protections_mechanical_CMS_HotTank_Overtemp_cutoff_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        CMS_HotTank_Overtemp_cutoff_test() 
    if(cb_vars["protections_mechanical_heater_low_temp_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        heater_low_temp_fault() 
    if(cb_vars["protections_mechanical_heater_high_temp_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        heater_high_temp_fault() 
    if(cb_vars["protections_mechanical_CMS_HotTank_offset_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        CMS_HotTank_offset_test() 
    if(cb_vars["protections_mechanical_heater_low_water_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        heater_low_water_fault() 
    if(cb_vars["protections_mechanical_heater_probe_low_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        heater_probe_low_fault() 
    if(cb_vars["protections_mechanical_heater_probe_high_fault"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        heater_probe_high_fault() 
    if(cb_vars["protections_mechanical_mbv_open_fault_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        mbv_open_fault_test() 
    if(cb_vars["protections_mechanical_mbv_close_fault_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        mbv_close_fault_test() 
    if(cb_vars["protections_mechanical_Air_Comp_Overheat_Protection_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Air_Comp_Overheat_Protection_test() 
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    
def check_protections_charge_algo(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_charge_algo_station_cell_over_voltage"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        station_cell_over_voltage() 
    if(cb_vars["protections_charge_algo_station_over_temp"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        station_over_temp() 
    if(cb_vars["protections_charge_algo_station_under_temp"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        station_under_temp() 
    if(cb_vars["protections_charge_algo_imcomplete_charge"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        imcomplete_charge() 
    if(cb_vars["protections_charge_algo_station_pack_temp_ib"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        station_pack_temp_ib() 
    if(cb_vars["protections_charge_algo_station_pack_voltage_ib"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        station_pack_voltage_ib() 
    if(cb_vars["protections_charge_algo_tec_failure"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        tec_failure() 
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

def check_protections_cloud_interaction(HW_v=21,FW_v=839,c_count=102):
    # system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    # BMS_OTA_Cloud_Display_No_Response()
    if(cb_vars["protections_cloud_interaction_BMS_OTA_Dont_Do_Cmd"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_OTA_Dont_Do_Cmd() 
    if(cb_vars["protections_cloud_interaction_BMS_OTA_Bootloader_Start_Fail"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_OTA_Bootloader_Start_Fail() 
    if(cb_vars["protections_cloud_interaction_Vehicle_blacklisted"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        Vehicle_blacklisted() 
    if(cb_vars["protections_cloud_interaction_fut_protection_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        fut_protection_test() 
    if(cb_vars["protections_cloud_interaction_BMS_OTA_target_fw_unavailable"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_OTA_target_fw_unavailable()
    if(cb_vars["protections_cloud_interaction_BMS_flasher_error_check"].get()==1):    
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_flasher_error_check()    
    
    if(cb_vars["protections_cloud_interaction_BMS_only_BL_ota_check_available"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        check_ota_with_only_bootloader_FW_available()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    
    if(cb_vars["protections_cloud_interaction_BMS_only_BL_ota_check_no_FW"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        check_ota_with_only_bootloader_FW_not_available()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    
def check_protections_BMS_interaction(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_BMS_interaction_BMS_charge_protection_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_charge_protection_test() 
    if(cb_vars["protections_BMS_interaction_BMS_can_freeze_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_can_freeze_test() 
    # if(cb_vars["protections_BMS_interaction_BMS_state_error_test"].get()==1):
    #     system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    #     BMS_state_error_test() 
    #     system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    if(cb_vars["protections_BMS_interaction_BMS_wakeup_fail"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        BMS_Wakeup_Fail_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

def check_protections_gun_lock_unlock(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_gun_lock_unlock_unintentional_gun_unlock_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        unintentional_gun_unlock_test() 
    if(cb_vars["protections_gun_lock_unlock_GunLockFailed_1st_attempt"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        GunLockFailed_1st_attempt() 
    if(cb_vars["protections_gun_lock_unlock_unautharized_gun_removal"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        unautharized_gun_removal() 
    if(cb_vars["protections_gun_lock_unlock_unlock_failure"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        unlock_failure() 
    if(cb_vars["protections_gun_lock_unlock_gun_lock_fail_with_early_fb"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_lock_fail_with_early_fb() 
    if(cb_vars["protections_gun_lock_unlock_gun_theft_fault_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_theft_fault_test() 
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    if(cb_vars["protections_gun_lock_unlock_Gun_Locked_In_Air_partial_unlock"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_lock_in_air_partial_unlock_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    if(cb_vars["protections_gun_lock_unlock_Gun_Locked_In_Air_full_unlock"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_lock_in_air_full_unlock_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

def check_protections_gun_temp(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protections_gun_temp_gun_temp_ib_fault_1_2_B3"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_ib_fault(1,2,activation_val=22,deactivation_val=12,use_b3=1)
    if(cb_vars["protections_gun_temp_gun_temp_ib_fault_1_3_B3"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_ib_fault(1,3,activation_val=42,deactivation_val=38,use_b3=1)
    if(cb_vars["protections_gun_temp_gun_temp_ib_fault_3_4_B3"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
        gun_temp_ib_fault(3,4,activation_val=22,deactivation_val=12,use_b3=1)
    if(cb_vars["protections_gun_temp_gun_temp_ib_fault_1_2_TG"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_ib_fault(1,2,activation_val=22,deactivation_val=12,use_b3=0)
    if(cb_vars["protections_gun_temp_gun_temp_ib_fault_1_3_TG"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_ib_fault(1,3,activation_val=42,deactivation_val=38,use_b3=0)
    if(cb_vars["protections_gun_temp_gun_temp_ib_fault_3_4_TG"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
        gun_temp_ib_fault(3,4,activation_val=22,deactivation_val=12,use_b3=0)
    if(cb_vars["protections_gun_temp_gun_temp_ib_detect_1_2"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_ib_detect(1,2,activation_val=12,deactivation_val=8)
    if(cb_vars["protections_gun_temp_gun_temp_ib_detect_1_3"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_temp_ib_detect(1,3,activation_val=22,deactivation_val=16)
    if(cb_vars["protections_gun_temp_gun_temp_ib_detect_3_4"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
        gun_temp_ib_detect(3,4,activation_val=13,deactivation_val=8)
    if(cb_vars["protections_gun_temp_gun_over_temp_cutoff_all"].get()==1):    
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_over_temp_cutoff_all() 
    if(cb_vars["protections_gun_temp_gun_over_temp_warning_all"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        gun_over_temp_warning_all() 
    

def check_protection_actions(HW_v=21,FW_v=839,c_count=102):
    if(cb_vars["protection_actions_input_power_protection_action_standby_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        input_power_protection_action_standby_test()
    if(cb_vars["protection_actions_input_power_protection_action_charge_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        input_power_protection_action_charge_test()
    if(cb_vars["protection_actions_bms_protection_action_charge_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
        bms_protection_action_charge_test()
    if(cb_vars["protection_actions_e_plug_protection_action_charge_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
        e_plug_protection_action_charge_test()
    if(cb_vars["protection_actions_output_power_protection_action_standby_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        output_power_protection_action_standby_test()
    if(cb_vars["protection_actions_output_power_protection_action_charge_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
        output_power_protection_action_charge_test()
    if(cb_vars["protection_actions_fcs_battery_heating_action_charge_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        fcs_battery_heating_action_charge_test()
    if(cb_vars["protection_actions_fcs_internal_cooling_action_standby_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        fcs_internal_cooling_action_standby_test()
    if(cb_vars["protection_actions_fcs_internal_cooling_action_charge_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        fcs_internal_cooling_action_charge_test()
    if(cb_vars["protection_actions_fcs_battery_cooling_action_charge_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        fcs_battery_cooling_action_charge_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
      
   
def basic_charge_tests(HW_v=21,FW_v=839,c_count=102):
    
    #region Tg1 charge cycles
    if(cb_vars["charge_cycle_TG1_normal_charge_no_precondition"].get()==1):
        ## normal_charge_no_precondition
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_CHTZ_charge_no_precondition"].get()==1):

        # ## CHTZ_charge_no_precondition
        normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_normal_charge_no_precondition_voltage_ib_cutoff"].get()==1):
        ## normal_charge_no_precondition voltage ib cutoff no tec
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff"].get()==1):

        # ## CHTZ_charge_no_precondition voltage ib cutoff first step no tec
        normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step"].get()==1):
        # ## CHTZ_charge_no_precondition voltage ib cutoff last step tec
        normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1,voltage_ib_in_chtz_step=1)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_normal_charge_precooling"].get()==1):

        # system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        ## normal_charge_precooling
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=38,max_cell_t=39,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_CHTZ_charge_precooling"].get()==1):
        ## CHTZ_charge_precooling
        normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=38,max_cell_t=39,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)

    if(cb_vars["charge_cycle_TG1_normal_charge_preheating"].get()==1):
        ## normal_charge_preheating
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=6,max_cell_t=7,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_CHTZ_charge_preheating"].get()==1):
        # ## CHTZ_charge_preheating
        normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=6,max_cell_t=7,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    

    ######     ### normal charge, low temp, voltage ib at chtz ramp up
    ######     normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    ######                 base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    ######                 start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    ######                 voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=1,
    ######                 low_temp_chtz_step_em=0)
    ######     sleep(5)
    ###### if(cb_vars["protection_actions_fcs_battery_cooling_action_charge_test"].get()==1):
    
    ######     ### CHTZ charge, low temp, voltage ib at chtz ramp up
    ######     normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    ######                 base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    ######                 start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    ######                 voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=1,
    ######                 low_temp_chtz_step_em=0)
        
    ######     sleep(5)

    #####  ### normal charge, low temp, EM at chtz ramp up
    ##### normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    #####               base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    #####               start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    #####               voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
    #####               low_temp_chtz_step_em=1)
    ##### sleep(5)
    
    ##### ### CHTZ charge, low temp, EM at chtz ramp up
    ##### normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    #####               base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    #####               start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    #####               voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
    #####               low_temp_chtz_step_em=1)
    
    # sleep(5)

    

    #endregion

   
    #region Tg1-max charge cycles
    if(cb_vars["charge_cycle_TGM_normal_charge_no_precondition"].get()==1):
        ###### normal_charge_no_precondition
        normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TGM_CHTZ_charge_no_precondition"].get()==1):
        ####### CHTZ_charge_no_precondition
        normal_charge(chtz_flag=1,set_pack_varient=2,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TGM_normal_charge_no_precondition_voltage_ib_cutoff"].get()==1):
        ##### normal_charge_no_precondition voltage ib cutoff
        normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1)
        sleep(5)
    if(cb_vars["charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff"].get()==1):

        ###### CHTZ_charge_no_precondition voltage ib cutoff
        normal_charge(chtz_flag=1,set_pack_varient=2,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1)
        sleep(5)
    if(cb_vars["charge_cycle_TGM_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step"].get()==1):

        ###### CHTZ_charge_no_precondition voltage ib cutoff last step
        normal_charge(chtz_flag=1,set_pack_varient=2,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1,voltage_ib_in_chtz_step=1)
        sleep(5)
    if(cb_vars["charge_cycle_TGM_normal_charge_precooling"].get()==1):
        # system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        ###### normal_charge_precooling
        normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=38,max_cell_t=39,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TGM_CHTZ_charge_precooling"].get()==1):
        ###### CHTZ_charge_precooling
        normal_charge(chtz_flag=1,set_pack_varient=2,min_cell_t=38,max_cell_t=39,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)

    if(cb_vars["charge_cycle_TGM_normal_charge_preheating"].get()==1):
        ## normal_charge_preheating
        normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=6,max_cell_t=7,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TGM_CHTZ_charge_preheating"].get()==1):
        ## CHTZ_charge_preheating
        normal_charge(chtz_flag=1,set_pack_varient=2,min_cell_t=6,max_cell_t=7,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    ######## if(cb_vars["protection_actions_fcs_battery_cooling_action_charge_test"].get()==1):

    ########     ### normal charge, low temp, voltage ib at chtz ramp up
    ########     normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    ########                 base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    ########                 start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    ########                 voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=1,
    ########                 low_temp_chtz_step_em=0)
    ########     sleep(5)
    ######## if(cb_vars["protection_actions_fcs_battery_cooling_action_charge_test"].get()==1):
    ########     ### CHTZ charge, low temp, voltage ib at chtz ramp up
    ########     normal_charge(chtz_flag=1,set_pack_varient=2,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    ########                 base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    ########                 start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    ########                 voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=1,
    ########                 low_temp_chtz_step_em=0)
        
    ########     sleep(5)

    #######  ### normal charge, low temp, EM at chtz ramp up
    ####### normal_charge(chtz_flag=0,set_pack_varient=2,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    #######               base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    #######               start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    #######               voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
    #######               low_temp_chtz_step_em=1)
    ####### sleep(5)
    
    ####### ### CHTZ charge, low temp, EM at chtz ramp up
    ####### normal_charge(chtz_flag=1,set_pack_varient=2,min_cell_t=6,max_cell_t=7,chiller_temp=10,
    #######               base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
    #######               start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
    #######               voltage_ib_cutoff_check=0,voltage_ib_in_chtz_step=0,low_temp_chtz_step_voltage_ib=0,
    #######               low_temp_chtz_step_em=1)
    
    ####### sleep(5)


    #endregion

   
    #region B3 charge cycles
    if(cb_vars["charge_cycle_B3_normal_charge_no_precondition"].get()==1):
        ## normal_charge_no_precondition
        normal_charge(chtz_flag=0,set_pack_varient=0,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_B3_normal_charge_precooling"].get()==1):

        # system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        ## normal_charge_precooling
        normal_charge(chtz_flag=0,set_pack_varient=0,min_cell_t=41,max_cell_t=42,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    
    if(cb_vars["charge_cycle_B3_normal_charge_preheating"].get()==1):
        ## normal_charge_preheating
        normal_charge(chtz_flag=0,set_pack_varient=0,min_cell_t=15,max_cell_t=16,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
   
    

    #endregion

   #region 2 rectifiers off
    if(cb_vars["charge_cycle_TG1_normal_charge_no_precondition_10_rectifiers"].get()==1):
        ## Tg1 normal_charge_no_precondition
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=2,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)

   #endregion

   #region 6 rectifiers off
    if(cb_vars["charge_cycle_TG1_normal_charge_no_precondition_6_rectifiers"].get()==1):
    ## Tg1 normal_charge_no_precondition
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=6,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)

   #endregion

   #region TG1 v10.1 algo check
    if(cb_vars["charge_cycle_TG1_normal_charge_no_precondition_10.1_profile_cloud"].get()==1):
    # normal_charge_no_precondition
        master_swt_on()
        sleep(5)

        emulate_pack_id(400000420)
        sleep(2)
        

        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)

        emulate_pack_id(4000001)
        sleep(2)
    #endregion

        
    #region Tg1-430 charge cycles
    if(cb_vars["charge_cycle_TG1_430_normal_charge_no_precondition"].get()==1):
        ## normal_charge_no_precondition
        normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_430_CHTZ_charge_no_precondition"].get()==1):

        # ## CHTZ_charge_no_precondition
        normal_charge(chtz_flag=1,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_430_normal_charge_no_precondition_voltage_ib_cutoff"].get()==1):
        ## normal_charge_no_precondition voltage ib cutoff no tec
        normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1)
        sleep(5)

    if(cb_vars["charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff"].get()==1):
        # ## CHTZ_charge_no_precondition voltage ib cutoff first step no tec
        normal_charge(chtz_flag=1,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_430_CHTZ_charge_no_precondition_voltage_ib_cutoff_last_step"].get()==1):
        # ## CHTZ_charge_no_precondition voltage ib cutoff last step tec
        normal_charge(chtz_flag=1,set_pack_varient=3,min_cell_t=26,max_cell_t=27,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=1,voltage_ib_in_chtz_step=1)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_430_normal_charge_precooling"].get()==1):
        # system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
        ## normal_charge_precooling
        normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=38,max_cell_t=39,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_430_CHTZ_charge_precooling"].get()==1):
        ## CHTZ_charge_precooling
        normal_charge(chtz_flag=1,set_pack_varient=3,min_cell_t=38,max_cell_t=39,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)

    if(cb_vars["charge_cycle_TG1_430_normal_charge_preheating"].get()==1):
    
        ## normal_charge_preheating
        normal_charge(chtz_flag=0,set_pack_varient=3,min_cell_t=6,max_cell_t=7,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)
    if(cb_vars["charge_cycle_TG1_430_CHTZ_charge_preheating"].get()==1):
        # ## CHTZ_charge_preheating
        normal_charge(chtz_flag=1,set_pack_varient=3,min_cell_t=6,max_cell_t=7,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0)
        sleep(5)

    
    

    #endregion

    #region precooling with chiller fault TG1
    if(cb_vars["charge_cycle_TG1_normal_charge_precooling_chiller_failure"].get()==1):
    ## normal_charge_precooling chiller failure
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=38,max_cell_t=39,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,chiller_fault=1)
        sleep(5)
    
   #endregion

   #region preheating with heater fault TG1
    if(cb_vars["charge_cycle_TG1_normal_charge_preheating_heater_failure"].get()==1):
    ## normal_charge_preheating heater failure
        normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=6,max_cell_t=7,chiller_temp=10,
                    base_soc=20,rect_off=0,thermal_emulation_flag=1,drain_check=0,start_charge_min_t=-1,
                    start_charge_max_t=-1,fluid_check_flag=0,c_rate_check_flag=0,capacity_deration_check_flag=0,
                    voltage_ib_cutoff_check=0,heater_fault=1)
        sleep(5)
    
   #endregion


def parallel_drain_tests(HW_v=21,FW_v=839,c_count=102):

    #region 3.43 C

    # 3.43 - SOC 40 temp 34 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)   

   

    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=40,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
    
    
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    
    # 3.43 - SOC 96 temp 34 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)  

    

    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=96,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=-1,
                  start_charge_max_t=-1,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
     
   
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    #endregion

    #region 2C 

    
    # 2 - SOC 40 temp 41 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
   
    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=40,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=41,
                  start_charge_max_t=41,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
    
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    

    # 2 - SOC 96 temp 41 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)     

    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=96,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=41,
                  start_charge_max_t=41,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
       
    
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    #endregion

    #region 1C

   

    # 1 - SOC 40 temp 42 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
    
    
    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=40,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=42,
                  start_charge_max_t=42,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
    

    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    

    # 1 - SOC 96 temp 42 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)  

   
    
    normal_charge(chtz_flag=0,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=96,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=42,
                  start_charge_max_t=42,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
      
    
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    #endregion

    #region 0.26C

    # 0.26 - SOC 40 temp 28 - paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)  

    

    normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=40,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=28,
                  start_charge_max_t=28,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
      
   
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    # 0.26 - SOC 40 temp 33 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)   
    
    
    normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=40,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=33,
                  start_charge_max_t=33,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    # 0.26 - SOC 96 temp 28 - paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
    
    
    normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=96,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=28,
                  start_charge_max_t=28,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    # 0.26 - SOC 96 temp 33 - no paralllel drain
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)    
    normal_charge(chtz_flag=1,set_pack_varient=1,min_cell_t=33,max_cell_t=34,chiller_temp=10,heater_temp=50,
                  base_soc=96,rect_off=0,thermal_emulation_flag=0,drain_check=1,start_charge_min_t=33,
                  start_charge_max_t=33,fluid_check_flag=1,c_rate_check_flag=1,capacity_deration_check_flag=1)
    
    
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

    #endregion


def start_C_rate_with_heater_failure(HW_v=21,FW_v=839,c_count=102):
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    min_cell_temp_C_rate_test(min_cell_t=6,soc_base=40,exp_c_rate=0.12,heating_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    min_cell_temp_C_rate_test(min_cell_t=10,soc_base=40,exp_c_rate=0.3,heating_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    min_cell_temp_C_rate_test(min_cell_t=17,soc_base=40,exp_c_rate=0.5,heating_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    min_cell_temp_C_rate_test(min_cell_t=20,soc_base=40,exp_c_rate=1,heating_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    min_cell_temp_C_rate_test(min_cell_t=27,soc_base=40,exp_c_rate=2,heating_req=0)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    min_cell_temp_C_rate_test(min_cell_t=34,soc_base=40,exp_c_rate=3.43,heating_req=0)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    min_cell_temp_C_rate_test(min_cell_t=20,soc_base=75,exp_c_rate=0.5,heating_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

def start_C_rate_with_chiller_failure(HW_v=21,FW_v=839,c_count=102):
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=55,soc_base=40,exp_c_rate=0,
                              cold_tank_temp=15,cooling_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=48,soc_base=40,exp_c_rate=0.5,
                              cold_tank_temp=15,cooling_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=45,soc_base=40,exp_c_rate=1,
                              cold_tank_temp=15,cooling_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=41,soc_base=40,exp_c_rate=2,
                              cold_tank_temp=15,cooling_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=37,soc_base=40,exp_c_rate=2,
                              cold_tank_temp=25,cooling_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=37,soc_base=40,exp_c_rate=3.43,
                              cold_tank_temp=15,cooling_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=30,soc_base=70,exp_c_rate=3.43,
                              cold_tank_temp=15,cooling_req=0)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=30,soc_base=40,exp_c_rate=2,
                              cold_tank_temp=30,cooling_req=1)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=30,soc_base=40,exp_c_rate=3.43,
                              cold_tank_temp=15,cooling_req=0)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)
    max_cell_temp_C_rate_test(max_cell_t=20,soc_base=40,exp_c_rate=3.43,
                              cold_tank_temp=15,cooling_req=0)
    system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=c_count)

def algo_tests2(HW_v=21,FW_v=839,pack_varient=1):
    global chiller_fault_list   

    master_swt_on()
    sleep(5)
    emulate_bms_pack_varient(pack_varient)
    sleep(1)
    
    if(HW_v==21):   
        if(cb_vars["algo_TG1_fake_bms_current"].get()==1):     
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            fake_bms_current(b3_pack=0)  
        if(cb_vars["algo_TG1_check_voltage_ib_non_chtz_high_vol"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_non_chtz_high_vol(HW_v=HW_v)
        if(cb_vars["algo_TG1_check_voltage_ib_non_chtz_low_vol"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_non_chtz_low_vol(HW_v=HW_v)
        if(cb_vars["algo_TG1_check_voltage_ib_chtz_higher_voltage"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_chtz_higher_voltage(HW_v=HW_v)
        if(cb_vars["algo_TG1_check_voltage_ib_chtz_lower_voltage"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_chtz_lower_voltage(HW_v=HW_v)
        if(cb_vars["algo_TG1_check_chtz_0_0"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=0,base_chtz_count=0,HW_v=21) ### Y
        if(cb_vars["algo_TG1_check_chtz_4_0"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=4,base_chtz_count=0,HW_v=21) ### Y
        if(cb_vars["algo_TG1_check_chtz_7_0"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=7,base_chtz_count=0,HW_v=21) ### N
        if(cb_vars["algo_TG1_check_chtz_50_4"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=50.5,base_chtz_count=4,HW_v=21) ### Y
        if(cb_vars["algo_TG1_check_chtz_52_4"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=52,base_chtz_count=4,HW_v=21) ### N
        if(cb_vars["algo_TG1_check_chtz_60_51"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=60.8,base_chtz_count=51,HW_v=21) ### Y
        if(cb_vars["algo_TG1_check_chtz_61_60"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=61,base_chtz_count=60.8,HW_v=21) ### Y
        if(cb_vars["algo_TG1_check_chtz_104_100"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=104,base_chtz_count=100.8,HW_v=21) ### N
        if(cb_vars["algo_TG1_check_chtz_305_100"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=305,base_chtz_count=100.8,HW_v=21) ### Y
        if(cb_vars["algo_TG1_check_chtz_301_300"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=301,base_chtz_count=300,HW_v=21) ### Y
        if(cb_vars["algo_TG1_check_chtz_304_300"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=304,base_chtz_count=300,HW_v=21) ### N
        if(cb_vars["algo_TG1_min_cell_temp_computed_verification"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)            
            min_cell_temp_computed_verification()
        if(cb_vars["algo_TG1_bms_reset_ah"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
            bms_reset_ah()
        if(cb_vars["algo_TG1_bms_state_change_ah_non"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            bms_state_change_ah_non()
        if(cb_vars["algo_TG1_TEC_failure_wrong_ah"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            TEC_failure_wrong_ah()
        if(cb_vars["algo_TG1_TEC_failure_wrong_soc"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            TEC_failure_wrong_soc()
        if(cb_vars["algo_TG1_TEC_failure_wrong_soc_tollerance"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            TEC_failure_wrong_soc_tollerance()
        if(cb_vars["algo_TG1_user_soc_lock"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            user_soc_lock()    
        if(cb_vars["algo_TG1_gun_temp_current_deration_no_previos_cutoff"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
            gun_temp_current_deration_no_previos_cutoff()
        if(cb_vars["algo_TG1_gun_temp_current_deration_after_cutoff"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            gun_temp_current_deration_after_cutoff()
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        
    elif(HW_v==22): 
        if(cb_vars["algo_TGM_fake_bms_current"].get()==1):       
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            fake_bms_current(b3_pack=0)  
        if(cb_vars["algo_TGM_check_voltage_ib_non_chtz_high_vol"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_non_chtz_high_vol(HW_v=HW_v)
        if(cb_vars["algo_TGM_check_voltage_ib_non_chtz_low_vol"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_non_chtz_low_vol(HW_v=HW_v)
        if(cb_vars["algo_TGM_check_voltage_ib_chtz_higher_voltage"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_chtz_higher_voltage(HW_v=HW_v)
        if(cb_vars["algo_TGM_check_voltage_ib_chtz_lower_voltage"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_chtz_lower_voltage(HW_v=HW_v)
        if(cb_vars["algo_TGM_check_chtz_0_0"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=0,base_chtz_count=0,HW_v=21) ### Y
        if(cb_vars["algo_TGM_check_chtz_4_0"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=4,base_chtz_count=0,HW_v=21) ### Y
        if(cb_vars["algo_TGM_check_chtz_7_0"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=7,base_chtz_count=0,HW_v=21) ### N
        if(cb_vars["algo_TGM_check_chtz_50_4"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=50.5,base_chtz_count=4,HW_v=21) ### Y
        if(cb_vars["algo_TGM_check_chtz_52_4"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=52,base_chtz_count=4,HW_v=21) ### N
        if(cb_vars["algo_TGM_check_chtz_60_51"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=60.8,base_chtz_count=51,HW_v=21) ### Y
        if(cb_vars["algo_TGM_check_chtz_61_60"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=61,base_chtz_count=60.8,HW_v=21) ### Y
        if(cb_vars["algo_TGM_check_chtz_104_100"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=104,base_chtz_count=100.8,HW_v=21) ### N
        if(cb_vars["algo_TGM_check_chtz_305_100"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=305,base_chtz_count=100.8,HW_v=21) ### Y
        if(cb_vars["algo_TGM_check_chtz_301_300"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=301,base_chtz_count=300,HW_v=21) ### Y
        if(cb_vars["algo_TGM_check_chtz_304_300"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_chtz(base_c_count=304,base_chtz_count=300,HW_v=21) ### N
        if(cb_vars["algo_TGM_min_cell_temp_computed_verification"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)            
            min_cell_temp_computed_verification()
        if(cb_vars["algo_TGM_bms_reset_ah"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
            bms_reset_ah()
        if(cb_vars["algo_TGM_bms_state_change_ah_non"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            bms_state_change_ah_non()
        if(cb_vars["algo_TGM_TEC_failure_wrong_ah"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            TEC_failure_wrong_ah()
        if(cb_vars["algo_TGM_TEC_failure_wrong_soc"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            TEC_failure_wrong_soc()
        if(cb_vars["algo_TGM_TEC_failure_wrong_soc_tollerance"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            TEC_failure_wrong_soc_tollerance()
        if(cb_vars["algo_TGM_user_soc_lock"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            user_soc_lock()    
        if(cb_vars["algo_TGM_gun_temp_current_deration_no_previos_cutoff"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
            gun_temp_current_deration_no_previos_cutoff()
        if(cb_vars["algo_TGM_gun_temp_current_deration_after_cutoff"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            gun_temp_current_deration_after_cutoff()
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)

    elif(HW_v==2):   
        if(cb_vars["algo_B3_fake_bms_current"].get()==1):     
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            check_voltage_ib_non_chtz_high_vol(HW_v=HW_v)        
        if(cb_vars["algo_B3_check_voltage_ib_non_chtz_high_vol"].get()==1):
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            fake_bms_current(b3_pack=1)    
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    

def common_algo_tests(HW_v=21,FW_v=839):
    if(cb_vars["common_algo_check_max_rect_voltage"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
        check_max_rect_voltage()
    if(cb_vars["common_algo_master_error_code_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        master_error_code_test()
    if(cb_vars["common_algo_CP4V_debounce_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        CP4V_debounce_test() 
    if(cb_vars["common_algo_charge_algo_latching_check"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67) 
        charge_algo_latching_check()      
    if(cb_vars["common_algo_chiller_remote_off_before_aft"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        chiller_remote_off_before_aft()
    if(cb_vars["common_algo_chiller_remote_off_before_aft_during_precooling"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
        chiller_remote_off_before_aft_during_precooling()
    if(cb_vars["common_algo_persisting_epump_id"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
        persisting_epump_id()
    if(cb_vars["common_algo_session_conter_increment"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        session_conter_increment()
    if(cb_vars["common_algo_calage_sending_check"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        calage_sending_check()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_bms_wakeup"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        bms_wakeup_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_current_calibration_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        current_calibration_algo_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_dc_contactor_weld_check_skip"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
        dc_contactor_weld_check_skip_after_EM()        
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_gun_temp_current_deration_during_charge_false_TEC"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        gun_temp_current_deration_during_charge_false_TEC()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_false_tec_with_fast_gun_connection"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        false_tec_with_fast_gun_connection()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_reverse_cx_gun_lock"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        reverse_cx_gun_lock()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)    
    if(cb_vars["common_algo_gun_temp_sensor_open_rejection_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        gun_temp_sensor_open_rejection_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_gun_temp_deartion_table_TG_352"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        gun_temp_deration_table_test(pack_type=1)
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_gun_temp_deartion_table_TG_430"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        gun_temp_deration_table_test(pack_type=3)
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_gun_temp_deartion_table_TGmax"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        gun_temp_deration_table_test(pack_type=2)
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_gun_temp_deartion_table_B3"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        gun_temp_deration_table_test(pack_type=0)
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_pump_interlock"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        pump_interlock_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_min_temp_deration"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        current_deration_due_to_low_temp()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_max_temp_deration"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        current_deration_due_to_high_temp()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_can_fast_toggle_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        can_fast_toggle_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_can_slow_toggle_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        can_slow_toggle_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_fast_gun_toggle_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        fast_gun_toggle_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_slow_gun_toggle_test"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        slow_gun_toggle_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_fast_gun_toggle_before_charge"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        fast_gun_toggle_before_charge_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
    if(cb_vars["common_algo_slow_gun_toggle_before_charge"].get()==1):
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)        
        slow_gun_toggle_before_charge_test()
        system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)

    

    

consecutive_cycle_checkbox_mapping={
    'consecutive_charge_cycle_B3_matlab_B3_C_code':[0,1],
    'consecutive_charge_cycle_B3_matlab_TG_matlab':[0,2],
    'consecutive_charge_cycle_B3_matlab_TG_C':[0,3],
    'consecutive_charge_cycle_B3_matlab_TGmax_C':[0,4],
    'consecutive_charge_cycle_B3_matlab_TG_430_C':[0,5],
    'consecutive_charge_cycle_B3_C_B3_matlab_code':[1,0],
    'consecutive_charge_cycle_B3_C_TG_matlab':[1,2],
    'consecutive_charge_cycle_B3_C_TG_C':[1,3],
    'consecutive_charge_cycle_B3_C_TGmax_C':[1,4],
    'consecutive_charge_cycle_B3_C_TG_430_C':[1,5],
    'consecutive_charge_cycle_TG_matlab_B3_matlab_code':[2,0],
    'consecutive_charge_cycle_TG_matlab_B3_C':[2,1],
    'consecutive_charge_cycle_TG_matlab_TG_C':[2,3],
    'consecutive_charge_cycle_TG_matlab_TGmax_C':[2,4],
    'consecutive_charge_cycle_TG_matlab_TG_430_C':[2,5],
    'consecutive_charge_cycle_TG_C_B3_matlab_code':[3,0],
    'consecutive_charge_cycle_TG_C_B3_C':[3,1],
    'consecutive_charge_cycle_TG_C_TG_matlab':[3,2],
    'consecutive_charge_cycle_TG_C_TGmax_C':[3,4],
    'consecutive_charge_cycle_TG_C_TG_430_C':[3,5],
    'consecutive_charge_cycle_TGM_C_B3_matlab_code':[4,0],
    'consecutive_charge_cycle_TGM_C_B3_C':[4,1],
    'consecutive_charge_cycle_TGM_C_TG_matlab':[4,2],
    'consecutive_charge_cycle_TGM_C_TG1_C':[4,3],
    'consecutive_charge_cycle_TGM_C_TG_430_C':[4,5],
    'consecutive_charge_cycle_TG_430_C_B3_matlab_code':[5,0],
    'consecutive_charge_cycle_TG_430_C_B3_C':[5,1],
    'consecutive_charge_cycle_TG_430_C_TG_matlab':[5,2],
    'consecutive_charge_cycle_TG_430_C_TG1_C':[5,3],
    'consecutive_charge_cycle_TG_430_C_TGmax_C':[5,4],

}    

def consecutive_charge_cycles_tests(HW_v=21,FW_v=839):
    for k in consecutive_cycle_checkbox_mapping.keys():
        if(cb_vars[k].get()==1):
            i=consecutive_cycle_checkbox_mapping[k][0]
            j=consecutive_cycle_checkbox_mapping[k][1]
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)
            consecutive_charge_session_check(start_pack=i,second_pack=j)
            system_reset(HW_version=HW_v,FW_version=FW_v,cycle_count=67)

    


#endregion       

root.mainloop()

