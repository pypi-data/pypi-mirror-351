"""
Run command implementation for the CLI.
"""

import typer
import uvicorn
import logging
import sys
import importlib.util
from typing_extensions import Annotated
from typing import Optional

from ...utils import validate_source_path, validate_log_level
from ..config import CommonOptions

# Configure a logger for the CLI
cli_logger = logging.getLogger("mcp_sdk_cli.run")


def run_command(
    ctx: typer.Context,
    host: Annotated[
        str,
        typer.Option(
            help="Host to bind the server to.",
            rich_help_panel="Network Configuration",
        ),
    ] = "127.0.0.1",
    port: Annotated[
        int,
        typer.Option(
            help="Port to bind the server to (8000-8005 are reserved).",
            rich_help_panel="Network Configuration",
        ),
    ] = 8080,
    reload: Annotated[
        bool,
        typer.Option(
            help="Enable auto-reload for development.", rich_help_panel="Development"
        ),
    ] = False,
    workers: Annotated[
        Optional[int],
        typer.Option(
            help="Number of worker processes for uvicorn.",
            rich_help_panel="Development",
        ),
    ] = None,
):
    """
    Run an MCP service locally using Uvicorn.

    This command creates and runs an MCP service from your Python code. It's also used
    by the start.sh script generated by the 'package' command in the CLI-based approach.
    All configuration parameters can be passed via CLI options.
    """
    common_opts: CommonOptions = ctx.obj

    if common_opts.source_path is None:
        cli_logger.error("Source path is required but was not configured.")
        sys.exit(1)

    # Validate the source path before proceeding
    if not validate_source_path(common_opts.source_path, cli_logger):
        cli_logger.error(
            "Source path validation failed. Please check the path and ensure it contains valid Python files."
        )
        sys.exit(1)

    if common_opts.functions:
        cli_logger.info(f"Targeting specific functions: {common_opts.functions}")

    if common_opts.cors_enabled:
        cli_logger.info(
            f"CORS will be enabled. Allowing origins: {common_opts.cors_allow_origins}"
        )
    else:
        cli_logger.info("CORS will be disabled.")

    # Validate configuration combinations
    if common_opts.enable_event_store and common_opts.json_response:
        cli_logger.error(
            "Event store can only be used with SSE mode (json_response=False). Please disable either event store or JSON response mode."
        )
        sys.exit(1)

    # Validate legacy SSE mode compatibility
    if common_opts.legacy_sse:
        if common_opts.json_response:
            cli_logger.error(
                "Legacy SSE mode is incompatible with JSON response mode. Please disable --json-response when using --legacy-sse."
            )
            sys.exit(1)
        if common_opts.stateless_http:
            cli_logger.error(
                "Legacy SSE mode is incompatible with stateless HTTP mode. Please disable --stateless-http when using --legacy-sse."
            )
            sys.exit(1)

    # Log transport configuration
    transport_mode = "stateless" if common_opts.stateless_http else "stateful"
    response_format = "JSON" if common_opts.json_response else "SSE"
    cli_logger.info(
        f"Transport mode: {transport_mode}, Response format: {response_format}"
    )

    # Log event store configuration
    if common_opts.enable_event_store:
        event_store_path_info = common_opts.event_store_path or "./mcp_event_store.db"
        cli_logger.info(
            f"Event store will be enabled using SQLite database: {event_store_path_info}"
        )
    else:
        cli_logger.info("Event store will be disabled.")

    try:
        # Import FastMCP explicitly to check if it's available
        try:
            # Use importlib.util.find_spec instead of direct import
            if importlib.util.find_spec("fastmcp") is None:
                cli_logger.error("FastMCP module not found")
                cli_logger.error("Please install FastMCP with: pip install fastmcp")
                sys.exit(1)

            # Use importlib to explicitly access the module
            fastmcp_spec = importlib.util.find_spec("fastmcp")
            if fastmcp_spec and fastmcp_spec.loader:
                # Check if FastMCP is available without importing unused symbols
                fastmcp_module = importlib.util.module_from_spec(fastmcp_spec)
                fastmcp_spec.loader.exec_module(fastmcp_module)
                # Reference the module to prevent F401 warning
                _ = fastmcp_module
                # Mark as available and log success
                has_fastmcp = True
                cli_logger.info(f"FastMCP {fastmcp_spec.origin} successfully imported")
            else:
                cli_logger.error("FastMCP module not found or invalid")
                cli_logger.error("Please install FastMCP with: pip install fastmcp")
                sys.exit(1)
        except ImportError as e:
            cli_logger.error(f"FastMCP not available: {e}")
            cli_logger.error("Please install FastMCP with: pip install fastmcp")
            sys.exit(1)

        # Import the create_mcp_application function
        from ...app_builder import create_mcp_application
        from ...utils import TransformationError

        # Create the MCP application
        mcp_app = create_mcp_application(
            source_path_str=common_opts.source_path,
            target_function_names=common_opts.functions,
            mcp_server_name=common_opts.mcp_name,
            mcp_server_root_path=common_opts.server_root,
            mcp_service_base_path=common_opts.mcp_base,
            cors_enabled=common_opts.cors_enabled,
            cors_allow_origins=common_opts.cors_allow_origins,
            mode=common_opts.mode.lower(),
            enable_event_store=common_opts.enable_event_store,
            event_store_path=common_opts.event_store_path,
            stateless_http=common_opts.stateless_http,
            json_response=common_opts.json_response,
            legacy_sse=common_opts.legacy_sse,
        )

        if mcp_app is None and not has_fastmcp:
            cli_logger.error(
                "Failed to create MCP application: FastMCP is not available"
            )
            cli_logger.error("Please install FastMCP with: pip install fastmcp")
            sys.exit(1)

        cli_logger.info(
            f"MCP application '{common_opts.mcp_name}' created successfully."
        )
        cli_logger.info(
            f"Starting server on {host}:{port} with log level {common_opts.log_level}..."
        )

        # Validate and normalize the log level
        uvicorn_log_level = validate_log_level(common_opts.log_level, cli_logger)

        uvicorn.run(
            mcp_app,
            host=host,
            port=port,
            log_level=uvicorn_log_level,
            reload=reload,
            workers=workers if workers is not None and workers > 0 else None,
        )
    except TransformationError as e:
        cli_logger.error(f"Failed to create MCP application: {e}")
        cli_logger.error("Please check the source path and function definitions.")
        sys.exit(1)
    except FileNotFoundError as e:
        cli_logger.error(f"Source path error: {e}. Please ensure the path is correct.")
        sys.exit(1)
    except ImportError as e:
        cli_logger.error(f"Import error: {e}")
        cli_logger.error(
            "This may be due to missing dependencies or Python path issues."
        )
        sys.exit(1)
    except Exception as e:
        cli_logger.error(f"An unexpected error occurred: {e}", exc_info=True)
        sys.exit(1)
