# Generated from pot_http.es5.cjs
SCRIPT = '// Example input:\n// var embeddedInputData = {\n//     "port": 12345,\n//     "content_bindings": ["dQw4w9WgXcQ"]\n// };\n// embeddedInputData.ytAtR = JSON.parse(\'\\x7b\\x7d\');\nif (embeddedInputData.ytAtR !== null) {\n    console.log(\'globalName:\', embeddedInputData.ytAtR.bgChallenge.globalName);\n}\n\nvar globalObj = (typeof globalThis !== \'undefined\') ? globalThis :\n    (typeof global !== \'undefined\') ? global :\n        (typeof window !== \'undefined\') ? window :\n            (typeof self !== \'undefined\') ? self :\n                this;\n\nif ((typeof process !== \'undefined\') &&\n    (typeof process.versions.node !== \'undefined\')) {\n    var jsdom = require(\'jsdom\');\n    var dom = new jsdom.JSDOM();\n    Object.assign(globalObj, {\n        window: dom.window,\n        document: dom.window.document\n    });\n}\n\nfunction exit(code) {\n    if (typeof phantom !== \'undefined\') {\n        // phantom.exit();\n        phantom.exit(code);\n        // yt-dlp\'s PhantomJSwrapper relies on\n        // `\'phantom.exit();\' in jscode`\n    } else if (typeof process !== \'undefined\')\n        process.exit(code);\n}\n\nfunction compatFetch(resolve, reject, url, req) {\n    req = req || {};\n    req.method = req.method ? req.method.toUpperCase() : (req.body ? \'POST\' : \'GET\');\n    req.headers = req.headers || {};\n    req.body = req.body || null;\n    if (typeof fetch === \'function\') {\n        fetch(url, req).then(function (response) {\n            return {\n                ok: response.ok,\n                status: response.status,\n                url: response.url,\n                text: function (resolveInner, rejectInner) {\n                    response.text().then(resolveInner).catch(rejectInner);\n                },\n                json: function (resolveInner, rejectInner) {\n                    response.json().then(resolveInner).catch(rejectInner);\n                },\n                headers: {\n                    get: response.headers.get,\n                    _raw: response.headers\n                }\n            };\n        }).then(resolve).catch(reject);\n    } else if (typeof XMLHttpRequest !== \'undefined\') {\n        xhr = new XMLHttpRequest();\n        xhr.open(req.method, url, true);\n        for (var hdr in req.headers)\n            xhr.setRequestHeader(hdr, req.headers[hdr]);\n        var doneCallbacks = [];\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 2) {\n                resolve({\n                    ok: (xhr.status >= 200 && xhr.status < 300),\n                    status: xhr.status,\n                    url: xhr.responseUrl,\n                    text: function (resolveInner, rejectInner) {\n                        doneCallbacks.push(resolveInner);\n                    },\n                    json: function (resolveInner, rejectInner) {\n                        doneCallbacks.push(function (responseText) {\n                            var parsed;\n                            try {\n                                parsed = JSON.parse(responseText);\n                            } catch (err) {\n                                return rejectInner(err);\n                            }\n                            resolveInner(parsed);\n                        });\n                    },\n                    headers: {\n                        get: function (name) {\n                            return xhr.getResponseHeader(name);\n                        },\n                        _raw: xhr.getAllResponseHeaders()\n                    }\n                });\n            } else if (xhr.readyState === 4) {\n                doneCallbacks = doneCallbacks.filter(function (x) {\n                    if (x)\n                        x(xhr.responseText);\n                    return false;\n                });\n            }\n        };\n        xhr.onerror = function () {\n            reject(new Error(\'XHR failed\'));\n        };\n\n        if (req && typeof req.timeout === \'number\') {\n            xhr.timeout = req.timeout;\n        }\n\n        xhr.ontimeout = function () {\n            reject(new Error(\'XHR timed out\'));\n        };\n\n        try {\n            xhr.send(req.body);\n        } catch (err) {\n            reject(err);\n        }\n    } else {\n        reject(new Error(\'Could not find available networking API.\'));\n    }\n}\n\nvar base64urlToBase64Map = {\n    \'-\': \'+\',\n    _: \'/\',\n    \'.\': \'=\'\n};\n\nvar base64urlCharRegex = /[-_.]/g;\n\nfunction b64ToUTF8Arr(b64) {\n    var b64Mod;\n\n    if (base64urlCharRegex.test(b64)) {\n        b64Mod = base64.replace(base64urlCharRegex, function (match) {\n            return base64urlToBase64Map[match];\n        });\n    } else {\n        b64Mod = b64;\n    }\n    var b64Mod = atob(b64Mod);\n    var ret = [];\n    b64Mod.split(\'\').forEach(function (chr) {\n        ret.push(chr.charCodeAt(0));\n    });\n    return ret;\n}\n\nfunction UTF8ArrToB64(u8, b64Url) {\n    b64Url = (typeof b64Url === \'undefined\') ? false : b64Url;\n    var str = \'\';\n    Array.prototype.forEach.call(u8, function (chrCode) {\n        str += String.fromCharCode(chrCode);\n    });\n    var result = btoa(str);\n    if (b64Url) {\n        return result\n            .replace(/\\+/g, \'-\')\n            .replace(/\\//g, \'_\');\n    }\n    return result;\n}\n\nfunction encodeASCII(str) {\n    var ret = [];\n    str.split(\'\').forEach(function (chr) {\n        ret.push(chr.charCodeAt(0));\n    });\n    return ret;\n}\n\nfunction load(resolve, reject, vm, program, userInteractionElement) {\n    if (!vm)\n        reject(new Error(\'VM not found\'));\n    if (!vm.a)\n        reject(new Error(\'VM init function not found\'));\n    var vmFns;\n    var asyncResolved = false;\n    var syncResolved = false;\n    var syncSnapshotFunction;\n    function maybeDone() {\n        if (asyncResolved && syncResolved) {\n            resolve({\n                syncSnapshotFunction: syncSnapshotFunction,\n                vmFns: vmFns,\n            });\n        }\n    }\n    function vmFunctionsCallback(asyncSnapshotFunction, shutdownFunction, passEventFunction, checkCameraFunction) {\n        vmFns = {\n            asyncSnapshotFunction: asyncSnapshotFunction,\n            shutdownFunction: shutdownFunction,\n            passEventFunction: passEventFunction,\n            checkCameraFunction: checkCameraFunction\n        };\n        asyncResolved = true;\n        maybeDone();\n    }\n    syncSnapshotFunction = vm.a(program, vmFunctionsCallback, true, userInteractionElement, function () { }, [[], []])[0];\n    syncResolved = true;\n    maybeDone();\n}\n\nfunction snapshot(resolve, reject, vmFns, args, timeout) {\n    timeout = (typeof timeout === \'undefined\') ? 3000 : timeout;\n    var timeoutId;\n    function resolveWrapped(x) {\n        clearTimeout(timeoutId);\n        resolve(x);\n    }\n    function rejectWrapped(x) {\n        clearTimeout(timeoutId);\n        reject(x);\n    }\n    timeoutId = setTimeout(function () {\n        reject(new Error(\'VM operation timed out\'));\n    }, timeout);\n    if (!vmFns.asyncSnapshotFunction)\n        return rejectWrapped(new Error(\'Asynchronous snapshot function not found\'));\n    vmFns.asyncSnapshotFunction(function (response) { resolveWrapped(response) }, [\n        args.contentBinding,\n        args.signedTimestamp,\n        args.webPoSignalOutput,\n        args.skipPrivacyBuffer\n    ]);\n}\n\nfunction getWebSafeMinter(resolve, reject, integrityTokenData, webPoSignalOutput) {\n    var getMinter = webPoSignalOutput[0];\n    if (!getMinter)\n        reject(new Error(\'PMD:Undefined\'));\n    if (!integrityTokenData.integrityToken)\n        reject(new Error(\'No integrity token provided\'));\n    var mintCallback = getMinter(b64ToUTF8Arr(integrityTokenData.integrityToken));\n    if (typeof mintCallback !== \'function\')\n        reject(new Error(\'APF:Failed\'));\n    resolve(function (resolveInner, rejectInner, identifier) {\n        var result = mintCallback(encodeASCII(identifier));\n        if (!result)\n            rejectInner(new Error(\'YNJ:Undefined\'));\n        // do we need to test if result is a U8arr?\n        resolveInner(UTF8ArrToB64(result, true));\n    });\n}\n\nfunction buildPOTServerURL(path) {\n    return \'http://127.0.0.1:\'.concat(embeddedInputData.port, path);\n}\n\n(function () {\n    var identifiers = embeddedInputData.content_bindings;\n    if (!identifiers.length) {\n        console.log(\'[]\');\n        exit(0);\n    }\n    compatFetch(function (bgChallengeRaw) {\n        bgChallengeRaw.json(function (bgChallenge) {\n            if (!bgChallengeRaw.ok || !bgChallenge) {\n                console.error(\'Could not get challenge:\', (bgChallenge && bgChallenge.error) || \'\');\n                exit(1);\n            }\n\n            var interpreterJavascript = bgChallenge.interpreterJavascript.privateDoNotAccessOrElseSafeScriptWrappedValue;\n            if (interpreterJavascript) {\n                new Function(interpreterJavascript)();\n            } else {\n                console.error(\'Could not load VM\');\n                exit(1);\n            }\n\n            load(\n                function (bg) {\n                    var webPoSignalOutput = [];\n                    snapshot(function (botguardResponse) {\n                        compatFetch(function (integrityTokenResponse) {\n                            integrityTokenResponse.json(function (integrityTokenJson) {\n                                if (!integrityTokenResponse.ok || !integrityTokenJson) {\n                                    console.error(\'Failed to get integrity token response:\', (integrityTokenResponse && integrityTokenResponse.error) || \'\')\n                                    exit(1);\n                                }\n                                getWebSafeMinter(function (webSafeMinter) {\n                                    var pots = [];\n                                    function exitIfCompleted() {\n                                        if (Object.keys(pots).length == identifiers.length) {\n                                            console.log(JSON.stringify(pots));\n                                            exit(+(pots.indexOf(null) !== -1));\n                                        }\n                                    }\n                                    identifiers.forEach(function (identifier, idx) {\n                                        webSafeMinter(function (pot) {\n                                            pots[idx] = pot;\n                                            exitIfCompleted();\n                                        }, function (err) {\n                                            console.error(\n                                                \'Failed to mint web-safe POT for identifier \'.concat(identifier, \':\'), err);\n                                            pots[idx] = null;\n                                            exitIfCompleted();\n                                        }, identifier);\n                                    });\n                                }, function (err) {\n                                    console.error(\'Failed to get web-safe minter:\', err);\n                                    exit(1);\n                                }, integrityTokenJson, webPoSignalOutput);\n                            }, function (err) {\n                                console.error(\'Failed to parse JSON:\', err);\n                                exit(1);\n                            });\n                        }, function (err) {\n                            console.error(\'Failed to fetch integrity token response:\', err);\n                            exit(1);\n                        }, buildPOTServerURL(\'/genit\'), {\n                            method: \'POST\',\n                            body: JSON.stringify(botguardResponse)\n                        });\n                    }, function (err) {\n                        console.error(\'snapshot failed:\', err);\n                        exit(1);\n                    }, bg.vmFns, {\n                        webPoSignalOutput: webPoSignalOutput\n                    })\n                }, function (err) {\n                    console.error(\'Error loading VM\', err);\n                    exit(1);\n                },\n                globalObj[bgChallenge.globalName],\n                bgChallenge.program, bgChallenge.userInteractionElement);\n        }, function (err) {\n            console.error(\'Failed to parse challenge:\', err);\n            exit(1);\n        });\n    }, function (err) {\n        console.error(\'Failed to fetch challenge:\', err);\n        exit(1);\n    }, buildPOTServerURL(\'/descrambled\'));\n})();\n'
