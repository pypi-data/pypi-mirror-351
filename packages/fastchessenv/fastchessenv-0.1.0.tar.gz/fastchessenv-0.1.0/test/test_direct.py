"""
Test direct manipulation of en passant position
"""

import chess
import numpy as np

from chessenv.rep import CBoard, _ffi
from chessenv_c.lib import array_to_possible, fen_to_possible


def test_array_to_possible_directly():
    """Test array_to_possible function directly"""
    # Create a position with en passant
    fen = "4k3/8/8/8/Pp6/8/8/4K3 b - a3 0 1"
    print(f"Testing position: {fen}")

    # Create a python-chess board for reference (not used directly but kept for reference)
    _ = chess.Board(fen)

    # Convert to CBoard and get the array representation
    cboard = CBoard.from_fen(fen)
    board_arr = cboard.to_array()

    # Check if en passant square is present in array
    has_ep = False
    for i in range(64):
        if board_arr[i] == 13:  # 13 is the code for en passant square
            rank = 7 - (i // 8)
            file = i % 8
            print(
                f"Found en passant marker at rank={rank}, file={file} (array index {i})"
            )
            has_ep = True

    if not has_ep:
        print("WARNING: No en passant marker found in the array!")

    # Call array_to_possible directly
    max_moves = 256
    moves_buffer = np.zeros(max_moves * 5, dtype=np.int32)

    array_to_possible(
        _ffi.cast("int *", moves_buffer.ctypes.data),
        _ffi.cast("int *", board_arr.ctypes.data),
    )

    # Count the moves
    num_moves = 0
    for i in range(0, moves_buffer.shape[0], 5):
        if np.sum(moves_buffer[i : i + 5]) > 0:
            num_moves += 1
        else:
            break

    # Extract the moves
    valid_moves = moves_buffer[: num_moves * 5].copy()

    # Convert to move strings
    move_strings = []
    for i in range(0, valid_moves.shape[0], 5):
        move_arr = valid_moves[i : i + 5]
        move_str = ""

        # File names
        files = "abcdefgh"
        # Rank numbers
        ranks = "12345678"

        from_file = files[move_arr[0]] if 0 <= move_arr[0] < 8 else "?"
        from_rank = ranks[move_arr[1]] if 0 <= move_arr[1] < 8 else "?"
        to_file = files[move_arr[2]] if 0 <= move_arr[2] < 8 else "?"
        to_rank = ranks[move_arr[3]] if 0 <= move_arr[3] < 8 else "?"

        move_str = f"{from_file}{from_rank}{to_file}{to_rank}"

        # Add promotion piece if needed
        if move_arr[4] > 0:
            promotion_pieces = " nbrq"
            move_str += promotion_pieces[move_arr[4]]

        move_strings.append(move_str)

    print(f"Moves generated by array_to_possible: {move_strings}")
    print(f"Total moves: {len(move_strings)}")

    # Test with fen_to_possible directly
    moves_buffer2 = np.zeros(max_moves * 5, dtype=np.int32)
    fen_bytes = fen.encode("utf-8")
    fen_ptr = _ffi.new(f"char[{len(fen_bytes) + 1}]", fen_bytes)

    fen_to_possible(_ffi.cast("int *", moves_buffer2.ctypes.data), fen_ptr)

    # Count the moves
    num_moves2 = 0
    for i in range(0, moves_buffer2.shape[0], 5):
        if np.sum(moves_buffer2[i : i + 5]) > 0:
            num_moves2 += 1
        else:
            break

    # Extract the moves
    valid_moves2 = moves_buffer2[: num_moves2 * 5].copy()

    # Convert to move strings
    move_strings2 = []
    for i in range(0, valid_moves2.shape[0], 5):
        move_arr = valid_moves2[i : i + 5]
        move_str = ""

        from_file = files[move_arr[0]] if 0 <= move_arr[0] < 8 else "?"
        from_rank = ranks[move_arr[1]] if 0 <= move_arr[1] < 8 else "?"
        to_file = files[move_arr[2]] if 0 <= move_arr[2] < 8 else "?"
        to_rank = ranks[move_arr[3]] if 0 <= move_arr[3] < 8 else "?"

        move_str = f"{from_file}{from_rank}{to_file}{to_rank}"

        # Add promotion piece if needed
        if move_arr[4] > 0:
            promotion_pieces = " nbrq"
            move_str += promotion_pieces[move_arr[4]]

        move_strings2.append(move_str)

    print(f"Moves generated by fen_to_possible: {move_strings2}")
    print(f"Total moves: {len(move_strings2)}")

    # Compare with standard CBoard
    std_moves = cboard.to_possible_moves().to_str()
    print(f"Moves from CBoard.to_possible_moves: {std_moves}")
    print(f"Total moves: {len(std_moves)}")

    # Check for en passant move
    ep_move = "b4a3"
    print(
        f"En passant move {ep_move} in array_to_possible output: {ep_move in move_strings}"
    )
    print(
        f"En passant move {ep_move} in fen_to_possible output: {ep_move in move_strings2}"
    )
    print(f"En passant move {ep_move} in CBoard output: {ep_move in std_moves}")


if __name__ == "__main__":
    test_array_to_possible_directly()
