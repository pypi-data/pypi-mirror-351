Metadata-Version: 2.4
Name: llm-tool-fusion
Version: 0.2.1
Summary: Biblioteca Python que simplifica e unifica a defini√ß√£o e chamada de ferramentas para grandes modelos de linguagem (LLMs). Compat√≠vel com Ollama, LangChain, OpenAI e outros frameworks.
Home-page: https://github.com/caua1503/llm-tool-fusion
Author: Caua ramos
Author-email: cauamedinax@gmail.com
Requires-Python: >=3.12
Description-Content-Type: text/markdown
License-File: LICENSE
Dynamic: author
Dynamic: author-email
Dynamic: home-page
Dynamic: license-file

# llm-tool-fusion

<div align="center">
  <img src="logo.png" alt="LLM Tool Fusion Logo" width="300">
</div>

<div align="center">

[![Python](https://img.shields.io/badge/python->=3.12-blue.svg)](https://www.python.org/downloads/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Version](https://img.shields.io/badge/version-0.2.0-orange.svg)](pyproject.toml)

</div>

## üáßüá∑ Portugu√™s

### üìñ Descri√ß√£o

**llm-tool-fusion** √© uma biblioteca Python que simplifica e unifica a defini√ß√£o e chamada de ferramentas para grandes modelos de linguagem (LLMs). Compat√≠vel com frameworks populares que suportam tool calling, como Ollama, LangChain e OpenAI, ela permite integrar facilmente novas fun√ß√µes e m√≥dulos, tornando o desenvolvimento de aplicativos avan√ßados de IA mais √°gil e modular atraves de decoradores de fun√ß√µes.

### ‚ú® Principais Recursos

- üîß **Unifica√ß√£o de APIs**: Interface √∫nica para diferentes frameworks de LLM
- üöÄ **Integra√ß√£o Simplificada**: Adicione novas ferramentas com facilidade
- üîó **Compatibilidade Ampla**: Suporte para Ollama, LangChain, OpenAI e outros
- üì¶ **Modularidade**: Arquitetura modular para desenvolvimento escal√°vel
- ‚ö° **Performance**: Otimizado para aplica√ß√µes em produ√ß√£o
- üìù **Menos Verbosidade**: Sintaxe simplificada para declara√ß√£o de fun√ß√µes
- üîÑ **Processamento Autom√°tico**: Execu√ß√£o autom√°tica de chamadas de ferramentas (opcional)

### üöÄ Instala√ß√£o

```bash
pip install llm-tool-fusion
```

### üìã Uso B√°sico (Exemplo com OpenAI)

```python
from openai import OpenAI
from llm_tool_fusion import ToolCaller, process_tool_calls

# Inicializa o cliente OpenAI e o gerenciador de ferramentas
client = OpenAI()
manager = ToolCaller()

# Define uma ferramenta usando o decorador
@manager.tool
def calculate_price(price: float, discount: float) -> float:
    """
    Calcula o pre√ßo final com desconto
    
    Args:
        price (float): Pre√ßo base
        discount (float): Percentual de desconto
        
    Returns:
        float: Pre√ßo final com desconto
    """
    return price * (1 - discount / 100)

# Prepara a mensagem e faz a chamada ao LLM
messages = [
    {"role": "user", "content": "Calcule o pre√ßo final de um produto de R$100 com 20% de desconto"}
]

# Primeira chamada ao LLM
response = client.chat.completions.create(
    model="gpt-4",
    messages=messages,
    tools=manager.get_tools()
)

available_tools = manager.get_map_tools()
async_available_tools = manager.get_name_async_tools()
    
# Processamento manual das chamadas de ferramentas
if response.choices[0].message.tool_calls:
    tool_results = []
    for tool_call in response.choices[0].message.tool_calls:
        if tool_call.function.name in available_tools:
            # Execu√ß√£o manual da ferramenta
            import json
            args = json.loads(tool_call.function.arguments)

            #verifica√ß√£o se a ferramenta e assincrona
            result = available_tools[tool_call.function.name](**args) if tool_call.function.name not in async_available_tools else asyncio.run(available_tools[tool_call.function.name](**args)) 
                
            # Coloca os resultados em uma lista
            tool_results.append({
                "role": "tool",
                "tool_call_id": tool_call.id,
                "name": tool_call.function.name,
                "content": str(result)
            })
        
    # Adiciona todas as respostas de uma vez
    messages.append(response.choices[0].message)
    messages.extend(tool_results)
        
    # Nova chamada para processar o resultado
    final_response = client.chat.completions.create(
        model=default_model,
        messages=messages
    )
            
    return final_response.choices[0].message.content

print(final_response)
```

### üîÑ Processamento Autom√°tico de Chamadas

O llm-tool-fusion oferece um sistema robusto e simples para processar chamadas de ferramentas (instru√ß√µes de uso em examples):

```python
# Fun√ß√£o para chamadas ao LLM
llm_call_fn = lambda model, messages, tools: client.chat.completions.create(
    model=model, 
    messages=messages, 
    tools=tools
)

# Processamento autom√°tico de chamadas
final_response = process_tool_calls(
    response=response,           # Resposta inicial do LLM
    messages=messages,           # Hist√≥rico de mensagens
    tool_caller=manager,         # Inst√¢ncia do ToolCaller
    model="gpt-4",              # Modelo a ser usado
    llm_call_fn=llm_call_fn,    # Fun√ß√£o de chamada ao LLM
    verbose=True,               # (opcional) Logs detalhados
    verbose_time=True,          # (opcional) M√©tricas de tempo
    clean_messages=True,        # (opcional) Retorna apenas o conte√∫do da mensagem
    use_async_poll=False,       # (opcional) Executa ferramentas ass√≠ncronas em paralelo
    max_chained_calls=5         # (opcional) M√°ximo de chamadas encadeadas
)
```

#### üéØ Par√¢metros Principais

- **`response`** (obrigat√≥rio): Resposta inicial do modelo
- **`messages`** (obrigat√≥rio): Lista de mensagens do chat
- **`tool_caller`** (obrigat√≥rio): Inst√¢ncia da classe ToolCaller
- **`model`** (obrigat√≥rio): Nome do modelo
- **`llm_call_fn`** (obrigat√≥rio): Fun√ß√£o que faz a chamada ao modelo

#### ‚öôÔ∏è Par√¢metros Opcionais

- **`verbose`**: Exibe logs detalhados da execu√ß√£o
- **`verbose_time`**: Mostra m√©tricas de tempo de execu√ß√£o
- **`clean_messages`**: Retorna apenas o conte√∫do da mensagem final
- **`use_async_poll`**: Executa ferramentas ass√≠ncronas em paralelo para melhor performance
- **`max_chained_calls`**: Limite de chamadas encadeadas (padr√£o: 5)

#### ‚ö° Performance com `use_async_poll`

Quando voc√™ tem m√∫ltiplas ferramentas ass√≠ncronas sendo chamadas simultaneamente, o par√¢metro `use_async_poll=True` oferece melhor performance:

```python
# Sem async_poll: ferramentas executam sequencialmente
final_response = process_tool_calls(
    # ... outros par√¢metros ...
    use_async_poll=False  # Padr√£o: execu√ß√£o sequencial
)

# Com async_poll: ferramentas ass√≠ncronas executam em paralelo
final_response = process_tool_calls(
    # ... outros par√¢metros ...
    use_async_poll=True   # Execu√ß√£o paralela para melhor performance
)
```

#### ‚ú® Caracter√≠sticas Principais

- üîÅ **Ciclo Autom√°tico**: Processa todas as chamadas de ferramentas at√© a conclus√£o
- ‚ö° **Suporte Ass√≠ncrono**: Executa ferramentas s√≠ncronas e ass√≠ncronas automaticamente
- üìù **Logs Inteligentes**: Acompanhe a execu√ß√£o com logs detalhados e m√©tricas de tempo
- üõ°Ô∏è **Tratamento de Erros**: Gerenciamento robusto de erros durante a execu√ß√£o
- üí¨ **Gest√£o de Contexto**: Mant√©m o hist√≥rico de conversas organizado
- üîß **Configur√°vel**: Personalize o comportamento conforme sua necessidade

#### üöÄ Vers√£o Ass√≠ncrona

Para aplica√ß√µes que precisam de processamento ass√≠ncrono:

```python
# Processamento ass√≠ncrono de chamadas
final_response = await process_tool_calls_async(
    response=response,
    messages=messages,
    tool_caller=manager,
    model="gpt-4",
    llm_call_fn=async_llm_call_fn,
    verbose=True,
    use_async_poll=True  # Recomendado para melhor performance
)
```

#### üîß Suporte a Frameworks

O sistema funciona com diferentes frameworks atrav√©s do par√¢metro `framework` no `ToolCaller`:

```python
# Para OpenAI (padr√£o)
manager = ToolCaller(framework="openai")

# Para Ollama
manager = ToolCaller(framework="ollama")
llm_call_fn = lambda model, messages, tools: ollama.Client().chat(
    model=model,
    messages=messages,
    tools=tools
)
```

### üîß Frameworks Suportados

- **OpenAI** - API oficial e modelos GPT
- **LangChain** - Framework completo para aplica√ß√µes LLM
- **Ollama** - Execu√ß√£o local de modelos
- **Anthropic Claude** - API da Anthropic
- **E muito mais...**

### ü§ù Contribui√ß√£o

Contribui√ß√µes s√£o bem-vindas! Por favor:

1. Fa√ßa um fork do projeto
2. Crie uma branch para sua feature (`git checkout -b feature/AmazingFeature`)
3. Commit suas mudan√ßas (`git commit -m 'Add some AmazingFeature'`)
4. Push para a branch (`git push origin feature/AmazingFeature`)
5. Abra um Pull Request

### üìÑ Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT - veja o arquivo [LICENSE](LICENSE) para detalhes.

---

## üá∫üá∏ English

### üìñ Description

**llm-tool-fusion** is a Python library that simplifies and unifies the definition and calling of tools for large language models (LLMs). Compatible with popular frameworks that support tool calling, such as Ollama, LangChain, and OpenAI, it allows you to easily integrate new functions and modules, making the development of advanced AI applications more agile and modular through function decorators.

### ‚ú® Key Features

- üîß **API Unification**: Single interface for different LLM frameworks
- üöÄ **Simplified Integration**: Add new tools with ease
- üîó **Wide Compatibility**: Support for Ollama, LangChain, OpenAI, and others
- üì¶ **Modularity**: Modular architecture for scalable development
- ‚ö° **Performance**: Optimized for production applications
- üìù **Less Verbosity**: Simplified syntax for function declarations
- üîÑ **Automatic Processing**: Automatic execution of tool calls (optional)

### üöÄ Installation

```bash
pip install llm-tool-fusion
```

### üìã Basic Usage (Example with OpenAI)

```python
from openai import OpenAI
from llm_tool_fusion import ToolCaller, process_tool_calls

# Initialize OpenAI client and tool manager
client = OpenAI()
manager = ToolCaller()

# Define a tool using the decorator
@manager.tool
def calculate_price(price: float, discount: float) -> float:
    """
    Calculate final price with discount
    
    Args:
        price (float): Base price
        discount (float): Discount percentage
        
    Returns:
        float: Final price with discount
    """
    return price * (1 - discount / 100)

# Prepare message and make LLM call
messages = [
    {"role": "user", "content": "Calculate the final price of a $100 product with 20% discount"}
]

# First LLM call
response = client.chat.completions.create(
    model="gpt-4",
    messages=messages,
    tools=manager.get_tools()
)

available_tools = manager.get_map_tools()
async_available_tools = manager.get_name_async_tools()
    
# Manual processing of tool calls
if response.choices[0].message.tool_calls:
    tool_results = []
    for tool_call in response.choices[0].message.tool_calls:
        if tool_call.function.name in available_tools:
            # Manual tool execution
            import json
            args = json.loads(tool_call.function.arguments)

print(final_response)
```

### üîÑ Automatic Call Processing

llm-tool-fusion provides a robust and simple system for processing tool calls automatically:

```python
# Function for LLM calls
llm_call_fn = lambda model, messages, tools: client.chat.completions.create(
    model=model, 
    messages=messages, 
    tools=tools
)

# Automatic tool call processing
final_response = process_tool_calls(
    response=response,           # Initial response from the LLM
    messages=messages,           # Message history
    tool_caller=manager,         # ToolCaller instance
    model="gpt-4",              # Model to be used
    llm_call_fn=llm_call_fn,    # Function to call the LLM
    verbose=True,               # (optional) Detailed logs
    verbose_time=True,          # (optional) Time metrics
    clean_messages=True,        # (optional) Returns only message content
    use_async_poll=False,       # (optional) Execute async tools in parallel
    max_chained_calls=5         # (optional) Maximum chained calls
)
```

#### üéØ Main Parameters

- **`response`** (required): Initial response from the model
- **`messages`** (required): List of chat messages
- **`tool_caller`** (required): ToolCaller class instance
- **`model`** (required): Model name
- **`llm_call_fn`** (required): Function that calls the model

#### ‚öôÔ∏è Optional Parameters

- **`verbose`**: Shows detailed execution logs
- **`verbose_time`**: Shows execution time metrics
- **`clean_messages`**: Returns only the final message content
- **`use_async_poll`**: Executes async tools in parallel for better performance
- **`max_chained_calls`**: Limit of chained calls (default: 5)

#### ‚ö° Performance with `use_async_poll`

When you have multiple asynchronous tools being called simultaneously, the `use_async_poll=True` parameter offers better performance:

```python
# Without async_poll: tools execute sequentially
final_response = process_tool_calls(
    # ... other parameters ...
    use_async_poll=False  # Default: sequential execution
)

# With async_poll: async tools execute in parallel
final_response = process_tool_calls(
    # ... other parameters ...
    use_async_poll=True   # Parallel execution for better performance
)
```

#### ‚ú® Main Features

- üîÅ **Automatic Loop**: Processes all tool calls to completion
- ‚ö° **Asynchronous Support**: Runs synchronous and asynchronous tools automatically
- üìù **Smart Logs**: Track execution with detailed logs and time metrics
- üõ°Ô∏è **Error Handling**: Robust error management during execution
- üí¨ **Context Management**: Keeps conversation history organized
- üîß **Configurable**: Customize behavior to your needs

#### üöÄ Asynchronous Version

For applications that need asynchronous processing:

```python
# Asynchronous processing of tool calls
final_response = await process_tool_calls_async(
    response=response,
    messages=messages,
    tool_caller=manager,
    model="gpt-4",
    llm_call_fn=async_llm_call_fn,
    verbose=True,
    use_async_poll=True  # Recommended for better performance
)
```

#### üîß Framework Support

The system works with different frameworks through the `framework` parameter in `ToolCaller`:

```python
# For OpenAI (default)
manager = ToolCaller(framework="openai")

# For Ollama
manager = ToolCaller(framework="ollama")
llm_call_fn = lambda model, messages, tools: ollama.Client().chat(
    model=model,
    messages=messages,
    tools=tools
)
```

### üîß Supported Frameworks

- **OpenAI** - Official API and GPT models
- **LangChain** - Complete framework for LLM applications
- **Ollama** - Local model execution
- **Anthropic Claude** - Anthropic's API
- **And many more...**

### ü§ù Contributing

Contributions are welcome! Please:

1. Fork the project
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

### üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## üõ†Ô∏è Development

### Prerequisites

- Python >= 3.12
- pip or poetry for dependency management

### Setup Development Environment

```bash
# Clone the repository
git clone https://github.com/caua1503/llm-tool-fusion.git
cd llm-tool-fusion

# Install dependencies
pip install -e .

# Run tests
python -m pytest
```

### Project Structure

```
llm-tool-fusion/
‚îú‚îÄ‚îÄ llm_tool_fusion/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
|   ‚îî‚îÄ‚îÄ _core.py
|   ‚îî‚îÄ‚îÄ _utils.py
‚îÇ      
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ examples/
‚îú‚îÄ‚îÄ pyproject.toml
‚îî‚îÄ‚îÄ README.md
```

---

**‚≠ê Se este projeto foi √∫til para voc√™, considere dar uma estrela no GitHub!**

**‚≠ê If this project was helpful to you, consider starring it on GitHub!**
